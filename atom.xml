<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MiChong的🏡</title>
  <icon>https://www.gravatar.com/avatar/4ad4fe3a4357a29a236338cca3ee2045</icon>
  
  <link href="https://www.buildworld.cn/atom.xml" rel="self"/>
  
  <link href="https://www.buildworld.cn/"/>
  <updated>2021-11-04T15:50:08.385Z</updated>
  <id>https://www.buildworld.cn/</id>
  
  <author>
    <name>MiChong</name>
    <email>qjzxzxd@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动设计学习</title>
    <link href="https://www.buildworld.cn/2021/11/04/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.buildworld.cn/2021/11/04/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-04T15:27:21.000Z</published>
    <updated>2021-11-04T15:50:08.385Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>小傅哥博客读后感：<a href="https://bugstack.cn/">https://bugstack.cn</a></p><h2 id="一、初识领域驱动设计"><a href="#一、初识领域驱动设计" class="headerlink" title="一、初识领域驱动设计"></a>一、初识领域驱动设计</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><blockquote><p><strong>DDD（Domain-Driven Design 领域驱动设计）</strong>是由 Eric Evans 最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。整个过程大概是这样的，开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。</p></blockquote><p><img src="https://file.buildworld.cn/img/20211104225640.png"></p><blockquote><p>依靠领域驱动设计的设计思想，通过事件风暴建立领域模型，合理划分领域逻辑和物理边界，建立领域对象及服务矩阵和服务架构图，定义符合 DDD 分层架构思想的代码结构模型，保证业务模型与代码模型的一致性。通过上述设计思想、方法和过程，指导团队按照 DDD 设计思想完成微服务设计和开发。</p><ol><li>拒绝泥球小单体、拒绝污染功能与服务、拒绝一加功能排期一个月</li><li>架构出高可用极易符合互联网高速迭代的应用服务</li><li>物料化、组装化、可编排的服务，提高人效</li></ol></blockquote><h3 id="2、服务架构"><a href="#2、服务架构" class="headerlink" title="2、服务架构"></a>2、服务架构</h3><p><img src="https://file.buildworld.cn/img/20211104225650.png" alt="四层架构"></p><h4 id="应用层-application"><a href="#应用层-application" class="headerlink" title="应用层{application}"></a>应用层{application}</h4><blockquote><ol><li>应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。</li><li>应用层的服务包括应用服务和领域事件相关服务。</li><li>应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。</li><li>领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。</li></ol></blockquote><h4 id="领域层-domain"><a href="#领域层-domain" class="headerlink" title="领域层{domain}"></a>领域层{domain}</h4><blockquote><ol><li>领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。</li><li>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。</li><li>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。</li><li>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。</li></ol></blockquote><h4 id="基础层-infrastructrue"><a href="#基础层-infrastructrue" class="headerlink" title="基础层{infrastructrue}"></a>基础层{infrastructrue}</h4><ul><li><p>基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。</p></li><li><p>基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。</p></li><li><pre><code class="xml">向其他层提供 通用的 技术能力(比如工具类,第三方库类支持,常用基本配置,数据访问底层实现)基础实施层主要包含以下的内容:    * 为应用层 传递消息(比如通知)    * 为领域层 提供持久化机制(最底层的实现)    * 为用户界面层 提供组件配置    * 基础设施层还能够通过架构框架来支持四个层次间的交互模式。</code></pre></li></ul><h4 id="接口层-interfaces"><a href="#接口层-interfaces" class="headerlink" title="接口层{interfaces}"></a>接口层{interfaces}</h4><ul><li>接口服务位于用户接口层，用于处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给应用层。</li></ul><h3 id="3、DDD-代码落地"><a href="#3、DDD-代码落地" class="headerlink" title="3、DDD 代码落地"></a>3、DDD 代码落地</h3><p><img src="https://file.buildworld.cn/img/20211104232530.png"></p>]]></content>
    
    
    <summary type="html">DDD（Domain-Driven Design 领域驱动设计）是由Eric Evans最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。</summary>
    
    
    
    <category term="后端" scheme="https://www.buildworld.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://www.buildworld.cn/tags/Java/"/>
    
    <category term="架构设计" scheme="https://www.buildworld.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>图数据库--Neo4j的介绍</title>
    <link href="https://www.buildworld.cn/2021/09/22/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89-Neo4j%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.buildworld.cn/2021/09/22/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89-Neo4j%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-09-22T14:01:45.000Z</published>
    <updated>2021-10-15T02:26:01.465Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、图数据库"><a href="#一、图数据库" class="headerlink" title="一、图数据库"></a>一、图数据库</h2><h3 id="1、什么是图数据库"><a href="#1、什么是图数据库" class="headerlink" title="1、什么是图数据库"></a>1、什么是图数据库</h3><blockquote><p>随着社交、电商、金融、零售、物联网等行业的快速发展，现实社会织起了了一张庞大而复杂的关系<br>网，传统数据库很难处理关系运算。大数据行业需要处理的数据之间的关系随数据量呈几何级数增长，<br>急需一种支持海量复杂数据关系运算的数据库，图数据库应运而生。</p></blockquote><ul><li>社交领域：Facebook, Twitter，Linkedin 用它来管理社交关系，实现好友推荐</li><li>零售领域：eBay，沃尔玛使用它实现商品实时推荐，给买家更好的购物体验</li><li>金融领域：摩根大通，花旗和瑞银等银行在用图数据库做风控处理</li><li>汽车制造领域：沃尔沃，戴姆勒和丰田等顶级汽车制造商依靠图数据库推动创新制造解决方案</li><li>电信领域：Verizon, Orange 和 AT&amp;T 等电信公司依靠图数据库来管理网络，控制访问并支持客户 360</li><li>酒店领域：万豪和雅高酒店等顶级酒店公司依使用图数据库来管理复杂且快速变化的库存图数据库并非指存储图片的数据库，而是以图数据结构存储和查询数据。</li></ul><blockquote><p><strong>图数据库是基于图论实现的一种 NoSQL 数据库，其数据存储结构和数据查询方式都是以图论为基础的，</strong> &gt;<strong>图数据库主要用于存储更多的连接数据。</strong></p></blockquote><blockquote><p><strong>图论〔Graph Theory〕</strong>是数学的一个分支。它以图为研究对象图论中的图是由若干给定的点及连<br>接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，<br>用连接两点的线表示相应两个事物间具有这种关系。</p><p><img src="https://file.buildworld.cn/img/20210918094152.png"></p></blockquote><h3 id="2、和关系型数据库的对比"><a href="#2、和关系型数据库的对比" class="headerlink" title="2、和关系型数据库的对比"></a>2、和关系型数据库的对比</h3><table><thead><tr><th align="left">关系型数据库（RDBMS）</th><th align="left">图数据库（GDB）</th></tr></thead><tbody><tr><td align="left">表</td><td align="left">图</td></tr><tr><td align="left">行</td><td align="left">节点</td></tr><tr><td align="left">列和数据</td><td align="left">属性和数据</td></tr><tr><td align="left">约束</td><td align="left">关系</td></tr></tbody></table><h3 id="3、Neo4j-数据库"><a href="#3、Neo4j-数据库" class="headerlink" title="3、Neo4j 数据库"></a>3、Neo4j 数据库</h3><blockquote><p>Neo4j 是一个开源的 NoSQL 图形数据库，2003 年开始开发，使用 scala 和 java 语言，2007 年开始发布。</p><ul><li>是世界上最先进的图数据库之一，提供原生的图数据存储，检索和处理；</li><li>采用<strong>属性图模型（Property graph model）</strong>，极大的完善和丰富图数据模型；</li><li>专属查询语言 Cypher，直观，高效；</li></ul><p>官网： <a href="https://neo4j.com/">https://neo4j.com/</a></p></blockquote><h4 id="3-1、Neo4j-的特性"><a href="#3-1、Neo4j-的特性" class="headerlink" title="3.1、Neo4j 的特性"></a>3.1、Neo4j 的特性</h4><ul><li>SQL 就像简单的查询语言 Neo4j CQL</li><li>它遵循属性图数据模型</li><li>它通过使用 Apache Lucence 支持索引</li><li>它支持 UNIQUE 约束</li><li>它包含一个用于执行 CQL 命令的 UI：Neo4j 数据浏览器</li><li>它支持完整的 ACID（原子性，一致性，隔离性和持久性）规则</li><li>它采用原生图形库与本地 GPE（图形处理引擎）</li><li>它支持查询的数据导出到 JSON 和 XLS 格式</li><li>它提供了 REST API，可以被任何编程语言（如 Java，Spring，Scala 等）访问</li><li>它提供了可以通过任何 UI MVC 框架（如 Node JS）访问的 Java 脚本</li><li>它支持两种 Java API：Cypher API 和 Native Java API 来开发 Java 应用程序</li></ul><h4 id="3-2、Neo4j-的优点"><a href="#3-2、Neo4j-的优点" class="headerlink" title="3.2、Neo4j 的优点"></a>3.2、Neo4j 的优点</h4><ul><li>它很容易表示连接的数据</li><li>检索/遍历/导航更多的连接数据是非常容易和快速的</li><li>它非常容易地表示半结构化数据</li><li>Neo4j CQL 查询语言命令是人性化的可读格式，非常容易学习</li><li>使用简单而强大的数据模型</li><li>它不需要复杂的连接来检索连接的/相关的数据，因为它很容易检索它的相邻节点或关系细节没有<br>连接或索引</li></ul><h2 id="二、Neo4j-数据模型"><a href="#二、Neo4j-数据模型" class="headerlink" title="二、Neo4j 数据模型"></a>二、Neo4j 数据模型</h2><h3 id="1、属性图模型"><a href="#1、属性图模型" class="headerlink" title="1、属性图模型"></a>1、属性图模型</h3><blockquote><p>Neo4j 图数据库遵循属性图模型来存储和管理其数据。</p><p>属性图模型规则</p><ul><li>表示节点，关系和属性中的数据</li><li>节点和关系都包含属性</li><li>关系连接节点</li><li>属性是键值对</li><li>节点用圆圈表示，关系用方向键表示。</li><li>关系具有方向：单向和双向。</li><li>每个关系包含“开始节点”或“从节点”和“到节点”或“结束节点”</li></ul></blockquote><blockquote><p><strong>Neo4j 图数据库将其所有数据存储在节点和关系中</strong>，我们不需要任何额外的 RDBMS 数据库或 NoSQL 数据<br>库来存储 Neo4j 数据库数据，它以图的形式存储数据。Neo4j 使用本机<strong>GPE（图形处理引擎）</strong>来使用它的<br>本机图存储格式。</p></blockquote><h3 id="2、Neo4j-的构建元素"><a href="#2、Neo4j-的构建元素" class="headerlink" title="2、Neo4j 的构建元素"></a>2、Neo4j 的构建元素</h3><blockquote><ul><li><p>节点</p></li><li><p>属性</p></li><li><p>关系</p></li><li><p>标签</p></li><li><p>数据浏览器</p><p><img src="https://file.buildworld.cn/img/20210922211025.png"></p></li></ul></blockquote><h4 id="2-1、节点"><a href="#2-1、节点" class="headerlink" title="2.1、节点"></a>2.1、节点</h4><blockquote><p>节点（Node)是图数据库中的一个基本元素，用来表示一个实体记录，就像关系数据库中的一条记录一<br>样。在 Neo4j 中节点可以包含多个属性(Property)和多个标签(Label)。</p><ul><li>节点是主要的数据元素</li><li>节点通过关系连接到其他节点</li><li>节点可以具有一个或多个属性（即，存储为键/值对的属性）</li><li>节点有一个或多个标签，用于描述其在图表中的作用</li></ul></blockquote><h4 id="2-2、属性"><a href="#2-2、属性" class="headerlink" title="2.2、属性"></a>2.2、属性</h4><blockquote><p>属性（Property）是用于描述图节点和关系的键值对。其中 Key 是一个字符串，值可以通过使用任何<br>Neo4j 数据类型来表示。</p><ul><li>属性是命名值，其中名称（或键）是字符串</li><li>属性可以被索引和约束</li><li>可以从多个属性创建复合索引</li></ul></blockquote><h4 id="2-3、关系"><a href="#2-3、关系" class="headerlink" title="2.3、关系"></a>2.3、关系</h4><blockquote><p>关系（Relationship）同样是图数据库的基本元素。当数据库中已经存在节点后，需要将节点连接起来<br>构成图。关系就是用来连接两个节点，关系也称为图论的边(Edge) ,其始端和末端都必须是节点，关系不<br>能指向空也不能从空发起。关系和节点一样可以包含多个属性，但关系只能有一个类型(Type) 。</p><ul><li>关系连接两个节点</li><li>关系是方向性的</li><li>节点可以有多个甚至递归的关系</li><li>关系可以有一个或多个属性（即存储为键/值对的属性）</li></ul></blockquote><h4 id="2-4、标签"><a href="#2-4、标签" class="headerlink" title="2.4、标签"></a>2.4、标签</h4><blockquote><p>标签（Label）将一个公共名称与一组节点或关系相关联， 节点或关系可以包含一个或多个标签。 我们<br>可以为现有节点或关系创建新标签， 我们可以从现有节点或关系中删除标签。</p><ul><li>标签用于将节点分组</li><li>一个节点可以具有多个标签</li><li>对标签进行索引以加速在图中查找节点</li><li>本机标签索引针对速度进行了优化</li></ul></blockquote><h3 id="3、Neo4j-CQL-简介"><a href="#3、Neo4j-CQL-简介" class="headerlink" title="3、Neo4j - CQL 简介"></a>3、Neo4j - CQL 简介</h3><blockquote><p>Neo4j 的 Cypher 语言是为处理图形数据而构建的，CQL 代表 Cypher 查询语言。像 Oracle 数据库具有查询<br>语言 SQL，Neo4j 具有 CQL 作为查询语言。</p><ul><li>它是 Neo4j 图形数据库的查询语言。</li><li>它是一种声明性模式匹配语言</li><li>它遵循 SQL 语法。</li><li>它的语法是非常简单且人性化、可读的格式。</li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20210923094527.png"></p>]]></content>
    
    
    <summary type="html">Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。</summary>
    
    
    
    <category term="人工智能" scheme="https://www.buildworld.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://www.buildworld.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图" scheme="https://www.buildworld.cn/tags/%E5%9B%BE/"/>
    
    <category term="Neo4j" scheme="https://www.buildworld.cn/tags/Neo4j/"/>
    
  </entry>
  
  <entry>
    <title>图与图学习</title>
    <link href="https://www.buildworld.cn/2021/09/10/%E5%9B%BE%E4%B8%8E%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.buildworld.cn/2021/09/10/%E5%9B%BE%E4%B8%8E%E5%9B%BE%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-10T06:35:46.000Z</published>
    <updated>2021-10-15T02:26:04.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="图与图学习"><a href="#图与图学习" class="headerlink" title="图与图学习"></a>图与图学习</h2><h3 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h3><h4 id="1-1、图的定义"><a href="#1-1、图的定义" class="headerlink" title="1.1、图的定义"></a>1.1、图的定义</h4><blockquote><p>图表示物 件与物件之间的关系的数学对象，是图论的基本研究对象。</p><p><strong>节点（node）</strong>用红色标出，通过黑色的<strong>边（edge）</strong>连接。</p><p><img src="https://file.buildworld.cn/img/20210907184428.png"></p><p>在图上执行怎样的分析：</p><ul><li>研究拓扑结构和连接性</li><li>群体检测</li><li>识别中心节点</li><li>预测缺失的节点</li><li>预测缺失的边</li></ul></blockquote><p><strong>空手道俱乐部图</strong></p><blockquote><p>这个「空手道」图表示什么？Wayne W. Zachary 在 1970 到 1972 年这三年中研究的一个空手道俱乐部的社交网络。该网络包含了这个空手道俱乐部的 34 个成员，成员对之间的连接表示他们在俱乐部之外也有联系。在研究期间，管理员 JohnA 与教练 Mr.Hi（化名）之间出现了冲突，导致俱乐部一分为二。一半成员围绕 Mr.Hi 形成了一个新的俱乐部，另一半则找了一个新教练或放弃了空手道。基于收集到的数据，除了其中一个成员，Zachary 正确分配了所有成员在分裂之后所进入的分组。</p></blockquote><h4 id="1-2、图的基本表示方法"><a href="#1-2、图的基本表示方法" class="headerlink" title="1.2、图的基本表示方法"></a>1.2、图的基本表示方法</h4><blockquote><ul><li><p>图 <strong>G=(V, E)</strong> 由下列要素构成：</p></li><li><p>一组<strong>节点</strong>（也称为 verticle）V=1,…,n</p></li><li><p>一组<strong>边</strong> E⊆V×V</p></li><li><p>边 <strong>(i,j) ∈ E</strong> 连接了节点 i 和 j</p></li><li><p><strong>i</strong> 和 <strong>j</strong> 被称为<strong>相邻节点</strong>（neighbor）</p></li><li><p>节点的<strong>度</strong>（degree）是指相邻节点的数量</p><p><img src="https://file.buildworld.cn/img/20210907190406.png"></p><ul><li>如果一个图的所有节点都有 n-1 个相邻节点，则该图是<strong>完备的</strong>（complete）。也就是说所有节点都具备所有可能的连接方式。</li><li>从 i 到 j 的路径（path）是指从 i 到达 j 的边的序列。该<strong>路径的长度</strong>（length）等于所经过的边的数量。</li><li><strong>图的直径</strong>（diameter）是指连接任意两个节点的所有最短路径中最长路径的长度。</li><li><strong>测地路径</strong>（geodesic path）是指两个节点之间的最短路径。</li><li>如果所有节点都可通过某个路径连接到彼此，则它们构成一个<strong>连通分支</strong>（connected component）。如果一个图仅有一个连通分支，则该图是<strong>连通</strong>的（connected）</li></ul></li></ul></blockquote><h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><ul><li>如果一个图的边是有顺序的配对，则该图是<strong>有向的</strong>（directed）。i 的<strong>入度</strong>（in-degree）是指向 i 的边的数量，<strong>出度</strong>（out-degree）是远离 i 的边的数量。</li></ul><p><img src="https://file.buildworld.cn/img/20210908140527.png"></p><blockquote><ul><li>如果可以回到一个给定节点，则该图是<strong>有环的</strong>（cyclic）。相对地，如果至少有一个节点无法回到，则该图就是<strong>无环的</strong>（acyclic）。</li><li>图可以被<strong>加权</strong>（weighted），即在节点或关系上施加权重。</li><li>如果一个图的边数量相比于节点数量较小，则该图是<strong>稀疏</strong>的（sparse）。相对地，如果节点之间的边非常多，则该图是<strong>密集</strong>的（dense）</li></ul></blockquote><h5 id="图的种类"><a href="#图的种类" class="headerlink" title="图的种类"></a>图的种类</h5><blockquote><p>分别是<strong>有向图</strong>、<strong>无向图</strong>、<strong>有环图</strong>、<strong>无环图</strong>、<strong>加权图</strong>、<strong>无加权图</strong>、<strong>稀疏图</strong>、<strong>密集图</strong></p></blockquote><p><img src="https://file.buildworld.cn/img/20210908140800.png"></p><h4 id="1-3、同构图与异构图"><a href="#1-3、同构图与异构图" class="headerlink" title="1.3、同构图与异构图"></a>1.3、同构图与异构图</h4><blockquote><p>两个图 G 和 H 是<strong>同构图（isomorphic graphs）</strong>，能够通过重新标记图 G 的顶点而产生图 H。</p><p>如果 G 和 H 同构，那么它们的阶是相同的，它们大小是相同的，它们个顶点的度数也对应相同。</p><p>异构图是一个与同构图相对应的新概念。</p><p>传统同构图（Homogeneous Graph）数据中只存在一种节点和边，因此在构建图神经网络时所有节点共享同样的模型参数并且拥有同样维度的特征空间。</p><p>而<strong>异构图（Heterogeneous Graph）</strong>中可以存在不只一种节点和边，因此允许不同类型的节点拥有不同维度的特征或属性。</p></blockquote><p><strong>异构图和同构图的区别</strong></p><blockquote><p>同构图中，node 的种类只有一种，一个 node 和另一个 node 的连接关系只有一种</p><ol><li>例如在社交网络中，可以想象 node 只有‘人’这一个种类，edge 只有‘认识’这一种连接。而人和人要么认识，要么不认识。</li><li>但是也可能细分有人，点赞，推文。则人和人可能通过认识连接，人和推文可能通过点赞连接，人和人也可能通过点赞同一篇推文连接(meta path）。这里节点、节点之间关系的多样性表达就需要引入异构图了。</li></ol><p>异构图中，有很多种 node。node 之间也有很多种连接关系(edge)，这些连接关系的组合则种类更多(meta-path), 而这些 node 之间的关系有轻重之分，不同连接关系也有轻重之分。比如在 IMDB 中，可以有三类 node 分别是 Movie，Director 和 Actor</p></blockquote><h4 id="1-4、主要的图算法"><a href="#1-4、主要的图算法" class="headerlink" title="1.4、主要的图算法"></a>1.4、主要的图算法</h4><blockquote><p>目前大多数框架（比如 Python 的 networkx 或 Neo4J）支持的图算法类别主要有三个：</p><ul><li><strong>Pathfinding（寻路）</strong>：根据可用性和质量等条件确定最优路径。我们也将搜索算法包含在这一类别中。这可用于确定最快路由或流量路由。</li><li><strong>Centrality（中心性）</strong>：确定网络中节点的重要性。这可用于识别社交网络中有影响力的人或识别网络中潜在的攻击目标。</li><li><strong>Community detection（社群检测）</strong>：评估群体聚类的方式。这可用于划分客户或检测欺诈等。</li></ul></blockquote><h5 id="寻路和图搜索算法"><a href="#寻路和图搜索算法" class="headerlink" title="寻路和图搜索算法"></a>寻路和图搜索算法</h5><ul><li>寻路算法是通过最小化跳（hop）的数量来寻找两个节点之间的最短路径。</li><li>搜索算法不是给出最短路径，而是根据图的相邻情况或深度来探索图。这可用于信息检索</li></ul><blockquote><p><strong>1). 搜索算法</strong></p><p>图搜索算法主要有两种：</p><ul><li><p><strong>宽度优先搜索（BFS）</strong>：首先探索每个节点的相邻节点，然后探索相邻节点的相邻节点；</p></li><li><p><strong>深度优先搜索（DFS）</strong>：会尝试尽可能地深入一条路径，如有可能便访问新的相邻节点。</p><p><strong>2). 寻路算法</strong></p><p><strong>a. 最短路径</strong></p></li></ul><blockquote><p>最短路径计算的是一对节点之间的最短的加权（如果图有加权的话）路径。</p></blockquote><p>这可用于确定最优的驾驶方向或社交网络上两个人之间的分离程度。</p><p><strong>b. 单源最短路径</strong></p><blockquote><p>单源最短路径（Single Source Shortest Path/SSSP）是找到给定节点与图中其它所有节点之间的最短路径。</p></blockquote><p><strong>c. 所有配对最短路径</strong></p><blockquote><p>所有配对最短路径（All Pairs Shortest Path / APSP）算法是找到所有节点对之间的<strong>最短路径</strong>。</p></blockquote><p><strong>d. 最小权重生成树</strong></p><blockquote><p>最小权重生成树（minimum spanning tree）是图（一个树）的一个子图，其用权重和最小的边连接了图中的所有节点。</p></blockquote></blockquote><h5 id="社群检测"><a href="#社群检测" class="headerlink" title="社群检测"></a>社群检测</h5><blockquote><p>社群检测是根据给定的质量指标将节点划分为多个分组。</p><p>这通常可用于识别<strong>社交社群</strong>、<strong>客户行为</strong>或<strong>网页主题</strong>。 社区是指一组相连节点的集合。但是，目前关于社群还没有广泛公认的定义，只是社群内的节点应该要密集地相连。</p><p><img src="https://file.buildworld.cn/img/20210909090814.png"></p></blockquote><blockquote><p><strong>Girvan Newman 算法</strong>是一个用于发现社群的常用算法。其通过逐步移除网络内的边来定义社区。我们将居间性称为「<strong>边居间性（edge betweenness）</strong>」。这是一个正比于穿过该边的节点对之间最短路径的数量的值。</p><p>该算法的步骤如下：</p><ol><li>计算网络中所有已有边的居间性。</li><li>移除居间性最高的边。</li><li>移除该边后，重新计算所有边的居间性。</li><li>重复步骤 2 和 3，直到不再剩余边。</li></ol></blockquote><h5 id="分层聚类"><a href="#分层聚类" class="headerlink" title="分层聚类"></a>分层聚类</h5><blockquote><p>在 <strong>分层聚类（hierarchical clustering）</strong> 中，我们构建聚类的层次结构。我们用树状图的形式表示聚类。</p><p><img src="https://file.buildworld.cn/img/20210909092544.jpg"></p><p>其思想是以不同的规模分析社群结构。我们通常自下而上构建树状图。我们从每个节点一个聚类开始，然后合并两个「最近」的节点。</p></blockquote><p><strong>相似度距离</strong></p><blockquote><p>衡量聚类是否相近。令 <strong>d(i,j)</strong> 为 <strong>i</strong> 和 <strong>j</strong> 之间的最短路径的长度。</p><p><img src="https://file.buildworld.cn/img/20210909103348.png"></p><p>要得到最大连接，在每个步骤，被最短距离分开的两个聚类被组合到一起。相似度距离可用以下示意图阐释：</p><p><img src="https://file.buildworld.cn/img/20210909103752.jpg" alt=" "></p></blockquote><h3 id="二、图学习"><a href="#二、图学习" class="headerlink" title="二、图学习"></a>二、图学习</h3><blockquote><p>图学习中包含三种主要的任务：</p><ul><li><strong>链接预测（Link prediction）</strong></li><li><strong>节点标记预测（Node labeling）</strong></li><li><strong>图嵌入（Graph Embedding）</strong></li></ul></blockquote><h4 id="2-1、链接预测（Link-prediction）"><a href="#2-1、链接预测（Link-prediction）" class="headerlink" title="2.1、链接预测（Link prediction）"></a>2.1、链接预测（Link prediction）</h4><blockquote><p>在链接预测中，给定图 G，我们的目标是预测新边。例如，当图未被完全观察时，或者当新客户加入平台（例如，新的 LinkedIn 用户）时，预测未来关系或缺失边是很有用的。</p><p><strong>在不同的 task 中，Link Prediction 被用于：</strong></p><ol><li><p>在社交网络中，进行用户/商品推荐</p></li><li><p>在生物学领域，进行相互作用发现</p></li><li><p>在知识图谱中，进行实体关系学习</p></li><li><p>在基础研究中，进行图结构捕捉</p></li></ol><p><strong>在不同的 work 中，Link Prediction 还会被称为（可以使用这些关键词检索哦）：</strong></p><ol><li><p>Edge Embedding/Classification</p></li><li><p>Relational Inference/Reasoning</p></li><li><p>Graph Generation（一种是从节点生成边，另一种是从噪声生成图，前者是 Link Prediction）</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">图的介绍</summary>
    
    
    
    <category term="人工智能" scheme="https://www.buildworld.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://www.buildworld.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图" scheme="https://www.buildworld.cn/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>手写netty的springboot-starter组件</title>
    <link href="https://www.buildworld.cn/2021/09/07/%E6%89%8B%E5%86%99netty%E7%9A%84springboot-starter%E7%BB%84%E4%BB%B6/"/>
    <id>https://www.buildworld.cn/2021/09/07/%E6%89%8B%E5%86%99netty%E7%9A%84springboot-starter%E7%BB%84%E4%BB%B6/</id>
    <published>2021-09-07T00:57:28.000Z</published>
    <updated>2021-10-15T02:26:10.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文的工作分为两个部分，一个是研究 Netty 框架的使用，实现服务端和客户之间的通信，另一个是将服务端和客户端的 Netty 打包成 springboot-starter 组件（两个组件：rpc-server-start,rpc-client-start），方便直接引入 starter 去实现 Netty 的相关功能。</p><p>项目地址：<a href="https://gitee.com/mi_chong/NettyDemo">https://gitee.com/mi_chong/NettyDemo</a></p></blockquote><h2 id="一、Netty"><a href="#一、Netty" class="headerlink" title="一、Netty"></a>一、Netty</h2><p><strong>1、NIO 是一种非阻塞 IO</strong></p><ul><li>单线程可以连接多个客户端。</li><li>选择器可以实现但线程管理多个 Channel，新建的通道都要向选择器注册。</li><li>一个 SelectionKey 键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</li><li>selector 进行 select()操作可能会产生阻塞，但是可以设置阻塞时间，并且可以用 wakeup()唤醒 selector，所以 NIO 是非阻塞 IO。</li></ul><h3 id="2、Netty-模型-selector-模式"><a href="#2、Netty-模型-selector-模式" class="headerlink" title="2、Netty 模型 selector 模式"></a>2、Netty 模型 selector 模式</h3><ul><li>NIO 采用多线程的方式可以同时使用多个 selector</li><li>通过绑定多个端口的方式，使得一个 selector 可以同时注册多个 ServerSocketServer</li><li>单个线程下只能有一个 selector，用来实现 Channel 的匹配及复用</li></ul><p><img src="https://file.buildworld.cn/img/20210827203719.png"></p><p><strong>半包问题</strong></p><blockquote><p>TCP/IP 在发送消息的时候，可能会拆包，这就导致接收端无法知道什么时候收到的数据是一个完整的数据。在传统的 BIO 中在读取不到数据时会发生阻塞，但是 NIO 不会。</p><p>为了解决 NIO 的半包问题，Netty 在 Selector 模型的基础上，提出了<strong>reactor 模式</strong>，从而解决客户端请求在服务端不完整的问题。</p></blockquote><h3 id="3、netty-模型-reactor-模式"><a href="#3、netty-模型-reactor-模式" class="headerlink" title="3、netty 模型 reactor 模式"></a>3、netty 模型 reactor 模式</h3><blockquote><p>在 selector 的基础上解决了半包问题。<br><img src="https://file.buildworld.cn/img/20210827205913.png"></p></blockquote><p>Netty 服务端代码：<a href="https://gitee.com/mi_chong/NettyDemo/tree/master/rpc-server-start">https://gitee.com/mi_chong/NettyDemo/tree/master/rpc-server-start</a></p><p>Netty 客户端代码：<a href="https://gitee.com/mi_chong/NettyDemo/tree/master/rpc-client-start">https://gitee.com/mi_chong/NettyDemo/tree/master/rpc-client-start</a></p><h2 id="二、自定义-springboot-starter-组件"><a href="#二、自定义-springboot-starter-组件" class="headerlink" title="二、自定义 springboot-starter 组件"></a>二、自定义 springboot-starter 组件</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><blockquote><p>SpringBoot 中的 starter 是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进 starter，应用者只需要在 maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启 动相应的默认配置。starter 让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。</p></blockquote><blockquote><p>SpringBoot 会自动通过 classpath 路径下的类发现需要的 Bean，并注册进 IOC 容器。SpringBoot 提供 了针对日常企业应用研发各种场景的<strong>spring-boot-starter</strong>依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“<strong>约定大于配置</strong>”的理念。</p></blockquote><blockquote><p>以 rpc-server-start 来看，如下图：<br><img src="https://file.buildworld.cn/img/20210906210553.png"></p><p>1、属性配置类</p><p>2、业务逻辑执行类</p><p>3、自动配置类</p><p>4、spring.factories 文件（里面指定了自动配置类 3 的位置）</p></blockquote><h3 id="2、NettyProperties-java——属性配置类"><a href="#2、NettyProperties-java——属性配置类" class="headerlink" title="2、NettyProperties.java——属性配置类"></a>2、NettyProperties.java——属性配置类</h3><blockquote><p>在使用 Spring 官方的 Starter 时通常可以在 application.properties 中来配置参数覆盖掉默认的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;netty.server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyProperties</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    <span class="keyword">private</span> String hostname = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="comment">// 端口</span></span><br><span class="line">    <span class="keyword">private</span> Integer host = <span class="number">8082</span>;</span><br><span class="line">    <span class="comment">// 主线程数目</span></span><br><span class="line">    <span class="keyword">private</span> Integer bossGroupCounts = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 工作线程数目</span></span><br><span class="line">    <span class="keyword">private</span> Integer workGroupCounts = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    get...</span><br><span class="line">    set...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、NettyServer-java——业务操作类"><a href="#3、NettyServer-java——业务操作类" class="headerlink" title="3、NettyServer.java——业务操作类"></a>3、NettyServer.java——业务操作类</h3><blockquote><p>在这里使用上面的属性配置类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务启动监听器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-08-27 21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NettyProperties nettyProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(NettyProperties nettyProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nettyProperties = nettyProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(nettyProperties.getHostname(), nettyProperties.getHost());</span><br><span class="line">        <span class="comment">//new 一个主线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(nettyProperties.getBossGroupCounts());</span><br><span class="line">        <span class="comment">//new 一个工作线程组</span></span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup(nettyProperties.getWorkGroupCounts());</span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(bossGroup, workGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ServerChannelInitializer())</span><br><span class="line">                .localAddress(socketAddress)</span><br><span class="line">                <span class="comment">//设置队列大小</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                <span class="comment">// 两小时内没有数据的通信时,TCP会自动发送一个活动探测数据报文</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//绑定端口,开始接收进来的连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.bind(socketAddress).sync();</span><br><span class="line">            log.info(<span class="string">&quot;服务器启动开始监听端口: &#123;&#125;&quot;</span>, socketAddress.getPort());</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;服务器开启失败&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭主线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            <span class="comment">//关闭工作线程组</span></span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、NettyServerAutoConfiguration-java–自动配置-NettyServer-类"><a href="#4、NettyServerAutoConfiguration-java–自动配置-NettyServer-类" class="headerlink" title="4、NettyServerAutoConfiguration.java–自动配置 NettyServer 类"></a>4、NettyServerAutoConfiguration.java–自动配置 NettyServer 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-09-06 14:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(NettyProperties.class)</span></span><br><span class="line"><span class="comment">//当类路径下有指定的类为true</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(NettyServer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;netty.server&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NettyProperties nettyProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(NettyServer.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NettyServer <span class="title">nettyServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NettyServer nettyServer = <span class="keyword">new</span> NettyServer(nettyProperties);</span><br><span class="line">        <span class="keyword">return</span> nettyServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、spring-factories-文件"><a href="#5、spring-factories-文件" class="headerlink" title="5、spring.factories 文件"></a>5、spring.factories 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/META-INF/spring.factories文件放在/src/main/resources目录下</span><br><span class="line">注意：META-INF是自己手动创建的目录，spring.factories也是自己手动创建的文件，在该文件中配置自己的自动配置类。</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.buildworld.netty.server.start.config.NettyServerAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="6、项目打包"><a href="#6、项目打包" class="headerlink" title="6、项目打包"></a>6、项目打包</h3><p><strong>最后，将项目打包 mvn clean install</strong><br><strong>下面链接是引入组件的 springboot 项目</strong></p><p><a href="https://gitee.com/mi_chong/NettyDemo/tree/master/WebStart">https://gitee.com/mi_chong/NettyDemo/tree/master/WebStart</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在我们的springboot项目中引入打包好的starter组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.buildworld<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-server-start<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在 springboot 中配置 applicaiton.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">netty:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure><h3 id="7、如何使用-netty-server"><a href="#7、如何使用-netty-server" class="headerlink" title="7、如何使用 netty server"></a>7、如何使用 netty server</h3><blockquote><p>在我们的 springboot 项目中引入 netty-starter 组件，需要在我们项目启动的时候，启动 netty 服务器，需要做一些处理。</p><p>需求就是，启动 springboot 项目–&gt; 执行 netty 组件中的启动服务器方法，目前网上有 5 种方式在 springboot 启动时执行方法。在<a href="https://gitee.com/mi_chong/NettyDemo/tree/master/WebStart/src/main/java/cn/buildworld/netty/webstart/start%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82">https://gitee.com/mi_chong/NettyDemo/tree/master/WebStart/src/main/java/cn/buildworld/netty/webstart/start目录下。</a></p></blockquote><p><strong>推荐使用@PostConstruct 注解方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将要执行的方法所在的类交个spring容器扫描(<span class="doctag">@Component</span>),并且在要执行的方法上添加<span class="doctag">@PostConstruct</span>注解或者静态代码块执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-09-06 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerStart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NettyServer nettyServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 使用@PostConstruct注解 &quot;</span>);</span><br><span class="line">        <span class="comment">// 开启一个线程去启动Netty服务，防止阻塞springboot启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            nettyServer.start();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、如何使用-netty-client"><a href="#8、如何使用-netty-client" class="headerlink" title="8、如何使用 netty client"></a>8、如何使用 netty client</h3><h4 id="8-1-引入依赖"><a href="#8-1-引入依赖" class="headerlink" title="8.1 引入依赖"></a>8.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.buildworld<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-client-start<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-2-自动导入-Bean"><a href="#8-2-自动导入-Bean" class="headerlink" title="8.2 自动导入 Bean"></a>8.2 自动导入 Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-09-06 10:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NettyClientUtil nettyClientUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/helloNetty&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseResult <span class="title">helloNetty</span><span class="params">(<span class="meta">@RequestParam</span> String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nettyClientUtil.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、测试"><a href="#9、测试" class="headerlink" title="9、测试"></a>9、测试</h3><h4 id="9-1、请求接口，发送数据"><a href="#9-1、请求接口，发送数据" class="headerlink" title="9.1、请求接口，发送数据"></a>9.1、请求接口，发送数据</h4><p><img src="https://file.buildworld.cn/img/20210907093445.png"></p><h4 id="9-2、客户端发送消息"><a href="#9-2、客户端发送消息" class="headerlink" title="9.2、客户端发送消息"></a>9.2、客户端发送消息</h4><p><img src="https://file.buildworld.cn/img/20210907093612.png"></p><h4 id="9-3、服务端接收消息并返回消息给客户端"><a href="#9-3、服务端接收消息并返回消息给客户端" class="headerlink" title="9.3、服务端接收消息并返回消息给客户端"></a>9.3、服务端接收消息并返回消息给客户端</h4><p><img src="https://file.buildworld.cn/img/20210907093657.png"></p>]]></content>
    
    
    <summary type="html">从九个细节考虑秒杀系统的设计。</summary>
    
    
    
    <category term="后端" scheme="https://www.buildworld.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SpringBoot" scheme="https://www.buildworld.cn/tags/SpringBoot/"/>
    
    <category term="Netty" scheme="https://www.buildworld.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>秒杀那些事</title>
    <link href="https://www.buildworld.cn/2021/09/06/%E7%A7%92%E6%9D%80%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://www.buildworld.cn/2021/09/06/%E7%A7%92%E6%9D%80%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-09-06T01:29:25.000Z</published>
    <updated>2021-10-15T02:26:15.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1、九个细节"><a href="#1、九个细节" class="headerlink" title="1、九个细节"></a>1、九个细节</h4><p><img src="https://file.buildworld.cn/img/20210815163818.png"></p><h4 id="2、页面静态化"><a href="#2、页面静态化" class="headerlink" title="2、页面静态化"></a>2、页面静态化</h4><blockquote><p>活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。</p></blockquote><blockquote><p>针对不同地区访问使用 CDN，它的全称是 Content Delivery Network，即内容分发网络。<br><img src="https://file.buildworld.cn/img/20210815170351.png"></p></blockquote><h4 id="3、秒杀按钮"><a href="#3、秒杀按钮" class="headerlink" title="3、秒杀按钮"></a>3、秒杀按钮</h4><p>==CDN 上的 js 文件是如何更新的？==</p><blockquote><p>秒杀开始之前，js 标志为 false，还有另外一个随机参数。<br><img src="https://file.buildworld.cn/img/20210815171140.png"></p></blockquote><blockquote><p>当秒杀开始的时候系统会生成一个新的 js 文件，此时标志为 true，并且随机参数生成一个新值，然后同步给 CDN。由于有了这个随机参数，CDN 不会缓存数据，每次都能从 CDN 中获取最新的 js 代码。<br><img src="https://file.buildworld.cn/img/20210815171159.png"></p></blockquote><h4 id="4、读多写少"><a href="#4、读多写少" class="headerlink" title="4、读多写少"></a>4、读多写少</h4><blockquote><p>使用 Redis 抵抗大量的请求。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210815200829.png"></p><h4 id="5、缓存问题"><a href="#5、缓存问题" class="headerlink" title="5、缓存问题"></a>5、缓存问题</h4><p>==秒杀之前查询商品是否存在==</p><p><img src="https://file.buildworld.cn/img/20210815201534.png"></p><blockquote><p>根据商品 id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。</p></blockquote><h5 id="5-1-缓存击穿"><a href="#5-1-缓存击穿" class="headerlink" title="5.1 缓存击穿"></a>5.1 缓存击穿</h5><blockquote><p>比如商品 A 第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。</p></blockquote><blockquote><p>然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。</p></blockquote><p>==使用分布式锁解决上面的问题==</p><p><img src="https://file.buildworld.cn/img/20210815204416.png"></p><p><strong>项目启动之前进行==缓存预热==。</strong></p><blockquote><p>表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加速同样可能出现缓存击穿。</p></blockquote><h5 id="5-2-缓存穿透"><a href="#5-2-缓存穿透" class="headerlink" title="5.2 缓存穿透"></a>5.2 缓存穿透</h5><blockquote><p>如果有大量的请求传入的商品 id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210815210140.png"></p><blockquote><p>系统根据商品 id，先从布隆过滤器中查询该 id 是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。</p></blockquote><blockquote><p>虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：布隆过滤器中的数据如何更缓存中的数据保持一致？</p></blockquote><blockquote><p>这就要求，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？</p></blockquote><p>==布隆过滤器绝大部分使用在缓存数据更新很少的场景中。==</p><p>==如果缓存数据更新非常频繁，把不存在的商品 id 也缓存起来。==<br><img src="https://file.buildworld.cn/img/20210815211010.png"></p><blockquote><p>下次，再有该商品 id 的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。</p></blockquote><h4 id="6、库存问题"><a href="#6、库存问题" class="headerlink" title="6、库存问题"></a>6、库存问题</h4><h5 id="6-1、数据库扣减库存"><a href="#6-1、数据库扣减库存" class="headerlink" title="6.1、数据库扣减库存"></a>6.1、数据库扣减库存</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 基于数据库的乐观锁，这样会少一次数据库查询，而且能够天然的保证数据操作的原子性。</span><br><span class="line">update product set stock=stock-1 where id=product and stock &gt; 0;</span><br></pre></td></tr></table></figure><blockquote><p>但需要频繁访问数据库，我们都知道数据库连接是非常昂贵的资源。在高并发的场景下，可能会造成系统雪崩。而且，容易出现多个请求，同时竞争行锁的情况，造成相互等待，从而出现==死锁==的问题。</p></blockquote><h5 id="6-2、redis-扣减库存"><a href="#6-2、redis-扣减库存" class="headerlink" title="6.2、redis 扣减库存"></a>6.2、redis 扣减库存</h5><p>==lua 脚本扣减库存==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder lua = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  lua.append(<span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 1) then&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]));&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    if (stock == -1) then&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;        return 1;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    end;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    if (stock &gt; 0) then&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;        redis.call(&#x27;incrby&#x27;, KEYS[1], -1);&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;        return stock;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    end;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;    return 0;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;end;&quot;</span>);</span><br><span class="line">  lua.append(<span class="string">&quot;return -1;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    先判断商品id是否存在，如果不存在则直接返回。</span><br><span class="line">    获取该商品id的库存，判断库存如果是-<span class="number">1</span>，则直接返回，表示不限制库存。</span><br><span class="line">    如果库存大于<span class="number">0</span>，则扣减库存。</span><br><span class="line">    如果库存等于<span class="number">0</span>，是直接返回，表示库存不足。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7、分布式锁"><a href="#7、分布式锁" class="headerlink" title="7、分布式锁"></a>7、分布式锁</h4><blockquote><p>如果在高并发下，有大量的请求都去查一个缓存中不存在的商品，这些请求都会直接打到数据库。数据库由于承受不住压力，而直接挂掉。</p></blockquote><h5 id="7-1、setNx-加锁"><a href="#7-1、setNx-加锁" class="headerlink" title="7.1、setNx 加锁"></a>7.1、setNx 加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jedis.setnx(lockKey, val) == <span class="number">1</span>) &#123;</span><br><span class="line">   jedis.expire(lockKey, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用该命令其实可以加锁，但和后面的设置超时时间是分开的，并非原子操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如加锁成功了，但是设置超时时间失败了，该lockKey就变成永不失效的了。在高并发场景中，该问题会导致非常严重的后果。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="7-2、set-加锁"><a href="#7-2、set-加锁" class="headerlink" title="7.2、set 加锁"></a>7.2、set 加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String result = jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">lockKey：锁的标识</span><br><span class="line">requestId：请求id</span><br><span class="line">NX：只在键不存在时，才对键进行设置操作。</span><br><span class="line">PX：设置键的过期时间为 millisecond 毫秒。</span><br><span class="line">expireTime：过期时间</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="7-3、释放锁"><a href="#7-3、释放锁" class="headerlink" title="7.3、释放锁"></a>7.3、释放锁</h5><blockquote><p>requestId 是在释放锁的时候用的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (jedis.get(lockKey).equals(requestId)) &#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lua脚本</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line"> return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">  return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="7-4、自旋锁"><a href="#7-4、自旋锁" class="headerlink" title="7.4、自旋锁"></a>7.4、自旋锁</h5><p>在秒杀场景下，会有什么问题？</p><p>答：每 1 万个请求，有 1 个成功。再 1 万个请求，有 1 个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟我们想象中的不一样。</p><p>如何解决这个问题呢？</p><p>答：使用自旋锁。在规定的时间，比如 500 毫秒内，自旋不断尝试加锁，如果成功则直接返回。如果失败，则休眠 50 毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。</p><h5 id="7-5、redisson"><a href="#7-5、redisson" class="headerlink" title="7.5、redisson"></a>7.5、redisson</h5><h4 id="8、-mq-异步处理"><a href="#8、-mq-异步处理" class="headerlink" title="8、 mq 异步处理"></a>8、 mq 异步处理</h4><p><img src="https://file.buildworld.cn/img/20210815221516.png"></p><h5 id="8-1-消息丢失问题"><a href="#8-1-消息丢失问题" class="headerlink" title="8.1 消息丢失问题"></a>8.1 消息丢失问题</h5><blockquote><p>秒杀成功了，往 mq 发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker 挂了、mq 服务端磁盘问题等。这些情况，都可能会造成消息丢失</p></blockquote><p>==加一张消息发送表==</p><p><img src="https://file.buildworld.cn/img/20210815221745.png"></p><blockquote><p>在生产者发送 mq 消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送 mq 消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。</p></blockquote><p><strong>发送 mq 消息到 mq 服务端的过程中失败了</strong></p><p>==使用 job，增加重试机制==。</p><blockquote><p>用 job 每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送 mq 消息。<br><img src="https://file.buildworld.cn/img/20210815221953.png"></p></blockquote><h5 id="8-2、重复消费问题"><a href="#8-2、重复消费问题" class="headerlink" title="8.2、重复消费问题"></a>8.2、重复消费问题</h5><blockquote><p>本来消费者消费消息时，在 ack 应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。</p></blockquote><p>那么，如何解决重复消息问题呢？</p><p>==答：加一张消息处理表。==</p><blockquote><p>消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。<br><img src="https://file.buildworld.cn/img/20210815222133.png"></p></blockquote><p><strong>有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。</strong></p><h5 id="8-3、垃圾消息问题"><a href="#8-3、垃圾消息问题" class="headerlink" title="8.3、垃圾消息问题"></a>8.3、垃圾消息问题</h5><blockquote><p>这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样 job 会不停的重试发消息。最后，会产生大量的垃圾消息。</p></blockquote><blockquote><p>每次在 job 重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加 1，然后发送消息。<br><img src="https://file.buildworld.cn/img/20210815223449.png"></p></blockquote><h5 id="8-4、延迟消费问题"><a href="#8-4、延迟消费问题" class="headerlink" title="8.4、延迟消费问题"></a>8.4、延迟消费问题</h5><blockquote><p>下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。<br><img src="https://file.buildworld.cn/img/20210815224026.png"></p></blockquote><h4 id="9、如何限流？"><a href="#9、如何限流？" class="headerlink" title="9、如何限流？"></a>9、如何限流？</h4><p><strong>三种常见的限流算法</strong></p><h5 id="9-1、计数器算法"><a href="#9-1、计数器算法" class="headerlink" title="9.1、计数器算法"></a>9.1、计数器算法</h5><blockquote><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于 A 接口来说，我们 1 分钟的访问次数不能超过 100 个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器 counter，每当一个请求过来的时候，counter 就加 1，如果 counter 的值大于 100 并且该请求与第一个 请求的间隔时间还在 1 分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于 1 分钟，且 counter 的值还在限流范围内，那么就重置 counter，具体算法的示意图如下：</p></blockquote><p><img src="https://file.buildworld.cn/img/20210610083810.jpg"></p><p>==存在临界问题！！！==</p><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><blockquote><p>滑动窗口，又称 rolling window。为了解决计数器算法带来的问题，我们引入了滑动窗口算法。如果学过 TCP 网络协议的话，那么一定对滑动窗口这个名词不会陌生。下面这张图，很好地解释了滑动窗口算法：</p></blockquote><p><img src="https://file.buildworld.cn/img/20210610085441.jpg"></p><p><strong>计数器算法其实就是滑动窗口算法，滑动窗口算法是它的细粒度表现</strong></p><p>==当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。==</p><h5 id="9-2、令牌桶算法"><a href="#9-2、令牌桶算法" class="headerlink" title="9.2、令牌桶算法"></a>9.2、令牌桶算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）、所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；</span><br><span class="line">2）、根据限流大小，设置按照一定的速率往桶里添加令牌；</span><br><span class="line">3）、桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；</span><br><span class="line">4）、请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；</span><br><span class="line">5）、令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流</span><br></pre></td></tr></table></figure><p><img src="https://file.buildworld.cn/img/20210610090132.png"></p><h5 id="9-3、漏桶算法"><a href="#9-3、漏桶算法" class="headerlink" title="9.3、漏桶算法"></a>9.3、漏桶算法</h5><blockquote><p>漏桶算法其实很简单，可以粗略的认为就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210610090216.png"></p>]]></content>
    
    
    <summary type="html">从九个细节考虑秒杀系统的设计。</summary>
    
    
    
    <category term="后端" scheme="https://www.buildworld.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://www.buildworld.cn/tags/Java/"/>
    
    <category term="Redis" scheme="https://www.buildworld.cn/tags/Redis/"/>
    
    <category term="架构设计" scheme="https://www.buildworld.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法那些事</title>
    <link href="https://www.buildworld.cn/2021/07/15/%E7%AE%97%E6%B3%95%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://www.buildworld.cn/2021/07/15/%E7%AE%97%E6%B3%95%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-07-15T00:56:01.000Z</published>
    <updated>2021-10-15T02:26:07.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="1、哈希表"><a href="#1、哈希表" class="headerlink" title="1、哈希表"></a>1、哈希表</h4><p><img src="https://file.buildworld.cn/img/20210715091717.png"></p><h5 id="1-1-构造规则"><a href="#1-1-构造规则" class="headerlink" title="1.1 构造规则"></a>1.1 构造规则</h5><ul><li>必须是一致的</li><li>计算简单</li><li>散列地址均匀分布</li></ul><h5 id="1-2-散列函数构造方法"><a href="#1-2-散列函数构造方法" class="headerlink" title="1.2 散列函数构造方法"></a>1.2 散列函数构造方法</h5><h6 id="1）直接定址法"><a href="#1）直接定址法" class="headerlink" title="1）直接定址法"></a>1）直接定址法</h6><blockquote><p>数组其实就是一张哈希表<br>f(key) = key<br><img src="https://file.buildworld.cn/img/20210715094229.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通用公式</span><br><span class="line">f(key) = a * key + b a,b均为常数</span><br></pre></td></tr></table></figure><h6 id="2）数字分析法"><a href="#2）数字分析法" class="headerlink" title="2）数字分析法"></a>2）数字分析法</h6><blockquote><p>该方法也是十分简单的方法，就是分析我们的关键字，取其中一段，或对其位移，叠加，用作地址。比如我们的学号，前 6 位都是一样的，但是后面 3 位都不相同，我们则可以用学号作为键，后面的 3 位做为我们的散列地址。如果我们这样还是容易产生冲突，则可以对抽取数字再进行处理。我们的目的只有一个，提供一个散列函数将关键字合理的分配到散列表的各位置。这里我们提到了一种新的方式，抽取，这也是在散列函数中经常用到的手段。<br><img src="https://file.buildworld.cn/img/20210715100009.png"></p></blockquote><h6 id="3）折叠法"><a href="#3）折叠法" class="headerlink" title="3）折叠法"></a>3）折叠法</h6><blockquote><p>主要思路是将关键字从左到右分割成位数相等的几部分，然后叠加求和，并按散列表表长，取后几位作为散列地址。</p></blockquote><h6 id="4）除法散列法"><a href="#4）除法散列法" class="headerlink" title="4）除法散列法"></a>4）除法散列法</h6><p>在用来设计散列函数的除法散列法中，通过取 key 除以 p 的余数，将关键字映射到 p 个槽中的某一个上，对于散列表长度为 m 的散列函数公式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 最经典的算法</span><br><span class="line">f(k) = k mod p (p &lt;= m)</span><br></pre></td></tr></table></figure><p><img src="https://file.buildworld.cn/img/20210715115210.png"></p><h6 id="5）乘法散列法"><a href="#5）乘法散列法" class="headerlink" title="5）乘法散列法"></a>5）乘法散列法</h6><p>构造散列函数的乘法散列法主要包含两个步骤</p><ul><li>用关键字 k 乘上常数 A(0 &lt; A &lt; 1)，并提取 k A 的小数部分</li><li>用 m 乘以这个值，再向下取整</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// kA mod 1 的含义是取 keyA 的小数部分，即 kA - ⌊kA⌋ 。</span><br><span class="line">f (k) = ⌊ m(kA mod 1) ⌋</span><br></pre></td></tr></table></figure><h6 id="6）平方取中法"><a href="#6）平方取中法" class="headerlink" title="6）平方取中法"></a>6）平方取中法</h6><blockquote><p>假设关键字是 321，那么他的平方就是 103041，再抽取中间的 3 位就是 030 或 304 用作散列地址。再比如关键字是 1234 那么它的平方就是 1522756 ，抽取中间 3 位就是 227 用作散列地址.</p></blockquote><h6 id="7）随机数法"><a href="#7）随机数法" class="headerlink" title="7）随机数法"></a>7）随机数法</h6><blockquote><p>取关键字的随机函数值为它的散列地址。也就是 f(key) = random(key)。这里的 random 是 随机函数。</p></blockquote><h5 id="1-2-处理散列冲突的方法"><a href="#1-2-处理散列冲突的方法" class="headerlink" title="1.2 处理散列冲突的方法"></a>1.2 处理散列冲突的方法</h5><h6 id="1）开放地址法"><a href="#1）开放地址法" class="headerlink" title="1）开放地址法"></a>1）开放地址法</h6><blockquote><p><strong>开放地址法</strong>就是一旦发生冲突，就去寻找下一个空的散列地址，只要列表足够大，空的散列地址总能找到，并将记录存入，为了使用开放寻址法插入一个元素，需要连续地检查散列表，或称为探查，我们常用的有<strong>线性探测</strong>，<strong>二次探测</strong>，<strong>随机探测</strong>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性探测： f,(key) = ( f(key) + di ) MOD m（di = 1,2,3,4,5,6....m-1）</span><br><span class="line"></span><br><span class="line">二次探测： f,(key) = ( f(key) + di ) MOD m（di =1^2 , -1^2 , 2^2 , -2^2 .... q^2, -q^2, q&lt;=m/2）</span><br></pre></td></tr></table></figure><h6 id="2）再哈希法"><a href="#2）再哈希法" class="headerlink" title="2）再哈希法"></a>2）再哈希法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 利用不同的哈希函数再求得一个哈希地址，直到不出现冲突为止</span><br><span class="line">f,(key) = RH,( key ) (i = 1,2,3,4.....k)</span><br></pre></td></tr></table></figure><blockquote><p>这里的 RH,就是不同的散列函数，你可以把我们之前说过的那些散列函数都用上，每当发生冲突时就换一个散列函数，相信总有一个能够解决冲突的。这种方法能使关键字不产生聚集，但是代价就是增加了计算时间。是不是很简单啊。</p></blockquote><h6 id="3）链地址法"><a href="#3）链地址法" class="headerlink" title="3）链地址法"></a>3）链地址法</h6><p><img src="https://file.buildworld.cn/img/20210715122020.png"></p><h6 id="4）公共溢出区法"><a href="#4）公共溢出区法" class="headerlink" title="4）公共溢出区法"></a>4）公共溢出区法</h6><p><img src="https://file.buildworld.cn/img/20210715130811.png"></p><h5 id="1-3）散列表性能分析"><a href="#1-3）散列表性能分析" class="headerlink" title="1.3）散列表性能分析"></a>1.3）散列表性能分析</h5><p>1.散列函数是否均匀</p><p>2.处理冲突的方法</p><p>3.散列表的装填因子</p><h4 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h4><blockquote><p><strong>栈（stack）是限制插入和删除只能在一个位置上进行的表</strong>，该位置是表的末端叫做栈的顶（top），对栈的基本操作有 push(进栈)和 pop(出栈),前者相当于插入，后者则是删除最后插入的元素。</p></blockquote><h5 id="Java-中栈的实现"><a href="#Java-中栈的实现" class="headerlink" title="Java 中栈的实现"></a>Java 中栈的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();<span class="comment">//类型为TreeNode</span></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br></pre></td></tr></table></figure><h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><blockquote><p>像栈一样，队列（queue）也是表。然而使用队列时插入在一端进行而删除在另一端进行，遵守先进先出的规则。所以队列的另一个名字是（FIFO）。</p></blockquote><blockquote><p>队列的基本操作是入队（enqueue）:它是在表的末端(队尾(rear)插入一个元素。出队（dequeue）:出队他是删除在表的开头（队头(front)）的元素。</p></blockquote><h5 id="Java-中队列的实现"><a href="#Java-中队列的实现" class="headerlink" title="Java 中队列的实现"></a>Java 中队列的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br></pre></td></tr></table></figure><h4 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h4><blockquote><p>链表是一种递归的数据结构，他或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p></blockquote><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p><img src="https://file.buildworld.cn/img/20210715140633.png"></p><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p><img src="https://file.buildworld.cn/img/20210715140701.png"></p><h4 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h4><p><img src="https://file.buildworld.cn/img/20210715141553.png"></p><h5 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h5><p><img src="https://file.buildworld.cn/img/20210715142011.png"><br><img src="https://file.buildworld.cn/img/20210715142048.png"></p>]]></content>
    
    
    <summary type="html">常见的数据结构</summary>
    
    
    
    <category term="提高" scheme="https://www.buildworld.cn/categories/%E6%8F%90%E9%AB%98/"/>
    
    
    <category term="算法" scheme="https://www.buildworld.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>14种常见的算法模式</title>
    <link href="https://www.buildworld.cn/2021/07/09/14%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.buildworld.cn/2021/07/09/14%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-09T03:41:36.000Z</published>
    <updated>2021-10-15T02:26:58.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>微信公众号<br><a href="https://mp.weixin.qq.com/s/FbMCAiRN_rO9a_GV4pCGoA">https://mp.weixin.qq.com/s/FbMCAiRN_rO9a_GV4pCGoA</a></p><p>代码仓库<br><a href="https://github.com/TangBean/grokking-the-coding-interview/">https://github.com/TangBean/grokking-the-coding-interview/</a></p><h4 id="1．滑动窗口"><a href="#1．滑动窗口" class="headerlink" title="1．滑动窗口"></a>1．滑动窗口</h4><p><img src="https://file.buildworld.cn/img/20210706090931.webp"></p><h5 id="1-1-给定问题可能需要滑动窗口的方法"><a href="#1-1-给定问题可能需要滑动窗口的方法" class="headerlink" title="1.1 给定问题可能需要滑动窗口的方法"></a>1.1 给定问题可能需要滑动窗口的方法</h5><ul><li>问题的输入是一种线性数据结构，比如链表、数组或字符串</li><li>你被要求查找最长/最短的子字符串、子数组或所需的值</li></ul><h5 id="1-2-可以使用滑动窗口模式处理的常见问题"><a href="#1-2-可以使用滑动窗口模式处理的常见问题" class="headerlink" title="1.2 可以使用滑动窗口模式处理的常见问题"></a>1.2 可以使用滑动窗口模式处理的常见问题</h5><ul><li>大小为 K 的子数组的最大和（简单）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an array of positive numbers and a positive number ‘k’,</span></span><br><span class="line"><span class="comment">     * find the maximum sum of any contiguous subarray of size ‘k’.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Example 1:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: [2, 1, 5, 1, 3, 2], k=3</span></span><br><span class="line"><span class="comment">     * Output: 9</span></span><br><span class="line"><span class="comment">     * Explanation: Subarray with maximum sum is [5, 1, 3].</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Example 2:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: [2, 3, 4, 1, 5], k=2</span></span><br><span class="line"><span class="comment">     * Output: 7</span></span><br><span class="line"><span class="comment">     * Explanation: Subarray with maximum sum is [3, 4].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaxSumSubArray</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 过滤不符合条件的输入变量</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || arr.length &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 累加</span></span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="comment">// 当窗口超过k</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                sum -= arr[i - k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较当前窗口和上一个窗口的大小</span></span><br><span class="line">            <span class="comment">// 如果当前窗口大，则就选择当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; res) &#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>带有 K 个不同字符的最长子字符串（中等）</li><li>寻找字符相同但排序不一样的字符串（困难）</li></ul><h4 id="2．二指针或迭代器"><a href="#2．二指针或迭代器" class="headerlink" title="2．二指针或迭代器"></a>2．二指针或迭代器</h4><blockquote><p>两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。<br>二指针通常在排序数组或链表中搜索配对时很有用：比如当你必须将一个数组的每个元素与其它元素做比较时。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210706095414.webp"></p><h5 id="2-1、识别使用二指针的时机的方法"><a href="#2-1、识别使用二指针的时机的方法" class="headerlink" title="2.1、识别使用二指针的时机的方法"></a>2.1、识别使用二指针的时机的方法</h5><ul><li>可用于你要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题。</li><li>数组中的元素集是配对、三元组甚至子数组。</li></ul><h5 id="2-2-满足二指针模式的问题"><a href="#2-2-满足二指针模式的问题" class="headerlink" title="2.2 满足二指针模式的问题"></a>2.2 满足二指针模式的问题</h5><ul><li>求一个排序数组的平方（简单）</li><li>求总和为零的三元组（中等）</li><li>比较包含回退（backspace）的字符串（中等）</li></ul><h4 id="3．快速和慢速指针或迭代器"><a href="#3．快速和慢速指针或迭代器" class="headerlink" title="3．快速和慢速指针或迭代器"></a>3．快速和慢速指针或迭代器</h4><blockquote><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列/链表）中以不同速度移动的指针。该方法在处理循环链表或数组时非常有用。通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210706101049.webp"></p><h5 id="3-1-、使用快速和慢速模式的时机"><a href="#3-1-、使用快速和慢速模式的时机" class="headerlink" title="3.1 、使用快速和慢速模式的时机"></a>3.1 、使用快速和慢速模式的时机</h5><ul><li>处理链表或数组中的循环的问题</li><li>当你需要知道特定元素的位置或链表的总长度时</li></ul><h5 id="3-2-、满足快速和慢速指针模式的问题"><a href="#3-2-、满足快速和慢速指针模式的问题" class="headerlink" title="3.2 、满足快速和慢速指针模式的问题"></a>3.2 、满足快速和慢速指针模式的问题</h5><ul><li>链表循环（简单）</li><li>回文链表（中等）</li><li>环形数组中的循环（困难）</li></ul><h4 id="4．合并区间"><a href="#4．合并区间" class="headerlink" title="4．合并区间"></a>4．合并区间</h4><p><strong>合并区间模式是一种处理重叠区间的有效技术。</strong></p><blockquote><p>在很多涉及区间的问题中，你既需要找到重叠的区间，也需要在这些区间重叠时合并它们。该模式的工作方式为：给定两个区间（a 和 b），这两个区间有 6 种不同的互相关联的方式：<br><img src="https://file.buildworld.cn/img/20210706101941.webp"></p></blockquote><h5 id="4-1-使用合并区间的时机"><a href="#4-1-使用合并区间的时机" class="headerlink" title="4.1 使用合并区间的时机"></a>4.1 使用合并区间的时机</h5><ul><li>如果你被要求得到一个仅含互斥区间的列表</li><li>如果你听到了术语「重叠区间（overlapping intervals）</li></ul><h5 id="4-2-使用合并区间方法解决的问题"><a href="#4-2-使用合并区间方法解决的问题" class="headerlink" title="4.2 使用合并区间方法解决的问题"></a>4.2 使用合并区间方法解决的问题</h5><ul><li>区间交叉（中等）</li><li>最大 CPU 负载（困难）</li></ul><h4 id="5．循环排序"><a href="#5．循环排序" class="headerlink" title="5．循环排序"></a>5．循环排序</h4><blockquote><p>循环排序模式一次会在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就将其与其正确索引处的数值交换。<br><img src="https://file.buildworld.cn/img/20210706102937.webp"></p></blockquote><h5 id="5-1-使用循环排序的时机"><a href="#5-1-使用循环排序的时机" class="headerlink" title="5.1 使用循环排序的时机"></a>5.1 使用循环排序的时机</h5><ul><li>涉及数值在给定范围内的排序数组的问题</li><li>如果问题要求你在一个排序/旋转的数组中找到缺失值/重复值/最小值</li></ul><h5 id="5-2-使用循环排序解决的问题"><a href="#5-2-使用循环排序解决的问题" class="headerlink" title="5.2 使用循环排序解决的问题"></a>5.2 使用循环排序解决的问题</h5><ul><li>找到缺失值（简单）</li><li>找到最小的缺失的正数值（中等）</li></ul><h4 id="6．原地反转链表"><a href="#6．原地反转链表" class="headerlink" title="6．原地反转链表"></a>6．原地反转链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在很多问题中，你可能会被要求反转一个链表中一组节点之间的链接。</span><br><span class="line"></span><br><span class="line">通常而言，你需要原地完成这一任务，即使用已有的节点对象且不占用额外的内存。这就是这个模式的用武之地。</span><br><span class="line"></span><br><span class="line">该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://file.buildworld.cn/img/20210706111707.webp"></p><h5 id="6-1、使用反转链表的时机"><a href="#6-1、使用反转链表的时机" class="headerlink" title="6.1、使用反转链表的时机"></a>6.1、使用反转链表的时机</h5><ul><li>如果你被要求在不使用额外内存的前提下反转一个链表</li></ul><h5 id="6-2、使用反转链表的问题"><a href="#6-2、使用反转链表的问题" class="headerlink" title="6.2、使用反转链表的问题"></a>6.2、使用反转链表的问题</h5><ul><li>反转一个子列表（中等）</li><li>反转每个 K 个元素的子列表（中等）</li></ul><h4 id="7．树的宽度优先搜索（Tree-BFS）"><a href="#7．树的宽度优先搜索（Tree-BFS）" class="headerlink" title="7．树的宽度优先搜索（Tree BFS）"></a>7．树的宽度优先搜索（Tree BFS）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。</span><br><span class="line"></span><br><span class="line">任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。</span><br><span class="line"></span><br><span class="line">Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代知道队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。</span><br><span class="line">在移除了队列中的每个节点之后，我们还将其所有子节点插入到队列中。</span><br></pre></td></tr></table></figure><h5 id="7-1-、使用时机"><a href="#7-1-、使用时机" class="headerlink" title="7.1 、使用时机"></a>7.1 、使用时机</h5><ul><li>如果你被要求以逐层级方式遍历（或按层级顺序遍历）一个树</li></ul><h5 id="7-2、解决的问题"><a href="#7-2、解决的问题" class="headerlink" title="7.2、解决的问题"></a>7.2、解决的问题</h5><ul><li>二叉树层级顺序遍历（简单）</li><li>之字型遍历（Zigzag Traversal）（中等）</li></ul><h4 id="8．树的深度优先搜索（Tree-DFS）"><a href="#8．树的深度优先搜索（Tree-DFS）" class="headerlink" title="8．树的深度优先搜索（Tree DFS）"></a>8．树的深度优先搜索（Tree DFS）</h4><blockquote><p>Tree DFS 是基于深度优先搜索（DFS）技术来遍历树。你可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tree DFS 模式的工作方式是从树的根部开始，如果这个节点不是一个叶节点，则需要做两件事：</span><br><span class="line"></span><br><span class="line">    1．决定现在是处理当前的节点（pre-order），或是在处理两个子节点之间（in-order），还是在处理两个子节点之后（post-order）</span><br><span class="line">    2．为当前节点的两个子节点执行两次递归调用以处理它们</span><br></pre></td></tr></table></figure><h5 id="8-1、使用时机"><a href="#8-1、使用时机" class="headerlink" title="8.1、使用时机"></a>8.1、使用时机</h5><ul><li>如果你被要求用 in-order、pre-order 或 post-order DFS 来遍历一个树</li><li>如果问题需要搜索其中节点更接近叶节点的东西</li></ul><h5 id="8-2、解决问题"><a href="#8-2、解决问题" class="headerlink" title="8.2、解决问题"></a>8.2、解决问题</h5><ul><li>路径数量之和（中等）</li><li>一个和的所有路径（中等）</li></ul><h4 id="9．Two-Heaps"><a href="#9．Two-Heaps" class="headerlink" title="9．Two Heaps"></a>9．Two Heaps</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在很多问题中，我们要将给定的一组元素分为两部分。</span><br><span class="line"></span><br><span class="line">为了求解这个问题，我们感兴趣的是了解一部分的最小元素以及另一部分的最大元素。这一模式是求解这类问题的一种有效方法。</span><br><span class="line"></span><br><span class="line">该模式要使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap。</span><br></pre></td></tr></table></figure><h5 id="9-1、使用时机"><a href="#9-1、使用时机" class="headerlink" title="9.1、使用时机"></a>9.1、使用时机</h5><ul><li>在优先级队列、调度等场景中有用</li><li>如果问题说你需要找到一个集合的最小/最大/中间元素</li><li>有时候可用于具有二叉树数据结构的问题</li></ul><h5 id="9-2、解决问题"><a href="#9-2、解决问题" class="headerlink" title="9.2、解决问题"></a>9.2、解决问题</h5><ul><li>查找一个数值流的中间值（中等）</li></ul><h4 id="10．子集"><a href="#10．子集" class="headerlink" title="10．子集"></a>10．子集</h4><blockquote><p>子集（Subsets）模式描述了一种用于有效处理所有这些问题的宽度优先搜索（BFS）方法<br><img src="https://file.buildworld.cn/img/20210706133238.webp"></p></blockquote><h5 id="10-1、使用时机"><a href="#10-1、使用时机" class="headerlink" title="10.1、使用时机"></a>10.1、使用时机</h5><ul><li>你需要找到给定集合的组合或排列的问题</li></ul><h5 id="10-2、解决问题"><a href="#10-2、解决问题" class="headerlink" title="10.2、解决问题"></a>10.2、解决问题</h5><ul><li>带有重复项的子集（简单）</li><li>通过改变大小写的字符串排列（中等）</li></ul><h4 id="11．经过修改的二叉搜索"><a href="#11．经过修改的二叉搜索" class="headerlink" title="11．经过修改的二叉搜索"></a>11．经过修改的二叉搜索</h4><blockquote><p>只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于一个升序的集合，该模式看起来是这样的：</span><br><span class="line"></span><br><span class="line">    1．首先，找到起点和终点的中间位置。</span><br><span class="line">    寻找中间位置的一种简单方法是：middle = (start + end) / 2。</span><br><span class="line">    但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle = start + (end—start) / 2。</span><br><span class="line">    2．如果键值（key）等于中间索引处的值，那么返回这个中间位置。</span><br><span class="line">    3．如果键值不等于中间索引处的值：</span><br><span class="line">    4．检查 key &lt; arr[middle] 是否成立。如果成立，将搜索约简到 end = middle—1【换行】5．检查 key &gt; arr[middle] 是否成立。如果成立，将搜索约简到 end = middle + 1</span><br></pre></td></tr></table></figure><p><img src="https://file.buildworld.cn/img/20210706133627.webp"></p><h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><ul><li>与顺序无关的二叉搜索（简单）</li><li>在经过排序的无限数组中搜索（中等）</li></ul><h4 id="12．前-K-个元素"><a href="#12．前-K-个元素" class="headerlink" title="12．前 K 个元素"></a>12．前 K 个元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任何要求我们找到一个给定集合中前面的/最小的/最常出现的 K 的元素的问题都在这一模式的范围内。</span><br><span class="line">跟踪 K 个元素的最佳的数据结构是 Heap。</span><br><span class="line">这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。</span><br></pre></td></tr></table></figure><ul><li>1．根据问题的不同，将 K 个元素插入到 min-heap 或 max-heap 中</li><li>2．迭代处理剩余的数，如果你找到一个比 heap 中数更大的数，那么就移除那个数并插入这个更大的数<br><img src="https://file.buildworld.cn/img/20210706133855.webp"></li></ul><h5 id="12-1、使用时机"><a href="#12-1、使用时机" class="headerlink" title="12.1、使用时机"></a>12.1、使用时机</h5><ul><li>如果你被要求寻找一个给定集合中前面的/最小的/最常出现的 K 的元素</li><li>如果你被要求对一个数值进行排序以找到一个确定元素</li></ul><h5 id="12-2、解决问题"><a href="#12-2、解决问题" class="headerlink" title="12.2、解决问题"></a>12.2、解决问题</h5><ul><li>前面的 K 个数（简单）</li><li>最常出现的 K 个数（中等）</li></ul><h4 id="13．K-路合并"><a href="#13．K-路合并" class="headerlink" title="13．K 路合并"></a>13．K 路合并</h4><blockquote><p>K 路合并能帮助你求解涉及一组经过排序的数组的问题。当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。然后，重复这一过程以得到所有元素的排序遍历结果。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210706134355.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1．将每个数组的第一个元素插入 Min Heap</span><br><span class="line">2．之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。</span><br><span class="line">3．在从 Heap 移除了最小的元素之后，将同一列表的下一个元素插入该 Heap</span><br><span class="line">4．重复步骤 2 和 3，以排序的顺序填充合并的列表</span><br></pre></td></tr></table></figure><h5 id="13-1、使用时机"><a href="#13-1、使用时机" class="headerlink" title="13.1、使用时机"></a>13.1、使用时机</h5><ul><li>具有排序数组、列表或矩阵的问题</li><li>如果问题要求你合并排序的列表，找到一个排序列表中的最小元素</li></ul><h5 id="13-2、解决问题"><a href="#13-2、解决问题" class="headerlink" title="13.2、解决问题"></a>13.2、解决问题</h5><ul><li>合并 K 个排序的列表（中等）</li><li>找到和最大的 K 个配对（困难）</li></ul><h4 id="14．拓扑排序"><a href="#14．拓扑排序" class="headerlink" title="14．拓扑排序"></a>14．拓扑排序</h4><blockquote><p>拓扑排序可用于寻找互相依赖的元素的线性顺序。比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前。这个模式定义了一种简单方法来理解执行一组元素的拓扑排序的技术。该模式看起来是这样的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1．初始化。</span><br><span class="line">    a）使用 HashMap 将图（graph）存储到邻接的列表中；</span><br><span class="line">    b）为了查找所有源，使用 HashMap 记录 in-degree 的数量</span><br><span class="line"></span><br><span class="line">2．构建图并找到所有顶点的 in-degree。</span><br><span class="line">    a）根据输入构建图并填充 in-degree HashMap</span><br><span class="line"></span><br><span class="line">3．寻找所有的源。</span><br><span class="line">    a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列</span><br><span class="line"></span><br><span class="line">4．排序。</span><br><span class="line">    a）对于每个源，执行以下操作：</span><br><span class="line">        i）将其加入到排序的列表；</span><br><span class="line">        ii）根据图获取其所有子节点；</span><br><span class="line">        iii）将每个子节点的 in-degree 减少 1；</span><br><span class="line">        iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。</span><br><span class="line"></span><br><span class="line">    b）重复 (a)，直到源队列为空。</span><br></pre></td></tr></table></figure><p><img src="https://file.buildworld.cn/img/20210706150056.webp"></p><h5 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h5><ul><li>处理无向有环图的问题</li><li>如果你被要求以排序顺序更新所有对象</li><li>如果你有一类遵循特定顺序的对象</li></ul>]]></content>
    
    
    <summary type="html">14中常见的算法模式</summary>
    
    
    
    <category term="提高" scheme="https://www.buildworld.cn/categories/%E6%8F%90%E9%AB%98/"/>
    
    
    <category term="算法" scheme="https://www.buildworld.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode数据库题目集合</title>
    <link href="https://www.buildworld.cn/2021/02/09/LeetCode%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%E9%9B%86%E5%90%88/"/>
    <id>https://www.buildworld.cn/2021/02/09/LeetCode%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%E9%9B%86%E5%90%88/</id>
    <published>2021-02-09T08:13:56.000Z</published>
    <updated>2021-04-09T02:11:41.451Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><a href="https://leetcode-cn.com/problemset/database/">https://leetcode-cn.com/problemset/database/</a></p><p>题目都是leetcode 上了可以点击题目会有相应的链接</p><p>由于个人比较喜欢用开窗函数，所以都优先用了开窗 ，当然这些并不一定都是最优解，答案仅供参考</p><p>每道题后面都应相应的难度等级，如果没时间做的话 可以在leetcode 按出题频率刷题</p><p>我是安顺序刷的题，后续还会继续更新</p><p>祝大家面试取得好的成绩</p></blockquote><h4 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h4><p>难度简单</p><p>SQL架构</p><p>表1: <code>Person</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure><p>表2: <code>Address</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> FirstName,LastName,City,State</span><br><span class="line"><span class="keyword">from</span> Person  p</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>  Address a </span><br><span class="line"><span class="keyword">on</span> a.PersonId <span class="operator">=</span> p.PersonId</span><br></pre></td></tr></table></figure><h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h4><p>难度简单</p><p>SQL架构</p><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    IFNULL(</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">       <span class="keyword">FROM</span> Employee</span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><h4 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/">177. 第N高的薪水</a></h4><p>难度中等</p><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| getNthHighestSalary(2) |</span><br><span class="line">+------------------------+</span><br><span class="line">| 200                    |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> N <span class="operator">=</span> N<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">RETURN</span> (</span><br><span class="line">        <span class="keyword">select</span> ifnull((</span><br><span class="line">                          <span class="keyword">select</span> <span class="keyword">distinct</span> Salary</span><br><span class="line">                          <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> limit N,<span class="number">1</span>),</span><br><span class="line">                      <span class="keyword">NULL</span>)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/">178. 分数排名</a></h4><p>难度中等</p><p>SQL架构</p><p>编写一个 SQL 查询来实现分数排名。</p><p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong>对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <strong><code>Rank</code></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Score,</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) `rank`</span><br><span class="line"><span class="keyword">from</span> Scores</span><br></pre></td></tr></table></figure><h4 id="180-连续出现的数字"><a href="#180-连续出现的数字" class="headerlink" title="180. 连续出现的数字"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/">180. 连续出现的数字</a></h4><p>难度中等</p><p>SQL架构</p><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure><p>例如，给定上面的 <code>Logs</code> 表， <code>1</code> 是唯一连续出现至少三次的数字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> ConsecutiveNums <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Num ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">Num,</span><br><span class="line"><span class="built_in">lead</span>(Num,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) n2,</span><br><span class="line"><span class="built_in">lead</span>(Num,<span class="number">2</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) n3</span><br><span class="line"><span class="keyword">from</span> Logs</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> Num <span class="operator">=</span> n2 <span class="keyword">and</span> Num <span class="operator">=</span> n3</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> l1.num <span class="keyword">as</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">from</span> logs l1</span><br><span class="line">         <span class="keyword">join</span> logs l2 <span class="keyword">on</span> l1.num <span class="operator">=</span> l2.num</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> l1.Id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(l1.Id <span class="operator">-</span> l2.Id <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span>) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工</a></h4><p>难度简单</p><p>SQL架构</p><p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure><p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> Employee <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> Joe      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name  Employee </span><br><span class="line"><span class="keyword">from</span> Employee a </span><br><span class="line"><span class="keyword">join</span> Employee b</span><br><span class="line"><span class="keyword">on</span> a.ManagerId <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">where</span> a.Salary<span class="operator">&gt;</span>b.Salary</span><br></pre></td></tr></table></figure><h4 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h4><p>难度简单</p><p>SQL架构</p><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>根据以上输入，你的查询应返回以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>所有电子邮箱都是小写字母。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/">183. 从不订购的客户</a></h4><p>难度简单</p><p>SQL架构</p><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p><code>Customers</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> Customers <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> Henry     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Max       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  c.Name Customers</span><br><span class="line"><span class="keyword">from</span> Customers  c <span class="keyword">left</span> <span class="keyword">join</span> Orders  o</span><br><span class="line"><span class="keyword">on</span> c.id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="keyword">where</span> o.id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/">184. 部门工资最高的员工</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure><p><code>Department</code> 表包含公司所有部门的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> Department <span class="operator">|</span> Employee <span class="operator">|</span> Salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> IT         <span class="operator">|</span> Max      <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sales      <span class="operator">|</span> Henry    <span class="operator">|</span> <span class="number">80000</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department,Employee,Salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> d.Name  Department,e.Name Employee, e.Salary,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> d.id <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">join</span> Department d</span><br><span class="line"><span class="keyword">on</span> e.DepartmentId<span class="operator">=</span>d.id</span><br><span class="line">)tmp</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/">185. 部门工资前三高的所有员工</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的工号 <code>Id</code>，姓名 <code>Name</code>，工资 <code>Salary</code> 和部门编号 <code>DepartmentId</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 85000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">| 5  | Janet | 69000  | 1            |</span><br><span class="line">| 6  | Randy | 85000  | 1            |</span><br><span class="line">| 7  | Will  | 70000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure><p><code>Department</code> 表包含公司所有部门的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| IT         | Randy    | 85000  |</span><br><span class="line">| IT         | Joe      | 85000  |</span><br><span class="line">| IT         | Will     | 70000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">| Sales      | Sam      | 60000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department,Employee,Salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> d.Name  Department,e.Name Employee, e.Salary,</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> d.id <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">join</span> Department d</span><br><span class="line"><span class="keyword">on</span> e.DepartmentId<span class="operator">=</span>d.id</span><br><span class="line">)tmp</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">&lt;=</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196. 删除重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></h4><p>难度简单</p><p>编写一个 SQL 查询，来删除 <code>Person</code> 表中所有重复的电子邮箱，重复的邮箱里只保留 <strong>Id</strong> <em>最小</em> 的那个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br></pre></td></tr></table></figure><p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>执行 SQL 之后，输出是整个 <code>Person</code> 表。</p></li><li><p>使用 <code>delete</code> 语句。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure><blockquote><p>注意是删除 ，不是查询</p></blockquote><h4 id="197-上升的温度"><a href="#197-上升的温度" class="headerlink" title="197. 上升的温度"></a><a href="https://leetcode-cn.com/problems/rising-temperature/">197. 上升的温度</a></h4><p>难度简单</p><p>SQL架构</p><p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------+------------------+------------------+</span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+---------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">Id</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> Id,RecordDate,Temperature,</span><br><span class="line"><span class="built_in">lag</span>(RecordDate,<span class="number">1</span>,<span class="number">9999</span><span class="number">-99</span><span class="number">-99</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> RecordDate) yd,</span><br><span class="line"><span class="built_in">lag</span>(Temperature,<span class="number">1</span>,<span class="number">999</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> RecordDate ) yt</span><br><span class="line"><span class="keyword">from</span> Weather </span><br><span class="line">)tmp</span><br><span class="line"><span class="keyword">where</span> Temperature <span class="operator">&gt;</span>yt</span><br><span class="line"><span class="keyword">and</span> datediff(RecordDate,yd)<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Id <span class="keyword">from</span> Weather a ,Weather b </span><br><span class="line">    <span class="keyword">where</span> a.Temperature <span class="operator">&gt;</span> b.Temperature </span><br><span class="line">    <span class="keyword">and</span> datediff(a.RecordDate,b.RecordDate) <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="262-行程和用户"><a href="#262-行程和用户" class="headerlink" title="262. 行程和用户"></a><a href="https://leetcode-cn.com/problems/trips-and-users/">262. 行程和用户</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Trips</code> 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 <code>Users</code> 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+----+-----------+-----------+---------+--------------------+----------+</span><br><span class="line">| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|</span><br><span class="line">+----+-----------+-----------+---------+--------------------+----------+</span><br><span class="line">| 1  |     1     |    10     |    1    |     completed      |2013-10-01|</span><br><span class="line">| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|</span><br><span class="line">| 3  |     3     |    12     |    6    |     completed      |2013-10-01|</span><br><span class="line">| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|</span><br><span class="line">| 5  |     1     |    10     |    1    |     completed      |2013-10-02|</span><br><span class="line">| 6  |     2     |    11     |    6    |     completed      |2013-10-02|</span><br><span class="line">| 7  |     3     |    12     |    6    |     completed      |2013-10-02|</span><br><span class="line">| 8  |     2     |    12     |    12   |     completed      |2013-10-03|</span><br><span class="line">| 9  |     3     |    10     |    12   |     completed      |2013-10-03| </span><br><span class="line">| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|</span><br><span class="line">+----+-----------+-----------+---------+--------------------+----------+</span><br></pre></td></tr></table></figure><p><code>Users</code> 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------+--------+--------+</span><br><span class="line">| Users_Id | Banned |  Role  |</span><br><span class="line">+----------+--------+--------+</span><br><span class="line">|    1     |   No   | client |</span><br><span class="line">|    2     |   Yes  | client |</span><br><span class="line">|    3     |   No   | client |</span><br><span class="line">|    4     |   No   | client |</span><br><span class="line">|    10    |   No   | driver |</span><br><span class="line">|    11    |   No   | driver |</span><br><span class="line">|    12    |   No   | driver |</span><br><span class="line">|    13    |   No   | driver |</span><br><span class="line">+----------+--------+--------+</span><br></pre></td></tr></table></figure><p>写一段 SQL 语句查出 <strong>2013年10月1日</strong> 至 <strong>2013年10月3日</strong> 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。</p><p>取消率的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="keyword">Day</span>    <span class="operator">|</span> Cancellation Rate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2013</span><span class="number">-10</span><span class="number">-01</span> <span class="operator">|</span>       <span class="number">0.33</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2013</span><span class="number">-10</span><span class="number">-02</span> <span class="operator">|</span>       <span class="number">0.00</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2013</span><span class="number">-10</span><span class="number">-03</span> <span class="operator">|</span>       <span class="number">0.50</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-------------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T.request_at <span class="keyword">AS</span> `<span class="keyword">Day</span>`, </span><br><span class="line">ROUND(</span><br><span class="line"><span class="built_in">SUM</span>(</span><br><span class="line">IF(T.STATUS <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="operator">/</span> </span><br><span class="line"><span class="built_in">COUNT</span>(T.STATUS),</span><br><span class="line"><span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span> `Cancellation Rate`</span><br><span class="line"><span class="keyword">FROM</span> trips <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">T.Client_Id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> users_id</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> banned <span class="operator">=</span> <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line">T.Driver_Id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> users_id</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> banned <span class="operator">=</span> <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> T.request_at <span class="keyword">BETWEEN</span> <span class="string">&#x27;2013-10-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2013-10-03&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T.request_at</span><br></pre></td></tr></table></figure><h4 id="511-游戏玩法分析-I"><a href="#511-游戏玩法分析-I" class="headerlink" title="511. 游戏玩法分析 I"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-i/">511. 游戏玩法分析 I</a></h4><p>难度简单</p><p>SQL架构</p><p>活动表 <code>Activity</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">表的主键是 (player_id, event_date)。</span><br><span class="line">这张表展示了一些游戏玩家在游戏平台上的行为活动。</span><br><span class="line">每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。</span><br></pre></td></tr></table></figure><p>写一条 SQL 查询语句获取每位玩家 <strong>第一次登陆平台的日期</strong>。</p><p>查询结果的格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Activity 表：</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| 1         | 2         | 2016-03-01 | 5            |</span><br><span class="line">| 1         | 2         | 2016-05-02 | 6            |</span><br><span class="line">| 2         | 3         | 2017-06-25 | 1            |</span><br><span class="line">| 3         | 1         | 2016-03-02 | 0            |</span><br><span class="line">| 3         | 4         | 2018-07-03 | 5            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| player_id | first_login |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| 1         | 2016-03-01  |</span><br><span class="line">| 2         | 2017-06-25  |</span><br><span class="line">| 3         | 2016-03-02  |</span><br><span class="line">+-----------+-------------+</span><br></pre></td></tr></table></figure><p>1.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id ,event_date first_login</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> player_id ,event_date,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) rk</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line">) tmp</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2.最优 （选最小日期）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id ,<span class="built_in">min</span>(event_date) first_login</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> player_id </span><br></pre></td></tr></table></figure><h4 id="512-游戏玩法分析-II"><a href="#512-游戏玩法分析-II" class="headerlink" title="512. 游戏玩法分析 II"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-ii/">512. 游戏玩法分析 II</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Activity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">(player_id, event_date) 是这个表的两个主键</span><br><span class="line">这个表显示的是某些游戏玩家的游戏活动情况</span><br><span class="line">每一行是在某天使用某个设备登出之前登录并玩多个游戏（可能为0）的玩家的记录</span><br></pre></td></tr></table></figure><p>请编写一个 SQL 查询，描述每一个玩家首次登陆的设备名称</p><p>查询结果格式在以下示例中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Activity table:</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| 1         | 2         | 2016-03-01 | 5            |</span><br><span class="line">| 1         | 2         | 2016-05-02 | 6            |</span><br><span class="line">| 2         | 3         | 2017-06-25 | 1            |</span><br><span class="line">| 3         | 1         | 2016-03-02 | 0            |</span><br><span class="line">| 3         | 4         | 2018-07-03 | 5            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| player_id | device_id |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| 1         | 2         |</span><br><span class="line">| 2         | 3         |</span><br><span class="line">| 3         | 1         |</span><br><span class="line">+-----------+-----------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id ,device_id</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> player_id ,event_date,device_id,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) rk</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line">) tmp</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="534-游戏玩法分析-III"><a href="#534-游戏玩法分析-III" class="headerlink" title="534. 游戏玩法分析 III"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-iii/">534. 游戏玩法分析 III</a></h4><p>难度中等20收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>Table: <code>Activity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">（player_id，event_date）是此表的主键。</span><br><span class="line">这张表显示了某些游戏的玩家的活动情况。</span><br><span class="line">每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0 ）。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Activity table:</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| 1         | 2         | 2016-03-01 | 5            |</span><br><span class="line">| 1         | 2         | 2016-05-02 | 6            |</span><br><span class="line">| 1         | 3         | 2017-06-25 | 1            |</span><br><span class="line">| 3         | 1         | 2016-03-02 | 0            |</span><br><span class="line">| 3         | 4         | 2018-07-03 | 5            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------+------------+---------------------+</span><br><span class="line">| player_id | event_date | games_played_so_far |</span><br><span class="line">+-----------+------------+---------------------+</span><br><span class="line">| 1         | 2016-03-01 | 5                   |</span><br><span class="line">| 1         | 2016-05-02 | 11                  |</span><br><span class="line">| 1         | 2017-06-25 | 12                  |</span><br><span class="line">| 3         | 2016-03-02 | 0                   |</span><br><span class="line">| 3         | 2018-07-03 | 5                   |</span><br><span class="line">+-----------+------------+---------------------+</span><br><span class="line">对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。</span><br><span class="line">对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。</span><br><span class="line">请注意，对于每个玩家，我们只关心玩家的登录日期。</span><br></pre></td></tr></table></figure><p>开窗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id,event_date ,</span><br><span class="line"><span class="built_in">sum</span>(games_played) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span>  event_date )games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity</span><br></pre></td></tr></table></figure><p>自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    a1.player_id,</span><br><span class="line">    a1.event_date,</span><br><span class="line">    <span class="built_in">sum</span>(a2.games_played) games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity a1,Activity a2</span><br><span class="line"><span class="keyword">where</span> a1.player_id<span class="operator">=</span>a2.player_id <span class="keyword">and</span> </span><br><span class="line">      a1.event_date<span class="operator">&gt;=</span>a2.event_date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="550-游戏玩法分析-IV"><a href="#550-游戏玩法分析-IV" class="headerlink" title="550. 游戏玩法分析 IV"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-iv/">550. 游戏玩法分析 IV</a></h4><p>难度中等17收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>Table: <code>Activity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">（player_id，event_date）是此表的主键。</span><br><span class="line">这张表显示了某些游戏的玩家的活动情况。</span><br><span class="line">每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的分数，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Activity table:</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| 1         | 2         | 2016-03-01 | 5            |</span><br><span class="line">| 1         | 2         | 2016-03-02 | 6            |</span><br><span class="line">| 2         | 3         | 2017-06-25 | 1            |</span><br><span class="line">| 3         | 1         | 2016-03-02 | 0            |</span><br><span class="line">| 3         | 4         | 2018-07-03 | 5            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------+</span><br><span class="line">| fraction  |</span><br><span class="line">+-----------+</span><br><span class="line">| 0.33      |</span><br><span class="line">+-----------+</span><br><span class="line">只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(a.event_date <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>), <span class="number">2</span>) fraction</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    (<span class="keyword">select</span> player_id, <span class="built_in">min</span>(event_date) <span class="keyword">as</span> login</span><br><span class="line">    <span class="keyword">from</span> activity</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> player_id) p </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> activity a </span><br><span class="line"><span class="keyword">on</span> p.player_id<span class="operator">=</span>a.player_id <span class="keyword">and</span> datediff(a.event_date, p.login)<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>这个avg用的妙</p><p>is not null判断后，有eventdate值的返回1，null的返回0，avg相当于求和后(即符合条件的id个数)除以总id数即所求比例</p></blockquote><h4 id="569-员工薪水中位数"><a href="#569-员工薪水中位数" class="headerlink" title="569. 员工薪水中位数"></a><a href="https://leetcode-cn.com/problems/median-employee-salary/">569. 员工薪水中位数</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Employee</code> 表包含所有员工。<code>Employee</code> 表有三列：员工Id，公司名和薪水。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-----+------------+--------+</span><br><span class="line">|Id   | Company    | Salary |</span><br><span class="line">+-----+------------+--------+</span><br><span class="line">|1    | A          | 2341   |</span><br><span class="line">|2    | A          | 341    |</span><br><span class="line">|3    | A          | 15     |</span><br><span class="line">|4    | A          | 15314  |</span><br><span class="line">|5    | A          | 451    |</span><br><span class="line">|6    | A          | 513    |</span><br><span class="line">|7    | B          | 15     |</span><br><span class="line">|8    | B          | 13     |</span><br><span class="line">|9    | B          | 1154   |</span><br><span class="line">|10   | B          | 1345   |</span><br><span class="line">|11   | B          | 1221   |</span><br><span class="line">|12   | B          | 234    |</span><br><span class="line">|13   | C          | 2345   |</span><br><span class="line">|14   | C          | 2645   |</span><br><span class="line">|15   | C          | 2645   |</span><br><span class="line">|16   | C          | 2652   |</span><br><span class="line">|17   | C          | 65     |</span><br><span class="line">+-----+------------+--------+</span><br></pre></td></tr></table></figure><p>请编写SQL查询来查找每个公司的薪水中位数。挑战点：你是否可以在不使用任何内置的SQL函数的情况下解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----+------------+--------+</span><br><span class="line">|Id   | Company    | Salary |</span><br><span class="line">+-----+------------+--------+</span><br><span class="line">|5    | A          | 451    |</span><br><span class="line">|6    | A          | 513    |</span><br><span class="line">|12   | B          | 234    |</span><br><span class="line">|9    | B          | 1154   |</span><br><span class="line">|14   | C          | 2645   |</span><br><span class="line">+-----+------------+--------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Id,Company,Salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> Id,Company,Salary,</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> Company <span class="keyword">order</span> <span class="keyword">by</span> Salary) rk,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> Company) cnt</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="keyword">IN</span> (<span class="built_in">FLOOR</span>((cnt <span class="operator">+</span> <span class="number">1</span>)<span class="operator">/</span><span class="number">2</span>), <span class="built_in">FLOOR</span>((cnt <span class="operator">+</span> <span class="number">2</span>)<span class="operator">/</span><span class="number">2</span>))</span><br></pre></td></tr></table></figure><blockquote><p>中位数：</p><p>+1向下取整 +2 向下取整数</p></blockquote><h4 id="570-至少有5名直接下属的经理"><a href="#570-至少有5名直接下属的经理" class="headerlink" title="570. 至少有5名直接下属的经理"></a><a href="https://leetcode-cn.com/problems/managers-with-at-least-5-direct-reports/">570. 至少有5名直接下属的经理</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Employee</code> 表包含所有员工和他们的经理。每个员工都有一个 Id，并且还有一列是经理的 Id。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+-----------+----------+</span><br><span class="line">|Id    |Name   |Department |ManagerId |</span><br><span class="line">+------+----------+-----------+----------+</span><br><span class="line">|101   |John   |A       |null      |</span><br><span class="line">|102   |Dan   |A       |101       |</span><br><span class="line">|103   |James   |A       |101       |</span><br><span class="line">|104   |Amy   |A       |101       |</span><br><span class="line">|105   |Anne   |A       |101       |</span><br><span class="line">|106   |Ron   |B       |101       |</span><br><span class="line">+------+----------+-----------+----------+</span><br></pre></td></tr></table></figure><p>给定 <code>Employee</code> 表，请编写一个SQL查询来查找至少有5名直接下属的经理。对于上表，您的SQL查询应该返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">| Name  |</span><br><span class="line">+-------+</span><br><span class="line">| John  |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>没有人是自己的下属。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">where</span> Id <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> ManagerId</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ManagerId</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="571-给定数字的频率查询中位数"><a href="#571-给定数字的频率查询中位数" class="headerlink" title="571. 给定数字的频率查询中位数"></a><a href="https://leetcode-cn.com/problems/find-median-given-frequency-of-numbers/">571. 给定数字的频率查询中位数</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Numbers</code> 表保存数字的值及其频率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------+-------------+</span><br><span class="line">|  Number  |  Frequency  |</span><br><span class="line">+----------+-------------|</span><br><span class="line">|  0       |  7          |</span><br><span class="line">|  1       |  1          |</span><br><span class="line">|  2       |  3          |</span><br><span class="line">|  3       |  1          |</span><br><span class="line">+----------+-------------+</span><br></pre></td></tr></table></figure><p>在此表中，数字为 <code>0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3</code>，所以中位数是 <code>(0 + 0) / 2 = 0</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| median |</span><br><span class="line">+--------|</span><br><span class="line">| 0.0000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><p>请编写一个查询来查找所有数字的中位数并将结果命名为 <code>median</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="built_in">avg</span>(<span class="built_in">cast</span>(number <span class="keyword">as</span> <span class="type">float</span>)) median</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> </span><br><span class="line">            Number,</span><br><span class="line">            Frequency,</span><br><span class="line">            <span class="built_in">sum</span>(Frequency) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Number) <span class="operator">-</span> Frequency prev_sum,</span><br><span class="line">            <span class="built_in">sum</span>(Frequency) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Number) curr_sum</span><br><span class="line">        <span class="keyword">from</span> Numbers</span><br><span class="line">    ) t1,</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> </span><br><span class="line">            <span class="built_in">sum</span>(Frequency) total_sum</span><br><span class="line">        <span class="keyword">from</span> Numbers</span><br><span class="line">    ) t2</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    t1.prev_sum <span class="operator">&lt;=</span> (<span class="built_in">cast</span>(t2.total_sum <span class="keyword">as</span> <span class="type">float</span>) <span class="operator">/</span> <span class="number">2</span>) <span class="keyword">and</span> </span><br><span class="line">    t1.curr_sum <span class="operator">&gt;=</span> (<span class="built_in">cast</span>(t2.total_sum <span class="keyword">as</span> <span class="type">float</span>) <span class="operator">/</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>如果 n1.Number 为中位数，n1.Number（包含本身）前累计的数字应大于等于总数/2 同时n1.Number（不包含本身）前累计数字应小于等于总数/2</p><p>例如：0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3 共12个数</p><p> 中位数0（包含本身）前累计的数字 7 &gt;=6  0（不包含本身）前累计数字 0 &lt;=6<br>例如：0，0，0，3，3，3 共6个数</p><p> 中位数0（包含本身）前累计的数字 3 &gt;=3  0（不包含本身）前累计数字 0 &lt;=3</p><p> 中位数3（包含本身）前累计的数字 6 &gt;=3  3（不包含本身）前累计数字 3 &lt;=3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="built_in">AVG</span>(Number)median </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> n1.Number <span class="keyword">FROM</span> Numbers n1 <span class="keyword">JOIN</span> Numbers n2 <span class="keyword">ON</span> n1.Number<span class="operator">&gt;=</span>n2.Number </span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line"> n1.Number </span><br><span class="line"> <span class="keyword">HAVING</span> </span><br><span class="line"> <span class="built_in">SUM</span>(n2.Frequency)<span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Frequency) <span class="keyword">FROM</span> Numbers)<span class="operator">/</span><span class="number">2</span> </span><br><span class="line"> <span class="keyword">AND</span> </span><br><span class="line"> <span class="built_in">SUM</span>(n2.Frequency)<span class="operator">-</span><span class="built_in">AVG</span>(n1.Frequency)<span class="operator">&lt;=</span>(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Frequency) <span class="keyword">FROM</span> Numbers)<span class="operator">/</span><span class="number">2</span></span><br><span class="line">)s</span><br></pre></td></tr></table></figure><h4 id="574-当选者"><a href="#574-当选者" class="headerlink" title="574. 当选者"></a><a href="https://leetcode-cn.com/problems/winning-candidate/">574. 当选者</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Candidate</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----+---------+</span><br><span class="line">| id  | Name    |</span><br><span class="line">+-----+---------+</span><br><span class="line">| 1   | A       |</span><br><span class="line">| 2   | B       |</span><br><span class="line">| 3   | C       |</span><br><span class="line">| 4   | D       |</span><br><span class="line">| 5   | E       |</span><br><span class="line">+-----+---------+  </span><br></pre></td></tr></table></figure><p>表: <code>Vote</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----+--------------+</span><br><span class="line">| id  | CandidateId  |</span><br><span class="line">+-----+--------------+</span><br><span class="line">| 1   |     2        |</span><br><span class="line">| 2   |     4        |</span><br><span class="line">| 3   |     3        |</span><br><span class="line">| 4   |     2        |</span><br><span class="line">| 5   |     5        |</span><br><span class="line">+-----+--------------+</span><br><span class="line">id 是自动递增的主键，</span><br><span class="line">CandidateId 是 Candidate 表中的 id.</span><br></pre></td></tr></table></figure><p>请编写 sql 语句来找到当选者的名字，上面的例子将返回当选者 <code>B</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| Name |</span><br><span class="line">+------+</span><br><span class="line">| B    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p>用了order by 全局排序 不够好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    Name</span><br><span class="line"><span class="keyword">from</span> Candidate c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Vote v</span><br><span class="line">    <span class="keyword">on</span> c.id <span class="operator">=</span> v.CandidateId</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> Name</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">1</span>   </span><br></pre></td></tr></table></figure><p>先过滤再  效率高很多</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name</span><br><span class="line"><span class="keyword">from</span> Candidate</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> CandidateId</span><br><span class="line">    <span class="keyword">from</span>    </span><br><span class="line">        (</span><br><span class="line">        <span class="keyword">select</span> CandidateId, </span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> CandidateId ) cnt</span><br><span class="line">        <span class="keyword">from</span> Vote</span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span> </span><br><span class="line">        limit <span class="number">1</span></span><br><span class="line">        )t1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="577-员工奖金"><a href="#577-员工奖金" class="headerlink" title="577. 员工奖金"></a><a href="https://leetcode-cn.com/problems/employee-bonus/">577. 员工奖金</a></h4><p>难度简单</p><p>SQL架构</p><p>选出所有 bonus &lt; 1000 的员工的 name 及其 bonus。</p><p><code>Employee</code> 表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">| empId |  name  | supervisor| salary |</span><br><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">|   1   | John   |  3        | 1000   |</span><br><span class="line">|   2   | Dan    |  3        | 2000   |</span><br><span class="line">|   3   | Brad   |  null     | 4000   |</span><br><span class="line">|   4   | Thomas |  3        | 4000   |</span><br><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">empId 是这张表单的主关键字</span><br></pre></td></tr></table></figure><p><code>Bonus</code> 表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+</span><br><span class="line">| empId | bonus |</span><br><span class="line">+-------+-------+</span><br><span class="line">| 2     | 500   |</span><br><span class="line">| 4     | 2000  |</span><br><span class="line">+-------+-------+</span><br><span class="line">empId 是这张表单的主关键字</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+</span><br><span class="line">| name  | bonus |</span><br><span class="line">+-------+-------+</span><br><span class="line">| John  | null  |</span><br><span class="line">| Dan   | 500   |</span><br><span class="line">| Brad  | null  |</span><br><span class="line">+-------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,bonus</span><br><span class="line"><span class="keyword">from</span> Employee e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Bonus b <span class="keyword">on</span>  e.empId<span class="operator">=</span>b.empId</span><br><span class="line"><span class="keyword">where</span> bonus<span class="operator">&lt;</span><span class="number">1000</span> <span class="keyword">or</span> bonus <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="578-查询回答率最高的问题"><a href="#578-查询回答率最高的问题" class="headerlink" title="578. 查询回答率最高的问题"></a><a href="https://leetcode-cn.com/problems/get-highest-answer-rate-question/">578. 查询回答率最高的问题</a></h4><p>难度中等3收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>从 <code>survey_log</code> 表中获得回答率最高的问题，<code>survey_log</code> 表包含这些列<strong>：id</strong>, <strong>action</strong>, <strong>question_id</strong>, <strong>answer_id</strong>, <strong>q_num</strong>, <strong>timestamp</strong>。</p><p>id 表示用户 id；action 有以下几种值：”show”，”answer”，”skip”；当 action 值为 “answer” 时 answer_id 非空，而 action 值为 “show” 或者 “skip” 时 answer_id 为空；q_num 表示当前会话中问题的编号。</p><p>请编写 SQL 查询来找到具有最高回答率的问题。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">+------+-----------+--------------+------------+-----------+------------+</span><br><span class="line">| id   | action    | question_id  | answer_id  | q_num     | timestamp  |</span><br><span class="line">+------+-----------+--------------+------------+-----------+------------+</span><br><span class="line">| 5    | show      | 285          | null       | 1         | 123        |</span><br><span class="line">| 5    | answer    | 285          | 124124     | 1         | 124        |</span><br><span class="line">| 5    | show      | 369          | null       | 2         | 125        |</span><br><span class="line">| 5    | skip      | 369          | null       | 2         | 126        |</span><br><span class="line">+------+-----------+--------------+------------+-----------+------------+</span><br><span class="line">输出：</span><br><span class="line">+-------------+</span><br><span class="line">| survey_log  |</span><br><span class="line">+-------------+</span><br><span class="line">|    285      |</span><br><span class="line">+-------------+</span><br><span class="line">解释：</span><br><span class="line">问题 285 的回答率为 1/1，而问题 369 回答率为 0/1，因此输出 285 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> question_id  survey_log</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">      question_id,</span><br><span class="line">      <span class="built_in">sum</span>(if(action <span class="operator">=</span> <span class="string">&#x27;answer&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">as</span> AnswerCnt,</span><br><span class="line">      <span class="built_in">sum</span>(if(action <span class="operator">=</span> <span class="string">&#x27;show&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">as</span> ShowCnt</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">      survey_log</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> question_id</span><br><span class="line">) <span class="keyword">as</span> tbl</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (AnswerCnt <span class="operator">/</span> ShowCnt) <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>直接不嵌套</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> question_id  survey_log</span><br><span class="line"><span class="keyword">from</span> survey_log</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> question_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(if(action <span class="operator">=</span> <span class="string">&#x27;answer&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="operator">/</span> <span class="built_in">sum</span>(if(action <span class="operator">=</span> <span class="string">&#x27;show&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="579-查询员工的累计薪水"><a href="#579-查询员工的累计薪水" class="headerlink" title="579. 查询员工的累计薪水"></a><a href="https://leetcode-cn.com/problems/find-cumulative-salary-of-an-employee/">579. 查询员工的累计薪水</a></h4><p>难度困难</p><p>SQL架构</p><p><strong>Employee</strong> 表保存了一年内的薪水信息。</p><p>请你编写 SQL 语句，对于每个员工，查询他除最近一个月（即最大月）之外，剩下每个月的近三个月的累计薪水（不足三个月也要计算）。</p><p>结果请按 <code>Id</code> 升序，然后按 <code>Month</code> 降序显示。</p><p><strong>示例：</strong><br><strong>输入：</strong></p><table><thead><tr><th>Id</th><th>Month</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>20</td></tr><tr><td>2</td><td>1</td><td>20</td></tr><tr><td>1</td><td>2</td><td>30</td></tr><tr><td>2</td><td>2</td><td>30</td></tr><tr><td>3</td><td>2</td><td>40</td></tr><tr><td>1</td><td>3</td><td>40</td></tr><tr><td>3</td><td>3</td><td>60</td></tr><tr><td>1</td><td>4</td><td>60</td></tr><tr><td>3</td><td>4</td><td>70</td></tr></tbody></table><p><strong>输出：</strong></p><table><thead><tr><th>Id</th><th>Month</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>90</td></tr><tr><td>1</td><td>2</td><td>50</td></tr><tr><td>1</td><td>1</td><td>20</td></tr><tr><td>2</td><td>1</td><td>20</td></tr><tr><td>3</td><td>3</td><td>100</td></tr><tr><td>3</td><td>2</td><td>40</td></tr></tbody></table><p><strong>解释：</strong></p><p>员工 ‘1’ 除去最近一个月（月份 ‘4’），有三个月的薪水记录：月份 ‘3’ 薪水为 40，月份 ‘2’ 薪水为 30，月份 ‘1’ 薪水为 20。</p><p>所以近 3 个月的薪水累计分别为 (40 + 30 + 20) = 90，(30 + 20) = 50 和 20。</p><table><thead><tr><th>Id</th><th>Month</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>90</td></tr><tr><td>1</td><td>2</td><td>50</td></tr><tr><td>1</td><td>1</td><td>20</td></tr></tbody></table><p>员工 ‘2’ 除去最近的一个月（月份 ‘2’）的话，只有月份 ‘1’ 这一个月的薪水记录。</p><table><thead><tr><th>Id</th><th>Month</th><th>Salary</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>20</td></tr></tbody></table><p>员工 ‘3’ 除去最近一个月（月份 ‘4’）后有两个月，分别为：月份 ‘4’ 薪水为 60 和 月份 ‘2’ 薪水为 40。所以各月的累计情况如下：</p><table><thead><tr><th>Id</th><th>Month</th><th>Salary</th></tr></thead><tbody><tr><td>3</td><td>3</td><td>100</td></tr><tr><td>3</td><td>2</td><td>40</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Id,<span class="keyword">Month</span>,</span><br><span class="line"><span class="built_in">sum</span>(Salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> Id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Month</span> <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span>) Salary</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> Id,<span class="keyword">Month</span>,Salary,</span><br><span class="line">    <span class="built_in">lead</span>(<span class="keyword">Month</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> Id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Month</span>) lm</span><br><span class="line">    <span class="keyword">from</span> Employee </span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> lm <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>  Id,<span class="keyword">Month</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h4 id="580-统计各专业学生人数"><a href="#580-统计各专业学生人数" class="headerlink" title="580. 统计各专业学生人数"></a><a href="https://leetcode-cn.com/problems/count-student-number-in-departments/">580. 统计各专业学生人数</a></h4><p>难度中等</p><p>SQL架构</p><p>一所大学有 2 个数据表，分别是 <em><strong>student</strong></em> 和 <em><strong>department</strong></em> ，这两个表保存着每个专业的学生数据和院系数据。</p><p>写一个查询语句，查询 <em><strong>department</strong></em> 表中每个专业的学生人数 （即使没有学生的专业也需列出）。</p><p>将你的查询结果按照学生人数降序排列。 如果有两个或两个以上专业有相同的学生数目，将这些部门按照部门名字的字典序从小到大排列。</p><p>*<strong>student*</strong> 表格如下：</p><table><thead><tr><th>Column Name</th><th>Type</th></tr></thead><tbody><tr><td>student_id</td><td>Integer</td></tr><tr><td>student_name</td><td>String</td></tr><tr><td>gender</td><td>Character</td></tr><tr><td>dept_id</td><td>Integer</td></tr></tbody></table><p>其中， student_id 是学生的学号， student_name 是学生的姓名， gender 是学生的性别， dept_id 是学生所属专业的专业编号。</p><p>*<strong>department*</strong> 表格如下：</p><table><thead><tr><th>Column Name</th><th>Type</th></tr></thead><tbody><tr><td>dept_id</td><td>Integer</td></tr><tr><td>dept_name</td><td>String</td></tr></tbody></table><p>dept_id 是专业编号， dept_name 是专业名字。</p><p>这里是一个示例输入：<br>*<strong>student*</strong> 表格：</p><table><thead><tr><th>student_id</th><th>student_name</th><th>gender</th><th>dept_id</th></tr></thead><tbody><tr><td>1</td><td>Jack</td><td>M</td><td>1</td></tr><tr><td>2</td><td>Jane</td><td>F</td><td>1</td></tr><tr><td>3</td><td>Mark</td><td>M</td><td>2</td></tr></tbody></table><p>*<strong>department*</strong> 表格：</p><table><thead><tr><th>dept_id</th><th>dept_name</th></tr></thead><tbody><tr><td>1</td><td>Engineering</td></tr><tr><td>2</td><td>Science</td></tr><tr><td>3</td><td>Law</td></tr></tbody></table><p>示例输出为：</p><table><thead><tr><th>dept_name</th><th>student_number</th></tr></thead><tbody><tr><td>Engineering</td><td>2</td></tr><tr><td>Science</td><td>1</td></tr><tr><td>Law</td><td>0</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  dept_name ,<span class="built_in">count</span>(student_id) student_number</span><br><span class="line"><span class="keyword">from</span> department d <span class="keyword">left</span> <span class="keyword">join</span> student s</span><br><span class="line"><span class="keyword">on</span> d.dept_id<span class="operator">=</span>s.dept_id </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> student_number <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h4 id="584-寻找用户推荐人"><a href="#584-寻找用户推荐人" class="headerlink" title="584. 寻找用户推荐人"></a><a href="https://leetcode-cn.com/problems/find-customer-referee/">584. 寻找用户推荐人</a></h4><p>难度简单9收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+------+-----------+</span><br><span class="line">| id   | name | referee_id|</span><br><span class="line">+------+------+-----------+</span><br><span class="line">|    1 | Will |      NULL |</span><br><span class="line">|    2 | Jane |      NULL |</span><br><span class="line">|    3 | Alex |         2 |</span><br><span class="line">|    4 | Bill |      NULL |</span><br><span class="line">|    5 | Zack |         1 |</span><br><span class="line">|    6 | Mark |         2 |</span><br><span class="line">+------+------+-----------+</span><br></pre></td></tr></table></figure><p>写一个查询语句，返回一个编号列表，列表中编号的推荐人的编号都 <strong>不是</strong> 2。</p><p>对于上面的示例数据，结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| Will |</span><br><span class="line">| Jane |</span><br><span class="line">| Bill |</span><br><span class="line">| Zack |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> referee_id <span class="operator">!=</span> <span class="number">2</span> <span class="keyword">OR</span> referee_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>MySQL 使用三值逻辑 —— TRUE, FALSE 和 UNKNOWN。任何与 NULL 值进行的比较都会与第三种值 UNKNOWN 做比较。这个“任何值”包括 NULL 本身！这就是为什么 MySQL 提供 IS NULL 和 IS NOT NULL 两种操作来对 NULL 特殊判断。</p><p>因此，在 WHERE 语句中我们需要做一个额外的条件判断 `referee_id IS NULL’。</p></blockquote><h4 id="585-2016年的投资"><a href="#585-2016年的投资" class="headerlink" title="585. 2016年的投资"></a><a href="https://leetcode-cn.com/problems/investments-in-2016/">585. 2016年的投资</a></h4><p>难度中等14收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>写一个查询语句，将 2016 年 (<strong>TIV_2016</strong>) 所有成功投资的金额加起来，保留 2 位小数。</p><p>对于一个投保人，他在 2016 年成功投资的条件是：</p><ol><li>他在 2015 年的投保额 (<strong>TIV_2015</strong>) 至少跟一个其他投保人在 2015 年的投保额相同。</li><li>他所在的城市必须与其他投保人都不同（也就是说维度和经度不能跟其他任何一个投保人完全相同）。</li></ol><p><strong>输入格式:</strong><br>表 *<strong>insurance*</strong> 格式如下：</p><table><thead><tr><th>Column Name</th><th>Type</th></tr></thead><tbody><tr><td>PID</td><td>INTEGER(11)</td></tr><tr><td>TIV_2015</td><td>NUMERIC(15,2)</td></tr><tr><td>TIV_2016</td><td>NUMERIC(15,2)</td></tr><tr><td>LAT</td><td>NUMERIC(5,2)</td></tr><tr><td>LON</td><td>NUMERIC(5,2)</td></tr></tbody></table><p><strong>PID</strong> 字段是投保人的投保编号， <strong>TIV_2015</strong> 是该投保人在2015年的总投保金额， <strong>TIV_2016</strong> 是该投保人在2016年的投保金额， <strong>LAT</strong> 是投保人所在城市的维度， <strong>LON</strong> 是投保人所在城市的经度。</p><p><strong>样例输入</strong></p><table><thead><tr><th>PID</th><th>TIV_2015</th><th>TIV_2016</th><th>LAT</th><th>LON</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>5</td><td>10</td><td>10</td></tr><tr><td>2</td><td>20</td><td>20</td><td>20</td><td>20</td></tr><tr><td>3</td><td>10</td><td>30</td><td>20</td><td>20</td></tr><tr><td>4</td><td>10</td><td>40</td><td>40</td><td>40</td></tr></tbody></table><p><strong>样例输出</strong></p><table><thead><tr><th>TIV_2016</th></tr></thead><tbody><tr><td>45.00</td></tr></tbody></table><p><strong>解释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">就如最后一个投保人，第一个投保人同时满足两个条件：</span><br><span class="line">1. 他在 2015 年的投保金额 TIV_2015 为 &#x27;10&#x27; ，与第三个和第四个投保人在 2015 年的投保金额相同。</span><br><span class="line">2. 他所在城市的经纬度是独一无二的。</span><br><span class="line"></span><br><span class="line">第二个投保人两个条件都不满足。他在 2015 年的投资 TIV_2015 与其他任何投保人都不相同。</span><br><span class="line">且他所在城市的经纬度与第三个投保人相同。基于同样的原因，第三个投保人投资失败。</span><br><span class="line"></span><br><span class="line">所以返回的结果是第一个投保人和最后一个投保人的 TIV_2016 之和，结果是 45 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(TIV_2016) TIV_2016</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> PID,TIV_2016,cnt,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> loc ) lcnt</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> PID,TIV_2016,</span><br><span class="line">        <span class="built_in">count</span>(TIV_2015) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> TIV_2015 ) cnt,</span><br><span class="line">        concat_ws(&quot;,&quot;,LAT,LON) loc</span><br><span class="line">        <span class="keyword">from</span> insurance </span><br><span class="line">    )t1</span><br><span class="line">)t2</span><br><span class="line"><span class="keyword">where</span> lcnt<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> cnt<span class="operator">!=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意去重顺序 不要先对TIV_2015去重  不然 local去重时会丢失数据</p></blockquote><p>优化 窗口</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    ROUND(<span class="built_in">SUM</span>(TIV_2016), <span class="number">2</span>) <span class="keyword">as</span> TIV_2016</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        <span class="operator">*</span>,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> TIV_2015) <span class="keyword">as</span> cnt_1,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> LAT, LON) <span class="keyword">as</span> cnt_2</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        insurance</span><br><span class="line">) a </span><br><span class="line"><span class="keyword">WHERE</span> a.cnt_1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> a.cnt_2 <span class="operator">&lt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="586-订单最多的客户"><a href="#586-订单最多的客户" class="headerlink" title="586. 订单最多的客户"></a><a href="https://leetcode-cn.com/problems/customer-placing-the-largest-number-of-orders/">586. 订单最多的客户</a></h4><p>难度简单</p><p>SQL架构</p><p>在表 <strong>orders</strong> 中找到订单数最多客户对应的 <strong>customer_number</strong> 。</p><p>数据保证订单数最多的顾客恰好只有一位。</p><p>表 *<strong>orders*</strong> 定义如下：</p><table><thead><tr><th>Column</th><th>Type</th></tr></thead><tbody><tr><td>order_number (PK)</td><td>int</td></tr><tr><td>customer_number</td><td>int</td></tr><tr><td>order_date</td><td>date</td></tr><tr><td>required_date</td><td>date</td></tr><tr><td>shipped_date</td><td>date</td></tr><tr><td>status</td><td>char(15)</td></tr><tr><td>comment</td><td>char(200)</td></tr></tbody></table><p><strong>样例输入</strong></p><table><thead><tr><th>order_number</th><th>customer_number</th><th>order_date</th><th>required_date</th><th>shipped_date</th><th>status</th><th>comment</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2017-04-09</td><td>2017-04-13</td><td>2017-04-12</td><td>Closed</td><td></td></tr><tr><td>2</td><td>2</td><td>2017-04-15</td><td>2017-04-20</td><td>2017-04-18</td><td>Closed</td><td></td></tr><tr><td>3</td><td>3</td><td>2017-04-16</td><td>2017-04-25</td><td>2017-04-20</td><td>Closed</td><td></td></tr><tr><td>4</td><td>3</td><td>2017-04-18</td><td>2017-04-28</td><td>2017-04-25</td><td>Closed</td><td></td></tr></tbody></table><p><strong>样例输出</strong></p><table><thead><tr><th>customer_number</th></tr></thead><tbody><tr><td>3</td></tr></tbody></table><p><strong>解释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer_number 为 &#x27;3&#x27; 的顾客有两个订单，比顾客 &#x27;1&#x27; 或者 &#x27;2&#x27; 都要多，因为他们只有一个订单</span><br><span class="line">所以结果是该顾客的 customer_number ，也就是 3 。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong> 如果有多位顾客订单数并列最多，你能找到他们所有的 customer_number 吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customer_number</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer_number </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>如果 数据量很大 order by 不太好</p></blockquote><h4 id="595-大的国家"><a href="#595-大的国家" class="headerlink" title="595. 大的国家"></a><a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a></h4><p>难度简单</p><p>SQL架构</p><p>这里有张 <code>World</code> 表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  name ,population,area  </span><br><span class="line"><span class="keyword">from</span> World</span><br><span class="line"><span class="keyword">where</span> area  <span class="operator">&gt;</span><span class="number">3000000</span> <span class="keyword">or</span> population <span class="operator">&gt;</span><span class="number">25000000</span></span><br></pre></td></tr></table></figure><h4 id="596-超过5名学生的课"><a href="#596-超过5名学生的课" class="headerlink" title="596. 超过5名学生的课"></a><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/">596. 超过5名学生的课</a></h4><p>难度简单</p><p>SQL架构</p><p>有一个<code>courses</code> 表 ，有: <strong>student (学生)</strong> 和 **class (课程)**。</p><p>请列出所有超过或等于5名学生的课。</p><p>例如,表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure><p>应该输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>学生在每个课中不应被重复计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  class </span><br><span class="line"><span class="keyword">from</span> courses</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> class </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> student)<span class="operator">&gt;=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>一个学生可能多次选课。。记得distinct</p></blockquote><h4 id="597-好友申请-I-：总体通过率"><a href="#597-好友申请-I-：总体通过率" class="headerlink" title="597. 好友申请 I ：总体通过率"></a><a href="https://leetcode-cn.com/problems/friend-requests-i-overall-acceptance-rate/">597. 好友申请 I ：总体通过率</a></h4><p>难度简单21收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>在 Facebook 或者 Twitter 这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。现在给如下两个表：</p><p>表： friend_request</p><table><thead><tr><th>sender_id</th><th>send_to_id</th><th>request_date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2016_06-01</td></tr><tr><td>1</td><td>3</td><td>2016_06-01</td></tr><tr><td>1</td><td>4</td><td>2016_06-01</td></tr><tr><td>2</td><td>3</td><td>2016_06-02</td></tr><tr><td>3</td><td>4</td><td>2016-06-09</td></tr></tbody></table><p>表： request_accepted</p><table><thead><tr><th>requester_id</th><th>accepter_id</th><th>accept_date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2016_06-03</td></tr><tr><td>1</td><td>3</td><td>2016-06-08</td></tr><tr><td>2</td><td>3</td><td>2016-06-08</td></tr><tr><td>3</td><td>4</td><td>2016-06-09</td></tr><tr><td>3</td><td>4</td><td>2016-06-10</td></tr></tbody></table><p>写一个查询语句，求出好友申请的通过率，用 2 位小数表示。通过率由接受好友申请的数目除以申请总数。</p><p>对于上面的样例数据，你的查询语句应该返回如下结果。</p><table><thead><tr><th>accept_rate</th></tr></thead><tbody><tr><td>0.80</td></tr></tbody></table><p>注意:</p><p>通过的好友申请不一定都在表 friend_request 中。在这种情况下，你只需要统计总的被通过的申请数（不管它们在不在原来的申请中），并将它除以申请总数，得到通过率<br>一个好友申请发送者有可能会给接受者发几条好友申请，也有可能一个好友申请会被通过好几次。这种情况下，重复的好友申请只统计一次。<br>如果一个好友申请都没有，通过率为 0.00 。</p><p>解释： 总共有 5 个申请，其中 4 个是不重复且被通过的好友申请，所以成功率是 0.80 。</p><p>进阶:</p><p>你能写一个查询语句得到每个月的通过率吗？<br>你能求出每一天的累计通过率吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">round(</span><br><span class="line">    ifnull(</span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> requester_id, accepter_id <span class="keyword">from</span> request_accepted) <span class="keyword">as</span> A)</span><br><span class="line">    <span class="operator">/</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> sender_id, send_to_id <span class="keyword">from</span> friend_request) <span class="keyword">as</span> B),</span><br><span class="line">    <span class="number">0</span>)</span><br><span class="line">, <span class="number">2</span>) <span class="keyword">as</span> accept_rate;</span><br></pre></td></tr></table></figure><h4 id="601-体育馆的人流量"><a href="#601-体育馆的人流量" class="headerlink" title="601. 体育馆的人流量"></a><a href="https://leetcode-cn.com/problems/human-traffic-of-stadium/">601. 体育馆的人流量</a></h4><p>难度困难113收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：<strong>序号</strong> (id)、<strong>日期</strong> (visit_date)、 <strong>人流量</strong> (people)。</p><p>请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。</p><p>例如，表 <code>stadium</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+------------+-----------+</span><br><span class="line">| id   | visit_date | people    |</span><br><span class="line">+------+------------+-----------+</span><br><span class="line">| 1    | 2017-01-01 | 10        |</span><br><span class="line">| 2    | 2017-01-02 | 109       |</span><br><span class="line">| 3    | 2017-01-03 | 150       |</span><br><span class="line">| 4    | 2017-01-04 | 99        |</span><br><span class="line">| 5    | 2017-01-05 | 145       |</span><br><span class="line">| 6    | 2017-01-06 | 1455      |</span><br><span class="line">| 7    | 2017-01-07 | 199       |</span><br><span class="line">| 8    | 2017-01-08 | 188       |</span><br><span class="line">+------+------------+-----------+</span><br></pre></td></tr></table></figure><p>对于上面的示例数据，输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+------------+-----------+</span><br><span class="line">| id   | visit_date | people    |</span><br><span class="line">+------+------------+-----------+</span><br><span class="line">| 5    | 2017-01-05 | 145       |</span><br><span class="line">| 6    | 2017-01-06 | 1455      |</span><br><span class="line">| 7    | 2017-01-07 | 199       |</span><br><span class="line">| 8    | 2017-01-08 | 188       |</span><br><span class="line">+------+------------+-----------+ </span><br></pre></td></tr></table></figure><p><strong>提示：</strong><br>每天只有一行记录，日期随着 id 的增加而增加。</p><p>3表相连(244 ms)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> stadium t1, stadium t2, stadium t3</span><br><span class="line"><span class="keyword">where</span> t1.people <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> t2.people <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> t3.people <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">(</span><br><span class="line">(t1.id <span class="operator">-</span> t2.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t1.id <span class="operator">-</span> t3.id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t3.id <span class="operator">=</span><span class="number">1</span>)  <span class="comment">-- t1, t2, t3</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    (t2.id <span class="operator">-</span> t1.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t3.id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> t1.id <span class="operator">-</span> t3.id <span class="operator">=</span><span class="number">1</span>) <span class="comment">-- t2, t1, t3</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    (t3.id <span class="operator">-</span> t2.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t1.id <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> t3.id <span class="operator">-</span> t1.id <span class="operator">=</span> <span class="number">2</span>) <span class="comment">-- t3, t2, t1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.id</span><br></pre></td></tr></table></figure><p>窗口函数(272 ms)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,visit_date,people <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> id</span><br><span class="line">    ,<span class="built_in">lead</span>(people,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) ld</span><br><span class="line">    ,<span class="built_in">lead</span>(people,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) ld2</span><br><span class="line">    ,visit_date</span><br><span class="line">    ,<span class="built_in">lag</span>(people,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) lg</span><br><span class="line">    ,<span class="built_in">lag</span>(people,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) lg2</span><br><span class="line">    ,people</span><br><span class="line">    <span class="keyword">from</span> stadium</span><br><span class="line">    ) a</span><br><span class="line"><span class="keyword">where</span> (a.ld<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.lg<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.people<span class="operator">&gt;=</span><span class="number">100</span>)</span><br><span class="line"><span class="keyword">or</span> (a.ld<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.ld2<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.people<span class="operator">&gt;=</span><span class="number">100</span>)</span><br><span class="line"><span class="keyword">or</span> (a.lg<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.lg2<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">and</span> a.people<span class="operator">&gt;=</span><span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="602-好友申请-II-：谁有最多的好友"><a href="#602-好友申请-II-：谁有最多的好友" class="headerlink" title="602. 好友申请 II ：谁有最多的好友"></a><a href="https://leetcode-cn.com/problems/friend-requests-ii-who-has-the-most-friends/">602. 好友申请 II ：谁有最多的好友</a></h4><p>难度中等</p><p>SQL架构</p><p>在 Facebook 或者 Twitter 这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。</p><p>表 <code>request_accepted</code> 存储了所有好友申请通过的数据记录，其中， <strong>requester_id</strong> 和 <strong>accepter_id</strong> 都是用户的编号。</p><table><thead><tr><th>requester_id</th><th>accepter_id</th><th>accept_date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2016_06-03</td></tr><tr><td>1</td><td>3</td><td>2016-06-08</td></tr><tr><td>2</td><td>3</td><td>2016-06-08</td></tr><tr><td>3</td><td>4</td><td>2016-06-09</td></tr></tbody></table><p>写一个查询语句，求出谁拥有最多的好友和他拥有的好友数目。对于上面的样例数据，结果为：</p><table><thead><tr><th>id</th><th>num</th></tr></thead><tbody><tr><td>3</td><td>3</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>保证拥有最多好友数目的只有 1 个人。</li><li>好友申请只会被接受一次，所以不会有 <strong>requester_id</strong> 和 <strong>accepter_id</strong> 值都相同的重复记录。</li></ul><p><strong>解释：</strong></p><p>编号为 ‘3’ 的人是编号为 ‘1’，’2’ 和 ‘4’ 的好友，所以他总共有 3 个好友，比其他人都多。</p><p><strong>进阶：</strong></p><p>在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> rid <span class="keyword">as</span> `id`,<span class="built_in">count</span>(aid) <span class="keyword">as</span> `num`</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> R1.requester_id <span class="keyword">as</span> rid,R1.accepter_id <span class="keyword">as</span> aid</span><br><span class="line">    <span class="keyword">from</span> request_accepted <span class="keyword">as</span> R1</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> R2.accepter_id <span class="keyword">as</span> rid,R2.requester_id <span class="keyword">as</span> aid</span><br><span class="line">    <span class="keyword">from</span> request_accepted <span class="keyword">as</span> R2</span><br><span class="line">) <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> rid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="603-连续空余座位"><a href="#603-连续空余座位" class="headerlink" title="603. 连续空余座位"></a><a href="https://leetcode-cn.com/problems/consecutive-available-seats/">603. 连续空余座位</a></h4><p>难度简单</p><p>SQL架构</p><p>几个朋友来到电影院的售票处，准备预约连续空余座位。</p><p>你能利用表 <code>cinema</code> ，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？</p><table><thead><tr><th>seat_id</th><th>free</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>0</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>1</td></tr><tr><td>5</td><td>1</td></tr></tbody></table><p>对于如上样例，你的查询语句应该返回如下结果。</p><table><thead><tr><th>seat_id</th></tr></thead><tbody><tr><td>3</td></tr><tr><td>4</td></tr><tr><td>5</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>seat_id 字段是一个自增的整数，free 字段是布尔类型（’1’ 表示空余， ‘0’ 表示已被占据）。</li><li>连续空余座位的定义是大于等于 2 个连续空余的座位。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> seat_id</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> seat_id,</span><br><span class="line"><span class="built_in">lag</span>(seat_id,<span class="number">1</span>,<span class="number">-99</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> seat_id) ls,</span><br><span class="line"><span class="built_in">lead</span>(seat_id,<span class="number">1</span>,<span class="number">-99</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> seat_id) rs</span><br><span class="line"><span class="keyword">from</span> cinema</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">free</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span>  seat_id<span class="operator">-</span>ls <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> rs<span class="operator">-</span>seat_id <span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="607-销售员"><a href="#607-销售员" class="headerlink" title="607. 销售员"></a><a href="https://leetcode-cn.com/problems/sales-person/">607. 销售员</a></h4><p>难度简单</p><p>SQL架构</p><p><strong>描述</strong></p><p>给定 3 个表： <code>salesperson</code>， <code>company</code>， <code>orders</code>。<br>输出所有表 <code>salesperson</code> 中，没有向公司 ‘RED’ 销售任何东西的销售员。</p><p><strong>示例：</strong><br><strong>输入</strong></p><p>表： <code>salesperson</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------+------+--------+-----------------+-----------+</span><br><span class="line">| sales_id | name | salary | commission_rate | hire_date |</span><br><span class="line">+----------+------+--------+-----------------+-----------+</span><br><span class="line">|   1      | John | 100000 |     6           | 4/1/2006  |</span><br><span class="line">|   2      | Amy  | 120000 |     5           | 5/1/2010  |</span><br><span class="line">|   3      | Mark | 65000  |     12          | 12/25/2008|</span><br><span class="line">|   4      | Pam  | 25000  |     25          | 1/1/2005  |</span><br><span class="line">|   5      | Alex | 50000  |     10          | 2/3/2007  |</span><br><span class="line">+----------+------+--------+-----------------+-----------+</span><br></pre></td></tr></table></figure><p>表 <code>salesperson</code> 存储了所有销售员的信息。每个销售员都有一个销售员编号 <strong>sales_id</strong> 和他的名字 <strong>name</strong> 。</p><p>表： <code>company</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------+--------+------------+</span><br><span class="line">| com_id  |  name  |    city    |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">|   1     |  RED   |   Boston   |</span><br><span class="line">|   2     | ORANGE |   New York |</span><br><span class="line">|   3     | YELLOW |   Boston   |</span><br><span class="line">|   4     | GREEN  |   Austin   |</span><br><span class="line">+---------+--------+------------+</span><br></pre></td></tr></table></figure><p>表 <code>company</code> 存储了所有公司的信息。每个公司都有一个公司编号 <strong>com_id</strong> 和它的名字 <strong>name</strong> 。</p><p>表： <code>orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------+------------+---------+----------+--------+</span><br><span class="line">| order_id | order_date | com_id  | sales_id | amount |</span><br><span class="line">+----------+------------+---------+----------+--------+</span><br><span class="line">| 1        |   1/1/2014 |    3    |    4     | 100000 |</span><br><span class="line">| 2        |   2/1/2014 |    4    |    5     | 5000   |</span><br><span class="line">| 3        |   3/1/2014 |    1    |    1     | 50000  |</span><br><span class="line">| 4        |   4/1/2014 |    1    |    4     | 25000  |</span><br><span class="line">+----------+----------+---------+----------+--------+</span><br></pre></td></tr></table></figure><p>表 <code>orders</code> 存储了所有的销售数据，包括销售员编号 <strong>sales_id</strong> 和公司编号 <strong>com_id</strong> 。</p><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| name | </span><br><span class="line">+------+</span><br><span class="line">| Amy  | </span><br><span class="line">| Mark | </span><br><span class="line">| Alex |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>根据表 <code>orders</code> 中的订单 ‘3’ 和 ‘4’ ，容易看出只有 ‘John’ 和 ‘Pam’ 两个销售员曾经向公司 ‘RED’ 销售过。</p><p>所以我们需要输出表 <code>salesperson</code> 中所有其他人的名字。\</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> salesperson</span><br><span class="line"><span class="keyword">where</span> sales_id <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> sales_id</span><br><span class="line">    <span class="keyword">from</span> orders</span><br><span class="line">    <span class="keyword">where</span> com_id <span class="operator">=</span></span><br><span class="line">            (</span><br><span class="line">            <span class="keyword">select</span> com_id </span><br><span class="line">            <span class="keyword">from</span> company</span><br><span class="line">            <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;RED&#x27;</span></span><br><span class="line">            )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="608-树节点"><a href="#608-树节点" class="headerlink" title="608. 树节点"></a><a href="https://leetcode-cn.com/problems/tree-node/">608. 树节点</a></h4><p>难度中等</p><p>SQL架构</p><p>给定一个表 <code>tree</code>，<strong>id</strong> 是树节点的编号， <strong>p_id</strong> 是它父节点的 <strong>id 。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+------+</span><br><span class="line">| id | p_id |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | null |</span><br><span class="line">| 2  | 1    |</span><br><span class="line">| 3  | 1    |</span><br><span class="line">| 4  | 2    |</span><br><span class="line">| 5  | 2    |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure><p>树中每个节点属于以下三种类型之一：</p><ul><li>叶子：如果这个节点没有任何孩子节点。</li><li>根：如果这个节点是整棵树的根，即没有父节点。</li><li>内部节点：如果这个节点既不是叶子节点也不是根节点。</li></ul><p>写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+------+</span><br><span class="line">| id | Type |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | Root |</span><br><span class="line">| 2  | Inner|</span><br><span class="line">| 3  | Leaf |</span><br><span class="line">| 4  | Leaf |</span><br><span class="line">| 5  | Leaf |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><p>节点 ‘1’ 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 ‘2’ 和 ‘3’ 。</p></li><li><p>节点 ‘2’ 是内部节点，因为它有父节点 ‘1’ ，也有孩子节点 ‘4’ 和 ‘5’ 。</p></li><li><p>节点 ‘3’, ‘4’ 和 ‘5’ 都是叶子节点，因为它们都有父节点同时没有孩子节点。</p></li><li><p>样例中树的形态如下： </p><p>​              1<br>​            /   <br>​          2       3<br>​        /   <br>​     4       5</p></li></ul><p><strong>注意</strong></p><p>如果树中只有一个节点，你只需要输出它的根属性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,</span><br><span class="line">    (<span class="keyword">case</span> <span class="keyword">when</span> p_id <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> &quot;Root&quot;</span><br><span class="line">    <span class="keyword">when</span> id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> ifnull(p_id,<span class="number">0</span>) <span class="keyword">from</span> tree) <span class="keyword">then</span> &quot;Leaf&quot;</span><br><span class="line">    <span class="keyword">else</span> &quot;Inner&quot; <span class="keyword">end</span>)  Type</span><br><span class="line"><span class="keyword">from</span> tree</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="610-判断三角形"><a href="#610-判断三角形" class="headerlink" title="610. 判断三角形"></a><a href="https://leetcode-cn.com/problems/triangle-judgement/">610. 判断三角形</a></h4><p>难度简单</p><p>SQL架构</p><p>一个小学生 Tim 的作业是判断三条线段是否能形成一个三角形。</p><p>然而，这个作业非常繁重，因为有几百组线段需要判断。</p><p>假设表 <code>triangle</code> 保存了所有三条线段的三元组 x, y, z ，你能帮 Tim 写一个查询语句，来判断每个三元组是否可以组成一个三角形吗？</p><table><thead><tr><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>13</td><td>15</td><td>30</td></tr><tr><td>10</td><td>20</td><td>15</td></tr></tbody></table><p>对于如上样例数据，你的查询语句应该返回如下结果：</p><table><thead><tr><th>x</th><th>y</th><th>z</th><th>triangle</th></tr></thead><tbody><tr><td>13</td><td>15</td><td>30</td><td>No</td></tr><tr><td>10</td><td>20</td><td>15</td><td>Yes</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> x,y,z, </span><br><span class="line">if(x<span class="operator">+</span>y<span class="operator">&gt;</span>z <span class="operator">&amp;&amp;</span> x<span class="operator">+</span>z<span class="operator">&gt;</span>y <span class="operator">&amp;&amp;</span> y<span class="operator">+</span>z<span class="operator">&gt;</span>x,<span class="string">&#x27;Yes&#x27;</span>,<span class="string">&#x27;No&#x27;</span>) triangle</span><br><span class="line"><span class="keyword">from</span> triangle</span><br></pre></td></tr></table></figure><h4 id="612-平面上的最近距离"><a href="#612-平面上的最近距离" class="headerlink" title="612. 平面上的最近距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-plane/">612. 平面上的最近距离</a></h4><p>难度中等</p><p>SQL架构</p><p>表 <code>point_2d</code> 保存了所有点（多于 2 个点）的坐标 (x,y) ，这些点在平面上两两不重合。</p><p>写一个查询语句找到两点之间的最近距离，保留 2 位小数。</p><table><thead><tr><th>x</th><th>y</th></tr></thead><tbody><tr><td>-1</td><td>-1</td></tr><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>-2</td></tr></tbody></table><p>最近距离在点 (-1,-1) 和(-1,2) 之间，距离为 1.00 。所以输出应该为： </p><table><thead><tr><th>shortest</th></tr></thead><tbody><tr><td>1.00</td></tr></tbody></table><p><strong>注意：</strong>任意点之间的最远距离小于 10000 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ROUND(<span class="built_in">SQRT</span>(<span class="built_in">MIN</span>((POW(p1.x <span class="operator">-</span> p2.x, <span class="number">2</span>) <span class="operator">+</span> POW(p1.y <span class="operator">-</span> p2.y, <span class="number">2</span>)))), <span class="number">2</span>) <span class="keyword">AS</span> shortest</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    point_2d p1</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    point_2d p2 <span class="keyword">ON</span> p1.x <span class="operator">!=</span> p2.x <span class="keyword">OR</span> p1.y <span class="operator">!=</span> p2.y</span><br></pre></td></tr></table></figure><p>优化 ：减少重复计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ROUND(<span class="built_in">SQRT</span>(<span class="built_in">MIN</span>((POW(p1.x <span class="operator">-</span> p2.x, <span class="number">2</span>) <span class="operator">+</span> POW(p1.y <span class="operator">-</span> p2.y, <span class="number">2</span>)))),<span class="number">2</span>) <span class="keyword">AS</span> shortest</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    point_2d p1</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    point_2d p2 <span class="keyword">ON</span> (p1.x <span class="operator">&lt;=</span> p2.x <span class="keyword">AND</span> p1.y <span class="operator">&lt;</span> p2.y)</span><br><span class="line">        <span class="keyword">OR</span> (p1.x <span class="operator">&lt;=</span> p2.x <span class="keyword">AND</span> p1.y <span class="operator">&gt;</span> p2.y)</span><br><span class="line">        <span class="keyword">OR</span> (p1.x <span class="operator">&lt;</span> p2.x <span class="keyword">AND</span> p1.y <span class="operator">=</span> p2.y)</span><br></pre></td></tr></table></figure><h4 id="613-直线上的最近距离"><a href="#613-直线上的最近距离" class="headerlink" title="613. 直线上的最近距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-line/">613. 直线上的最近距离</a></h4><p>难度简单</p><p>SQL架构</p><p>表 <code>point</code> 保存了一些点在 x 轴上的坐标，这些坐标都是整数。</p><p>写一个查询语句，找到这些点中最近两个点之间的距离。</p><table><thead><tr><th>x</th></tr></thead><tbody><tr><td>-1</td></tr><tr><td>0</td></tr><tr><td>2</td></tr></tbody></table><p>最近距离显然是 ‘1’ ，是点 ‘-1’ 和 ‘0’ 之间的距离。所以输出应该如下：</p><table><thead><tr><th>shortest</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table><p><strong>注意：</strong>每个点都与其他点坐标不同，表 <code>table</code> 不会有重复坐标出现。</p><p><strong>进阶：</strong>如果这些点在 x 轴上从左到右都有一个编号，输出结果时需要输出最近点对的编号呢？</p><p> 开窗方法 178m</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(l<span class="operator">-</span>x) shortest</span><br><span class="line"><span class="keyword">from</span>( </span><br><span class="line"><span class="keyword">select</span> x,<span class="built_in">lead</span>(x,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> x) l</span><br><span class="line"><span class="keyword">from</span> point</span><br><span class="line">)t1</span><br></pre></td></tr></table></figure><p>join方法 268m</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">MIN</span>(<span class="built_in">ABS</span>(p1.x <span class="operator">-</span> p2.x)) <span class="keyword">AS</span> shortest</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    point p1</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    point p2 <span class="keyword">ON</span> p1.x <span class="operator">!=</span> p2.x</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h4 id="614-二级关注者"><a href="#614-二级关注者" class="headerlink" title="614. 二级关注者"></a><a href="https://leetcode-cn.com/problems/second-degree-follower/">614. 二级关注者</a></h4><p>难度中等</p><p>SQL架构</p><p>在 facebook 中，表 <code>follow</code> 会有 2 个字段： <strong>followee</strong>, <strong>follower</strong> ，分别表示被关注者和关注者。</p><p>请写一个 sql 查询语句，对每一个关注者，查询关注他的关注者的数目。</p><p>比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+------------+</span><br><span class="line">| followee    | follower   |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     A       |     B      |</span><br><span class="line">|     B       |     C      |</span><br><span class="line">|     B       |     D      |</span><br><span class="line">|     D       |     E      |</span><br><span class="line">+-------------+------------+</span><br></pre></td></tr></table></figure><p>应该输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------+------------+</span><br><span class="line">| follower    | num        |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     B       |  2         |</span><br><span class="line">|     D       |  1         |</span><br><span class="line">+-------------+------------+</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>B 和 D 都在在 <strong>follower</strong> 字段中出现，作为被关注者，B 被 C 和 D 关注，D 被 E 关注。A 不在 <strong>follower</strong> 字段内，所以A不在输出列表中。</p><p><strong>注意：</strong></p><ul><li>被关注者永远不会被他 / 她自己关注。</li><li>将结果按照字典序返回。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> followee follower,<span class="built_in">count</span>(<span class="keyword">distinct</span> follower) num</span><br><span class="line"><span class="keyword">from</span> follow</span><br><span class="line"><span class="keyword">where</span> followee  <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> follower</span><br><span class="line">    <span class="keyword">from</span> follow</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> follower</span><br><span class="line">)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> followee</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> follower </span><br></pre></td></tr></table></figure><blockquote><p>这里出现了重复关注 ，需要去重</p></blockquote><h4 id="615-平均工资：部门与公司比较"><a href="#615-平均工资：部门与公司比较" class="headerlink" title="615. 平均工资：部门与公司比较"></a><a href="https://leetcode-cn.com/problems/average-salary-departments-vs-company/">615. 平均工资：部门与公司比较</a></h4><p>难度困难</p><p>SQL架构</p><p>给如下两个表，写一个查询语句，求出在每一个工资发放日，每个部门的平均工资与公司的平均工资的比较结果 （高 / 低 / 相同）。</p><p>表： <code>salary</code></p><table><thead><tr><th>id</th><th>employee_id</th><th>amount</th><th>pay_date</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>9000</td><td>2017-03-31</td></tr><tr><td>2</td><td>2</td><td>6000</td><td>2017-03-31</td></tr><tr><td>3</td><td>3</td><td>10000</td><td>2017-03-31</td></tr><tr><td>4</td><td>1</td><td>7000</td><td>2017-02-28</td></tr><tr><td>5</td><td>2</td><td>6000</td><td>2017-02-28</td></tr><tr><td>6</td><td>3</td><td>8000</td><td>2017-02-28</td></tr></tbody></table><p><strong>employee_id</strong> 字段是表 <code>employee</code> 中 <strong>employee_id</strong> 字段的外键。</p><table><thead><tr><th>employee_id</th><th>department_id</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>2</td></tr></tbody></table><p>对于如上样例数据，结果为：</p><table><thead><tr><th>pay_month</th><th>department_id</th><th>comparison</th></tr></thead><tbody><tr><td>2017-03</td><td>1</td><td>higher</td></tr><tr><td>2017-03</td><td>2</td><td>lower</td></tr><tr><td>2017-02</td><td>1</td><td>same</td></tr><tr><td>2017-02</td><td>2</td><td>same</td></tr></tbody></table><p><strong>解释</strong></p><p>在三月，公司的平均工资是 (9000+6000+10000)/3 = 8333.33…</p><p>由于部门 ‘1’ 里只有一个 <strong>employee_id</strong> 为 ‘1’ 的员工，所以部门 ‘1’ 的平均工资就是此人的工资 9000 。因为 9000 &gt; 8333.33 ，所以比较结果是 ‘higher’。</p><p>第二个部门的平均工资为 <strong>employee_id</strong> 为 ‘2’ 和 ‘3’ 两个人的平均工资，为 (6000+10000)/2=8000 。因为 8000 &lt; 8333.33 ，所以比较结果是 ‘lower’ 。</p><p>在二月用同样的公式求平均工资并比较，比较结果为 ‘same’ ，因为部门 ‘1’ 和部门 ‘2’ 的平均工资与公司的平均工资相同，都是 7000 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    pay_month,</span><br><span class="line">    department_id,</span><br><span class="line">     (<span class="keyword">case</span> <span class="keyword">when</span> avgs<span class="operator">&gt;</span>ts <span class="keyword">then</span> <span class="string">&#x27;higher&#x27;</span></span><br><span class="line">            <span class="keyword">when</span> avgs<span class="operator">&lt;</span>ts <span class="keyword">then</span> <span class="string">&#x27;lower&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="string">&#x27;same&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> comparison</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        date_format(pay_date,<span class="string">&#x27;%Y-%m&#x27;</span>)pay_month,</span><br><span class="line">        department_id,</span><br><span class="line">        <span class="built_in">avg</span>(amount) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> date_format(pay_date,<span class="string">&#x27;%Y-%m&#x27;</span>) )ts,</span><br><span class="line">        <span class="built_in">avg</span>(amount) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> date_format(pay_date,<span class="string">&#x27;%Y-%m&#x27;</span>),department_id) avgs</span><br><span class="line">    <span class="keyword">from</span> salary s</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> employee e</span><br><span class="line">    <span class="keyword">on</span> s.employee_id <span class="operator">=</span> e.employee_id</span><br><span class="line">   </span><br><span class="line">)t1</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> pay_month, department_id</span><br></pre></td></tr></table></figure><blockquote><p>也可以用if</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(avgs<span class="operator">&gt;</span>ts,<span class="string">&#x27;higher&#x27;</span>,IF(avgs<span class="operator">=</span>ts,<span class="string">&#x27;same&#x27;</span>,<span class="string">&#x27;lower&#x27;</span>)) <span class="keyword">AS</span> comparison</span><br></pre></td></tr></table></figure><h4 id="618-学生地理信息报告"><a href="#618-学生地理信息报告" class="headerlink" title="618. 学生地理信息报告"></a><a href="https://leetcode-cn.com/problems/students-report-by-geography/">618. 学生地理信息报告</a></h4><p>难度困难</p><p>SQL架构</p><p>一所美国大学有来自亚洲、欧洲和美洲的学生，他们的地理信息存放在如下 <code>student</code> 表中。</p><table><thead><tr><th>name</th><th>continent</th></tr></thead><tbody><tr><td>Jack</td><td>America</td></tr><tr><td>Pascal</td><td>Europe</td></tr><tr><td>Xi</td><td>Asia</td></tr><tr><td>Jane</td><td>America</td></tr></tbody></table><p>写一个查询语句实现对大洲（continent）列的 <a href="https://zh.wikipedia.org/wiki/%E9%80%8F%E8%A7%86%E8%A1%A8">透视表</a> 操作，使得每个学生按照姓名的字母顺序依次排列在对应的大洲下面。输出的标题应依次为美洲（America）、亚洲（Asia）和欧洲（Europe）。数据保证来自美洲的学生不少于来自亚洲或者欧洲的学生。</p><p>对于样例输入，它的对应输出是：</p><table><thead><tr><th>America</th><th>Asia</th><th>Europe</th></tr></thead><tbody><tr><td>Jack</td><td>Xi</td><td>Pascal</td></tr><tr><td>Jane</td><td></td><td></td></tr></tbody></table><p><strong>进阶：</strong>如果不能确定哪个大洲的学生数最多，你可以写出一个查询去生成上述学生报告吗？</p><p>开窗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="built_in">max</span>(if(continent<span class="operator">=</span><span class="string">&#x27;America&#x27;</span>,name,<span class="keyword">null</span>)) America,</span><br><span class="line"><span class="built_in">max</span>(if(continent<span class="operator">=</span><span class="string">&#x27;Asia&#x27;</span>,name,<span class="keyword">null</span>)) Asia,</span><br><span class="line"><span class="built_in">max</span>(if(continent<span class="operator">=</span><span class="string">&#x27;Europe&#x27;</span>,name,<span class="keyword">null</span>)) Europe</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    (<span class="keyword">select</span> <span class="operator">*</span>, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> continent <span class="keyword">order</span> <span class="keyword">by</span> name) rk</span><br><span class="line">    <span class="keyword">from</span> student) t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> rk</span><br></pre></td></tr></table></figure><p>变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    America, Asia, Europe</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="variable">@as</span>:<span class="operator">=</span><span class="number">0</span>, <span class="variable">@am</span>:<span class="operator">=</span><span class="number">0</span>, <span class="variable">@eu</span>:<span class="operator">=</span><span class="number">0</span>) t,</span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        <span class="variable">@as</span>:<span class="operator">=</span><span class="variable">@as</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> asid, name <span class="keyword">AS</span> Asia</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        student</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        continent <span class="operator">=</span> <span class="string">&#x27;Asia&#x27;</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> Asia) <span class="keyword">AS</span> t1</span><br><span class="line">        <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        <span class="variable">@am</span>:<span class="operator">=</span><span class="variable">@am</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> amid, name <span class="keyword">AS</span> America</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        student</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        continent <span class="operator">=</span> <span class="string">&#x27;America&#x27;</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> America) <span class="keyword">AS</span> t2 <span class="keyword">ON</span> asid <span class="operator">=</span> amid</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        <span class="variable">@eu</span>:<span class="operator">=</span><span class="variable">@eu</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> euid, name <span class="keyword">AS</span> Europe</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        student</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        continent <span class="operator">=</span> <span class="string">&#x27;Europe&#x27;</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> Europe) <span class="keyword">AS</span> t3 <span class="keyword">ON</span> amid <span class="operator">=</span> euid</span><br></pre></td></tr></table></figure><blockquote><p>官方给出的。。同下方开窗</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> America,Asia,Europe </span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> name) <span class="keyword">as</span> rn,name <span class="keyword">as</span> America <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> continent<span class="operator">=</span><span class="string">&#x27;America&#x27;</span></span><br><span class="line">) a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> name) <span class="keyword">as</span> rn,name <span class="keyword">as</span> Asia <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> continent<span class="operator">=</span><span class="string">&#x27;Asia&#x27;</span></span><br><span class="line">) b <span class="keyword">on</span> a.rn<span class="operator">=</span>b.rn</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> name) <span class="keyword">as</span> rn,name <span class="keyword">as</span> Europe <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> continent<span class="operator">=</span><span class="string">&#x27;Europe&#x27;</span></span><br><span class="line">) c <span class="keyword">on</span> a.rn<span class="operator">=</span>c.rn</span><br></pre></td></tr></table></figure><h4 id="619-只出现一次的最大数字"><a href="#619-只出现一次的最大数字" class="headerlink" title="619. 只出现一次的最大数字"></a><a href="https://leetcode-cn.com/problems/biggest-single-number/">619. 只出现一次的最大数字</a></h4><p>难度简单</p><p>SQL架构</p><p>表 <code>my_numbers</code> 的 <strong>num</strong> 字段包含很多数字，其中包括很多重复的数字。</p><p>你能写一个 SQL 查询语句，找到只出现过一次的数字中，最大的一个数字吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---+</span><br><span class="line">|num|</span><br><span class="line">+---+</span><br><span class="line">| 8 |</span><br><span class="line">| 8 |</span><br><span class="line">| 3 |</span><br><span class="line">| 3 |</span><br><span class="line">| 1 |</span><br><span class="line">| 4 |</span><br><span class="line">| 5 |</span><br><span class="line">| 6 | </span><br></pre></td></tr></table></figure><p>对于上面给出的样例数据，你的查询语句应该返回如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+---+</span><br><span class="line">|num|</span><br><span class="line">+---+</span><br><span class="line">| 6 |</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>如果没有只出现一次的数字，输出 <strong>null</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">MAX</span>(num) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        num</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        my_numbers</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> num</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(num) <span class="operator">=</span> <span class="number">1</span>) t1</span><br></pre></td></tr></table></figure><h4 id="620-有趣的电影"><a href="#620-有趣的电影" class="headerlink" title="620. 有趣的电影"></a><a href="https://leetcode-cn.com/problems/not-boring-movies/">620. 有趣的电影</a></h4><p>难度简单86收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p><p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为<strong>非</strong> <code>boring</code> (不无聊) 的并且 <strong>id 为奇数</strong> 的影片，结果请按等级 <code>rating</code> 排列。</p><p>例如，下表 <code>cinema</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><p>对于上面的例子，则正确的输出是为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  id,movie,description,rating </span><br><span class="line"><span class="keyword">from</span> cinema</span><br><span class="line"><span class="keyword">where</span> id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> description <span class="operator">!=</span><span class="string">&#x27;boring&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">desc</span>,id,movie,description</span><br></pre></td></tr></table></figure><h4 id="626-换座位"><a href="#626-换座位" class="headerlink" title="626. 换座位"></a><a href="https://leetcode-cn.com/problems/exchange-seats/">626. 换座位</a></h4><p>难度中等</p><p>SQL架构</p><p>小美是一所中学的信息科技老师，她有一张 <code>seat</code> 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 <strong>id</strong> 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ </p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p>假如数据输入的是上表，则输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><p>开窗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">0</span> <span class="keyword">then</span> f</span><br><span class="line">      <span class="keyword">when</span> id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">1</span> <span class="operator">&amp;&amp;</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> b</span><br><span class="line">      <span class="keyword">else</span> student <span class="keyword">end</span>) student</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> id,student,</span><br><span class="line">    <span class="built_in">lag</span>(student,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) f,</span><br><span class="line">    <span class="built_in">lead</span>(student,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id) b</span><br><span class="line">    <span class="keyword">from</span> seat</span><br><span class="line">)t1</span><br></pre></td></tr></table></figure><p>非嵌套</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    if(id<span class="operator">%</span><span class="number">2</span><span class="operator">=</span><span class="number">0</span>,</span><br><span class="line">        id<span class="number">-1</span>,</span><br><span class="line">        if(id<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> id) <span class="keyword">from</span> seat),</span><br><span class="line">            id,</span><br><span class="line">            id<span class="operator">+</span><span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">as</span> id,student </span><br><span class="line"><span class="keyword">from</span> seat </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure><p>用异或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.id,a.student <span class="keyword">from</span> </span><br><span class="line">seat <span class="keyword">as</span> a,seat <span class="keyword">as</span> b,(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt <span class="keyword">from</span> seat) <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">where</span> b.id<span class="operator">=</span><span class="number">1</span><span class="operator">^</span>(a.id<span class="number">-1</span>)<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="comment">-- where a.id=1^(b.id-1)+1; 也可以这样写，更容易理解</span></span><br><span class="line"> <span class="operator">||</span> (c.cnt<span class="operator">%</span><span class="number">2</span> <span class="operator">&amp;&amp;</span> b.id<span class="operator">=</span>c.cnt <span class="operator">&amp;&amp;</span> a.id<span class="operator">=</span>c.cnt);</span><br></pre></td></tr></table></figure><h4 id="627-交换工资"><a href="#627-交换工资" class="headerlink" title="627. 交换工资"></a><a href="https://leetcode-cn.com/problems/swap-salary/">627. 交换工资</a></h4><p>难度简单</p><p>SQL架构</p><p>给定一个 <code>salary</code> 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。</p><p>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。</p><p><strong>例如：</strong></p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>m</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>f</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>m</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>f</td><td>500</td></tr></tbody></table><p>运行你所编写的更新语句之后，将会得到以下表:</p><table><thead><tr><th>id</th><th>name</th><th>sex</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>f</td><td>2500</td></tr><tr><td>2</td><td>B</td><td>m</td><td>1500</td></tr><tr><td>3</td><td>C</td><td>f</td><td>5500</td></tr><tr><td>4</td><td>D</td><td>m</td><td>500</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UPDATE salary</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    sex <span class="operator">=</span> <span class="keyword">CASE</span> sex</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;f&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;m&#x27;</span></span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Update 和set的使用</p></blockquote><h4 id="1045-买下所有产品的客户"><a href="#1045-买下所有产品的客户" class="headerlink" title="1045. 买下所有产品的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-bought-all-products/">1045. 买下所有产品的客户</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Customer</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| customer_id | int     |</span><br><span class="line">| product_key | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">product_key 是 Customer 表的外键。</span><br></pre></td></tr></table></figure><p><code>Product</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| product_key | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">product_key 是这张表的主键。</span><br></pre></td></tr></table></figure><p>写一条 SQL 查询语句，从 <code>Customer</code> 表中查询购买了 <code>Product</code> 表中所有产品的客户的 id。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Customer 表：</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| customer_id | product_key |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 5           |</span><br><span class="line">| 2           | 6           |</span><br><span class="line">| 3           | 5           |</span><br><span class="line">| 3           | 6           |</span><br><span class="line">| 1           | 6           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+-------------+</span><br><span class="line">| product_key |</span><br><span class="line">+-------------+</span><br><span class="line">| 5           |</span><br><span class="line">| 6           |</span><br><span class="line">+-------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+</span><br><span class="line">| customer_id |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">| 3           |</span><br><span class="line">+-------------+</span><br><span class="line">购买了所有产品（5 和 6）的客户的 id 是 1 和 3 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customer_id</span><br><span class="line"><span class="keyword">from</span> Customer</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> product_key)<span class="operator">=</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) cnt</span><br><span class="line"><span class="keyword">from</span> Product)</span><br></pre></td></tr></table></figure><h4 id="1050-合作过至少三次的演员和导演"><a href="#1050-合作过至少三次的演员和导演" class="headerlink" title="1050. 合作过至少三次的演员和导演"></a><a href="https://leetcode-cn.com/problems/actors-and-directors-who-cooperated-at-least-three-times/">1050. 合作过至少三次的演员和导演</a></h4><p>难度简单</p><p>SQL架构</p><p><code>ActorDirector</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| actor_id    | int     |</span><br><span class="line">| director_id | int     |</span><br><span class="line">| timestamp   | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">timestamp 是这张表的主键.</span><br></pre></td></tr></table></figure><p>写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对 <code>(actor_id, director_id)</code></p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ActorDirector 表：</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line">| actor_id    | director_id | timestamp   |</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line">| 1           | 1           | 0           |</span><br><span class="line">| 1           | 1           | 1           |</span><br><span class="line">| 1           | 1           | 2           |</span><br><span class="line">| 1           | 2           | 3           |</span><br><span class="line">| 1           | 2           | 4           |</span><br><span class="line">| 2           | 1           | 5           |</span><br><span class="line">| 2           | 1           | 6           |</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| actor_id    | director_id |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 1           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id,director_id</span><br><span class="line"><span class="keyword">from</span> ActorDirector</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> actor_id,director_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="1068-产品销售分析-I"><a href="#1068-产品销售分析-I" class="headerlink" title="1068. 产品销售分析 I"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-i/">1068. 产品销售分析 I</a></h4><p>难度简单</p><p>SQL架构</p><p>销售表 <code>Sales</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">(sale_id, year) 是销售表 Sales 的主键.</span><br><span class="line">product_id 是产品表 Product 的外键.</span><br><span class="line">注意: price 表示每单位价格</span><br></pre></td></tr></table></figure><p>产品表 <code>Product</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是表的主键.</span><br></pre></td></tr></table></figure><p>写一条SQL 查询语句获取产品表 <code>Product</code> 中所有的 <strong>产品名称 product name</strong> 以及 该产品在 <code>Sales</code> 表中相对应的 <strong>上市年份 year</strong> 和 <strong>价格 price</strong>。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| product_name | year  | price |</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| Nokia        | 2008  | 5000  |</span><br><span class="line">| Nokia        | 2009  | 5000  |</span><br><span class="line">| Apple        | 2011  | 9000  |</span><br><span class="line">+--------------+-------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_name,<span class="keyword">year</span>,price</span><br><span class="line"><span class="keyword">from</span> Sales s <span class="keyword">left</span> <span class="keyword">join</span> Product p</span><br><span class="line"><span class="keyword">on</span> s.product_id  <span class="operator">=</span> p.product_id </span><br></pre></td></tr></table></figure><h4 id="1069-产品销售分析-II"><a href="#1069-产品销售分析-II" class="headerlink" title="1069. 产品销售分析 II"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-ii/">1069. 产品销售分析 II</a></h4><p>难度简单</p><p>SQL架构</p><p>销售表：<code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">sale_id 是这个表的主键。</span><br><span class="line">product_id 是 Product 表的外键。</span><br><span class="line">请注意价格是每单位的。</span><br></pre></td></tr></table></figure><p>产品表：<code>Product</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，按产品 id <code>product_id</code> 来统计每个产品的销售总量。</p><p>查询结果格式如下面例子所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| product_id   | total_quantity |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| 100          | 22             |</span><br><span class="line">| 200          | 15             |</span><br><span class="line">+--------------+----------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.product_id,<span class="built_in">sum</span>(quantity) total_quantity</span><br><span class="line"><span class="keyword">from</span> Sales s <span class="keyword">left</span> <span class="keyword">join</span> Product p</span><br><span class="line"><span class="keyword">on</span> s.product_id  <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.product_id</span><br></pre></td></tr></table></figure><h4 id="1070-产品销售分析-III"><a href="#1070-产品销售分析-III" class="headerlink" title="1070. 产品销售分析 III"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-iii/">1070. 产品销售分析 III</a></h4><p>难度中等</p><p>SQL架构</p><p>销售表 <code>Sales</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">sale_id 是此表的主键。</span><br><span class="line">product_id 是产品表的外键。</span><br><span class="line">请注意，价格是按每单位计的。</span><br></pre></td></tr></table></figure><p>产品表 <code>Product</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是此表的主键。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，选出每个销售产品的 <strong>第一年</strong> 的 <strong>产品 id</strong>、<strong>年份</strong>、<strong>数量</strong> 和 <strong>价格</strong>。</p><p>查询结果格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sales table:</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product table:</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+------------+----------+-------+</span><br><span class="line">| product_id | first_year | quantity | price |</span><br><span class="line">+------------+------------+----------+-------+ </span><br><span class="line">| 100        | 2008       | 10       | 5000  |</span><br><span class="line">| 200        | 2011       | 15       | 9000  |</span><br><span class="line">+------------+------------+----------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id,<span class="keyword">year</span> first_year,quantity,price</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> s.product_id,<span class="keyword">year</span>,quantity,price,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> product_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">year</span>) rk</span><br><span class="line"><span class="keyword">from</span> Sales s <span class="keyword">left</span> <span class="keyword">join</span> Product p</span><br><span class="line"><span class="keyword">on</span> s.product_id  <span class="operator">=</span> p.product_id</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1075-项目员工-I"><a href="#1075-项目员工-I" class="headerlink" title="1075. 项目员工 I"></a><a href="https://leetcode-cn.com/problems/project-employees-i/">1075. 项目员工 I</a></h4><p>难度简单</p><p>SQL架构</p><p>项目表 <code>Project</code>： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| project_id  | int     |</span><br><span class="line">| employee_id | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">主键为 (project_id, employee_id)。</span><br><span class="line">employee_id 是员工表 Employee 表的外键。</span><br></pre></td></tr></table></figure><p>员工表 <code>Employee</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| employee_id      | int     |</span><br><span class="line">| name             | varchar |</span><br><span class="line">| experience_years | int     |</span><br><span class="line">+------------------+---------+</span><br><span class="line">主键是 employee_id。</span><br></pre></td></tr></table></figure><p>请写一个 SQL 语句，查询每一个项目中员工的 <strong>平均</strong> 工作年限，<strong>精确到小数点后两位</strong>。</p><p>查询结果的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Project 表：</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| project_id  | employee_id |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 1           |</span><br><span class="line">| 1           | 2           |</span><br><span class="line">| 1           | 3           |</span><br><span class="line">| 2           | 1           |</span><br><span class="line">| 2           | 4           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Employee 表：</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| employee_id | name   | experience_years |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| 1           | Khaled | 3                |</span><br><span class="line">| 2           | Ali    | 2                |</span><br><span class="line">| 3           | John   | 1                |</span><br><span class="line">| 4           | Doe    | 2                |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| project_id  | average_years |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 1           | 2.00          |</span><br><span class="line">| 2           | 2.50          |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">第一个项目中，员工的平均工作年限是 (3 + 2 + 1) / 3 = 2.00；第二个项目中，员工的平均工作年限是 (3 + 2) / 2 = 2.50</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> project_id,round(<span class="built_in">avg</span>(experience_years),<span class="number">2</span>) average_years</span><br><span class="line"><span class="keyword">from</span> Project p <span class="keyword">join</span> Employee e</span><br><span class="line"><span class="keyword">on</span> p.employee_id<span class="operator">=</span>e.employee_id </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> project_id</span><br></pre></td></tr></table></figure><h4 id="1076-项目员工II"><a href="#1076-项目员工II" class="headerlink" title="1076. 项目员工II"></a><a href="https://leetcode-cn.com/problems/project-employees-ii/">1076. 项目员工II</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Project</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| project_id  | int     |</span><br><span class="line">| employee_id | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">主键为 (project_id, employee_id)。</span><br><span class="line">employee_id 是员工表 Employee 表的外键。</span><br></pre></td></tr></table></figure><p>Table: <code>Employee</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| employee_id      | int     |</span><br><span class="line">| name             | varchar |</span><br><span class="line">| experience_years | int     |</span><br><span class="line">+------------------+---------+</span><br><span class="line">主键是 employee_id。</span><br></pre></td></tr></table></figure><p>编写一个SQL查询，报告所有雇员最多的项目。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Project table:</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| project_id  | employee_id |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 1           |</span><br><span class="line">| 1           | 2           |</span><br><span class="line">| 1           | 3           |</span><br><span class="line">| 2           | 1           |</span><br><span class="line">| 2           | 4           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Employee table:</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| employee_id | name   | experience_years |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| 1           | Khaled | 3                |</span><br><span class="line">| 2           | Ali    | 2                |</span><br><span class="line">| 3           | John   | 1                |</span><br><span class="line">| 4           | Doe    | 2                |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-------------+</span><br><span class="line">| project_id  |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">+-------------+</span><br><span class="line">第一个项目有3名员工，第二个项目有2名员工。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> project_id </span><br><span class="line"><span class="keyword">from</span> Project </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> project_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) `num` <span class="keyword">from</span> Project <span class="keyword">group</span> <span class="keyword">by</span> project_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>开窗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> project_id <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> project_id,<span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(employee_id) <span class="keyword">desc</span>) ranking <span class="keyword">from</span> Project <span class="keyword">group</span> <span class="keyword">by</span> project_id) temp <span class="keyword">where</span> ranking<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1077-项目员工-III"><a href="#1077-项目员工-III" class="headerlink" title="1077. 项目员工 III"></a><a href="https://leetcode-cn.com/problems/project-employees-iii/">1077. 项目员工 III</a></h4><p>难度中等</p><p>SQL架构</p><p>项目表 <code>Project</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| project_id  | int     |</span><br><span class="line">| employee_id | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">(project_id, employee_id) 是这个表的主键</span><br><span class="line">employee_id 是员工表 Employee 的外键</span><br></pre></td></tr></table></figure><p>员工表 <code>Employee</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| employee_id      | int     |</span><br><span class="line">| name             | varchar |</span><br><span class="line">| experience_years | int     |</span><br><span class="line">+------------------+---------+</span><br><span class="line">employee_id 是这个表的主键</span><br></pre></td></tr></table></figure><p>写 一个 SQL 查询语句，报告在每一个项目中经验最丰富的雇员是谁。如果出现经验年数相同的情况，请报告所有具有最大经验年数的员工。</p><p>查询结果格式在以下示例中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Project 表：</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| project_id  | employee_id |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 1           |</span><br><span class="line">| 1           | 2           |</span><br><span class="line">| 1           | 3           |</span><br><span class="line">| 2           | 1           |</span><br><span class="line">| 2           | 4           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Employee 表：</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| employee_id | name   | experience_years |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line">| 1           | Khaled | 3                |</span><br><span class="line">| 2           | Ali    | 2                |</span><br><span class="line">| 3           | John   | 3                |</span><br><span class="line">| 4           | Doe    | 2                |</span><br><span class="line">+-------------+--------+------------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| project_id  | employee_id   |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 1           | 1             |</span><br><span class="line">| 1           | 3             |</span><br><span class="line">| 2           | 1             |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">employee_id 为 1 和 3 的员工在 project_id 为 1 的项目中拥有最丰富的经验。在 project_id 为 2 的项目中，employee_id 为 1 的员工拥有最丰富的经验。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> project_id ,employee_id</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> project_id,e.employee_id,</span><br><span class="line"><span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> project_id <span class="keyword">order</span> <span class="keyword">by</span> experience_years <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Project p <span class="keyword">join</span> Employee e</span><br><span class="line"><span class="keyword">on</span> p.employee_id<span class="operator">=</span>e.employee_id </span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1082-销售分析-I"><a href="#1082-销售分析-I" class="headerlink" title="1082. 销售分析 I "></a><a href="https://leetcode-cn.com/problems/sales-analysis-i/">1082. 销售分析 I </a></h4><p>难度简单22</p><p>SQL架构</p><p>产品表：<code>Product</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">| unit_price   | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键.</span><br></pre></td></tr></table></figure><p>销售表：<code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| seller_id   | int     |</span><br><span class="line">| product_id  | int     |</span><br><span class="line">| buyer_id    | int     |</span><br><span class="line">| sale_date   | date    |</span><br><span class="line">| quantity    | int     |</span><br><span class="line">| price       | int     |</span><br><span class="line">+------ ------+---------+</span><br><span class="line">这个表没有主键，它可以有重复的行.</span><br><span class="line">product_id 是 Product 表的外键.</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，查询总销售额最高的销售者，如果有并列的，就都展示出来。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Product 表：</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| product_id | product_name | unit_price |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| 1          | S8           | 1000       |</span><br><span class="line">| 2          | G4           | 800        |</span><br><span class="line">| 3          | iPhone       | 1400       |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line"></span><br><span class="line">Sales 表：</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| seller_id | product_id | buyer_id | sale_date  | quantity | price |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |</span><br><span class="line">| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |</span><br><span class="line">| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |</span><br><span class="line">| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+</span><br><span class="line">| seller_id   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">| 3           |</span><br><span class="line">+-------------+</span><br><span class="line">Id 为 1 和 3 的销售者，销售总金额都为最高的 2800。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> seller_id</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> seller_id ,<span class="built_in">sum</span>(price) tp,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(price) <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> seller_id</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1083-销售分析-II"><a href="#1083-销售分析-II" class="headerlink" title="1083. 销售分析 II"></a><a href="https://leetcode-cn.com/problems/sales-analysis-ii/">1083. 销售分析 II</a></h4><p>难度简单13</p><p>SQL架构</p><p>Table: <code>Product</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">| unit_price   | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这张表的主键</span><br></pre></td></tr></table></figure><p>Table: <code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| seller_id   | int     |</span><br><span class="line">| product_id  | int     |</span><br><span class="line">| buyer_id    | int     |</span><br><span class="line">| sale_date   | date    |</span><br><span class="line">| quantity    | int     |</span><br><span class="line">| price       | int     |</span><br><span class="line">+------ ------+---------+</span><br><span class="line">这个表没有主键，它可以有重复的行.</span><br><span class="line">product_id 是 Product 表的外键.</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，查询购买了 S8 手机却没有购买 iPhone 的买家。注意这里 S8 和 iPhone 是 Product 表中的产品。</p><p>查询结果格式如下图表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Product table:</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| product_id | product_name | unit_price |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| 1          | S8           | 1000       |</span><br><span class="line">| 2          | G4           | 800        |</span><br><span class="line">| 3          | iPhone       | 1400       |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line"></span><br><span class="line">Sales table:</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| seller_id | product_id | buyer_id | sale_date  | quantity | price |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |</span><br><span class="line">| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |</span><br><span class="line">| 2         | 1          | 3        | 2019-06-02 | 1        | 800   |</span><br><span class="line">| 3         | 3          | 3        | 2019-05-13 | 2        | 2800  |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-------------+</span><br><span class="line">| buyer_id    |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">+-------------+</span><br><span class="line">id 为 1 的买家购买了一部 S8，但是却没有购买 iPhone，而 id 为 3 的买家却同时购买了这 2 部手机。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.buyer_id <span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> s.buyer_id, p.product_name</span><br><span class="line"><span class="keyword">from</span> sales s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">product p</span><br><span class="line"><span class="keyword">on</span> s.product_id<span class="operator">=</span>p.product_id <span class="keyword">and</span> (p.product_name<span class="operator">=</span><span class="string">&#x27;S8&#x27;</span> <span class="keyword">or</span> p.product_name<span class="operator">=</span><span class="string">&#x27;iPhone&#x27;</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.buyer_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> p.product_name) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> t.product_name<span class="operator">=</span><span class="string">&#x27;S8&#x27;</span></span><br></pre></td></tr></table></figure><p>效率低</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.buyer_id </span><br><span class="line"><span class="keyword">from</span> sales <span class="keyword">as</span> s <span class="keyword">left</span> <span class="keyword">join</span> product <span class="keyword">as</span> p </span><br><span class="line"><span class="keyword">on</span> s.product_id<span class="operator">=</span>p.product_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> buyer_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(p.product_name<span class="operator">=</span><span class="string">&#x27;S8&#x27;</span>)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="built_in">sum</span>(p.product_name<span class="operator">=</span><span class="string">&#x27;iPhone&#x27;</span>)<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="1084-销售分析III"><a href="#1084-销售分析III" class="headerlink" title="1084. 销售分析III"></a><a href="https://leetcode-cn.com/problems/sales-analysis-iii/">1084. 销售分析III</a></h4><p>难度简单13</p><p>SQL架构</p><p>Table: <code>Product</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">| unit_price   | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键</span><br></pre></td></tr></table></figure><p>Table: <code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| seller_id   | int     |</span><br><span class="line">| product_id  | int     |</span><br><span class="line">| buyer_id    | int     |</span><br><span class="line">| sale_date   | date    |</span><br><span class="line">| quantity    | int     |</span><br><span class="line">| price       | int     |</span><br><span class="line">+------ ------+---------+</span><br><span class="line">这个表没有主键，它可以有重复的行.</span><br><span class="line">product_id 是 Product 表的外键.</span><br></pre></td></tr></table></figure><p>编写一个SQL查询，报告2019年春季才售出的产品。即<strong>仅</strong>在<strong>2019-01-01</strong>至<strong>2019-03-31</strong>（含）之间出售的商品。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Product table:</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| product_id | product_name | unit_price |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| 1          | S8           | 1000       |</span><br><span class="line">| 2          | G4           | 800        |</span><br><span class="line">| 3          | iPhone       | 1400       |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line"></span><br><span class="line">Sales table:</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| seller_id | product_id | buyer_id | sale_date  | quantity | price |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |</span><br><span class="line">| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |</span><br><span class="line">| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |</span><br><span class="line">| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| product_id  | product_name |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| 1           | S8           |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">id为1的产品仅在2019年春季销售，其他两个产品在之后销售。</span><br></pre></td></tr></table></figure><p>876ms</p><p>正常解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, product_name  </span><br><span class="line"><span class="keyword">from</span> product </span><br><span class="line"><span class="keyword">where</span> product_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> product_id <span class="keyword">from</span> sales </span><br><span class="line"><span class="keyword">where</span> sale_date <span class="operator">&gt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">or</span> sale_date <span class="operator">&lt;</span> <span class="string">&#x27;2019-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure><p>867ms</p><p>sum = count</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, product_name</span><br><span class="line"><span class="keyword">from</span> Sales <span class="keyword">join</span> Product</span><br><span class="line"><span class="keyword">using</span>(product_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(sale_date <span class="keyword">between</span> &quot;2019-01-01&quot; <span class="keyword">and</span> &quot;2019-03-31&quot;) <span class="operator">=</span> <span class="built_in">count</span>(sale_date)</span><br></pre></td></tr></table></figure><p>987ms</p><p>sum 为0 类似于第一种解法，计算了sum效率就低了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.product_id, p.product_name</span><br><span class="line"><span class="keyword">from</span> sales s, product p</span><br><span class="line"><span class="keyword">where</span> s.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.product_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(s.sale_date<span class="operator">&gt;</span> <span class="string">&#x27;2019-03-31&#x27;</span>)<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> <span class="built_in">sum</span>(s.sale_date <span class="operator">&lt;</span> <span class="string">&#x27;2019-01-01&#x27;</span>) <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上一解法sum换成max</p><p>859ms</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.product_id, p.product_name</span><br><span class="line"><span class="keyword">from</span> sales s, product p</span><br><span class="line"><span class="keyword">where</span> s.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.product_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(s.sale_date)<span class="operator">&gt;=</span><span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="built_in">max</span>(s.sale_date) <span class="operator">&lt;=</span> <span class="string">&#x27;2019-03-31&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1097-游戏玩法分析-V"><a href="#1097-游戏玩法分析-V" class="headerlink" title="1097. 游戏玩法分析 V"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-v/">1097. 游戏玩法分析 V</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Activity</code> 活动记录表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">（player_id，event_date）是此表的主键</span><br><span class="line">这张表显示了某些游戏的玩家的活动情况</span><br><span class="line">每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）</span><br></pre></td></tr></table></figure><p>我们将玩家的安装日期定义为该玩家的第一个登录日。</p><p>我们还将某个日期 <code>X</code> 的第 1 天留存时间定义为安装日期为 <code>X</code> 的玩家的数量，他们在 <code>X</code> 之后的一天重新登录，除以安装日期为 <code>X</code> 的玩家的数量，四舍五入到小数点后两位。</p><p>编写一个 SQL 查询，报告每个安装日期、当天安装游戏的玩家数量和第一天的留存时间。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Activity 表：</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| 1         | 2         | 2016-03-01 | 5            |</span><br><span class="line">| 1         | 2         | 2016-03-02 | 6            |</span><br><span class="line">| 2         | 3         | 2017-06-25 | 1            |</span><br><span class="line">| 3         | 1         | 2016-03-01 | 0            |</span><br><span class="line">| 3         | 4         | 2016-07-03 | 5            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+----------+----------------+</span><br><span class="line">| install_dt | installs | Day1_retention |</span><br><span class="line">+------------+----------+----------------+</span><br><span class="line">| 2016-03-01 | 2        | 0.50           |</span><br><span class="line">| 2017-06-25 | 1        | 0.00           |</span><br><span class="line">+------------+----------+----------------+</span><br><span class="line">玩家 1 和 3 在 2016-03-01 安装了游戏，但只有玩家 1 在 2016-03-02 重新登录，所以 2016-03-01 的第一天留存时间是 1/2=0.50</span><br><span class="line">玩家 2 在 2017-06-25 安装了游戏，但在 2017-06-26 没有重新登录，因此 2017-06-25 的第一天留存时间为 0/1=0.00</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> install_dt,<span class="built_in">count</span>(<span class="keyword">distinct</span> player_id)installs,</span><br><span class="line">       round(<span class="built_in">sum</span>(if(datediff(event_date,install_dt)<span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">distinct</span> player_id),<span class="number">2</span>) Day1_retention </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">min</span>(event_date) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id) install_dt</span><br><span class="line">    <span class="keyword">from</span> Activity</span><br><span class="line">)t1   </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> install_dt</span><br></pre></td></tr></table></figure><h4 id="1098-小众书籍"><a href="#1098-小众书籍" class="headerlink" title="1098. 小众书籍"></a><a href="https://leetcode-cn.com/problems/unpopular-books/">1098. 小众书籍</a></h4><p>难度中等</p><p>SQL架构</p><p>书籍表 <code>Books</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| book_id        | int     |</span><br><span class="line">| name           | varchar |</span><br><span class="line">| available_from | date    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">book_id 是这个表的主键。</span><br></pre></td></tr></table></figure><p>订单表 <code>Orders</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| order_id       | int     |</span><br><span class="line">| book_id        | int     |</span><br><span class="line">| quantity       | int     |</span><br><span class="line">| dispatch_date  | date    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">order_id 是这个表的主键。</span><br><span class="line">book_id  是 Books 表的外键。</span><br></pre></td></tr></table></figure><p>你需要写一段 SQL 命令，筛选出过去一年中订单总量 <strong>少于10本</strong> 的 <strong>书籍</strong> 。</p><p>注意：<strong>不考虑</strong> 上架（available from）距今 <strong>不满一个月</strong> 的书籍。并且 <strong>假设今天是</strong> <strong>2019-06-23</strong> 。</p><p> Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23.</p><p>下面是样例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Books 表：</span><br><span class="line">+---------+--------------------+----------------+</span><br><span class="line">| book_id | name               | available_from |</span><br><span class="line">+---------+--------------------+----------------+</span><br><span class="line">| 1       | &quot;Kalila And Demna&quot; | 2010-01-01     |</span><br><span class="line">| 2       | &quot;28 Letters&quot;       | 2012-05-12     |</span><br><span class="line">| 3       | &quot;The Hobbit&quot;       | 2019-06-10     |</span><br><span class="line">| 4       | &quot;13 Reasons Why&quot;   | 2019-06-01     |</span><br><span class="line">| 5       | &quot;The Hunger Games&quot; | 2008-09-21     |</span><br><span class="line">+---------+--------------------+----------------+</span><br><span class="line"></span><br><span class="line">Orders 表：</span><br><span class="line">+----------+---------+----------+---------------+</span><br><span class="line">| order_id | book_id | quantity | dispatch_date |</span><br><span class="line">+----------+---------+----------+---------------+</span><br><span class="line">| 1        | 1       | 2        | 2018-07-26    |</span><br><span class="line">| 2        | 1       | 1        | 2018-11-05    |</span><br><span class="line">| 3        | 3       | 8        | 2019-06-11    |</span><br><span class="line">| 4        | 4       | 6        | 2019-06-05    |</span><br><span class="line">| 5        | 4       | 5        | 2019-06-20    |</span><br><span class="line">| 6        | 5       | 9        | 2009-02-02    |</span><br><span class="line">| 7        | 5       | 8        | 2010-04-13    |</span><br><span class="line">+----------+---------+----------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| book_id   | name               |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| 1         | &quot;Kalila And Demna&quot; |</span><br><span class="line">| 2         | &quot;28 Letters&quot;       |</span><br><span class="line">| 5         | &quot;The Hunger Games&quot; |</span><br><span class="line">+-----------+--------------------+</span><br></pre></td></tr></table></figure><blockquote><p>这题中英文 都有歧义，看结果进行分析</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.book_id, a.name </span><br><span class="line"><span class="keyword">FROM</span> books a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders b <span class="keyword">ON</span> a.book_id<span class="operator">=</span>b.book_id </span><br><span class="line"><span class="keyword">AND</span> dispatch_date <span class="keyword">BETWEEN</span> DATE_ADD(<span class="string">&#x27;2019-06-23&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">YEAR</span>) <span class="keyword">AND</span> <span class="string">&#x27;2019-06-23&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> a.available_from <span class="operator">&lt;=</span> DATE_ADD(<span class="string">&#x27;2019-06-23&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">MONTH</span>) </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.book_id, a.name </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(IFNULL(b.quantity,<span class="number">0</span>)) <span class="operator">&lt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.book_id;</span><br></pre></td></tr></table></figure><blockquote><p>此题有坑，首先订单近一年，再者quantity为null，还有近一月出版，sum不是订单是本数</p><p>还有就是date_add这个函数在hive里和mysql语法上有点小区别</p></blockquote><h4 id="1107-每日新用户统计"><a href="#1107-每日新用户统计" class="headerlink" title="1107. 每日新用户统计"></a><a href="https://leetcode-cn.com/problems/new-users-daily-count/">1107. 每日新用户统计</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Traffic</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| activity      | enum    |</span><br><span class="line">| activity_date | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表没有主键，它可能有重复的行。</span><br><span class="line">activity 列是 ENUM 类型，可能取 (&#x27;login&#x27;, &#x27;logout&#x27;, &#x27;jobs&#x27;, &#x27;groups&#x27;, &#x27;homepage&#x27;) 几个值之一。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，以查询从今天起最多 90 天内，每个日期该日期首次登录的用户数。假设今天是 <strong>2019-06-30</strong>.</p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Traffic 表：</span><br><span class="line">+---------+----------+---------------+</span><br><span class="line">| user_id | activity | activity_date |</span><br><span class="line">+---------+----------+---------------+</span><br><span class="line">| 1       | login    | 2019-05-01    |</span><br><span class="line">| 1       | homepage | 2019-05-01    |</span><br><span class="line">| 1       | logout   | 2019-05-01    |</span><br><span class="line">| 2       | login    | 2019-06-21    |</span><br><span class="line">| 2       | logout   | 2019-06-21    |</span><br><span class="line">| 3       | login    | 2019-01-01    |</span><br><span class="line">| 3       | jobs     | 2019-01-01    |</span><br><span class="line">| 3       | logout   | 2019-01-01    |</span><br><span class="line">| 4       | login    | 2019-06-21    |</span><br><span class="line">| 4       | groups   | 2019-06-21    |</span><br><span class="line">| 4       | logout   | 2019-06-21    |</span><br><span class="line">| 5       | login    | 2019-03-01    |</span><br><span class="line">| 5       | logout   | 2019-03-01    |</span><br><span class="line">| 5       | login    | 2019-06-21    |</span><br><span class="line">| 5       | logout   | 2019-06-21    |</span><br><span class="line">+---------+----------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+-------------+</span><br><span class="line">| login_date | user_count  |</span><br><span class="line">+------------+-------------+</span><br><span class="line">| 2019-05-01 | 1           |</span><br><span class="line">| 2019-06-21 | 2           |</span><br><span class="line">+------------+-------------+</span><br><span class="line">请注意，我们只关心用户数非零的日期.</span><br><span class="line">ID 为 5 的用户第一次登陆于 2019-03-01，因此他不算在 2019-06-21 的的统计内。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> login_date,<span class="built_in">count</span>(<span class="operator">*</span>) user_count</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> user_id,<span class="built_in">min</span>(activity_date) login_date</span><br><span class="line">    <span class="keyword">from</span> Traffic</span><br><span class="line">    <span class="keyword">where</span> activity <span class="operator">=</span> <span class="string">&#x27;login&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line">    <span class="keyword">having</span> login_date<span class="operator">&gt;=</span> DATE_ADD(<span class="string">&#x27;2019-06-30&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">-90</span> <span class="keyword">DAY</span>) </span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> login_date</span><br></pre></td></tr></table></figure><h4 id="1112-每位学生的最高成绩"><a href="#1112-每位学生的最高成绩" class="headerlink" title="1112. 每位学生的最高成绩"></a><a href="https://leetcode-cn.com/problems/highest-grade-for-each-student/">1112. 每位学生的最高成绩</a></h4><p>难度中等</p><p>SQL架构</p><p>表：<code>Enrollments</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| student_id    | int     |</span><br><span class="line">| course_id     | int     |</span><br><span class="line">| grade         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(student_id, course_id) 是该表的主键。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，查询每位学生获得的最高成绩和它所对应的科目，若科目成绩并列，取 <code>course_id</code> 最小的一门。查询结果需按 <code>student_id</code> 增序进行排序。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Enrollments 表：</span><br><span class="line">+------------+-------------------+</span><br><span class="line">| student_id | course_id | grade |</span><br><span class="line">+------------+-----------+-------+</span><br><span class="line">| 2          | 2         | 95    |</span><br><span class="line">| 2          | 3         | 95    |</span><br><span class="line">| 1          | 1         | 90    |</span><br><span class="line">| 1          | 2         | 99    |</span><br><span class="line">| 3          | 1         | 80    |</span><br><span class="line">| 3          | 2         | 75    |</span><br><span class="line">| 3          | 3         | 82    |</span><br><span class="line">+------------+-----------+-------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+-------------------+</span><br><span class="line">| student_id | course_id | grade |</span><br><span class="line">+------------+-----------+-------+</span><br><span class="line">| 1          | 2         | 99    |</span><br><span class="line">| 2          | 2         | 95    |</span><br><span class="line">| 3          | 3         | 82    |</span><br><span class="line">+------------+-----------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,course_id ,grade</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> student_id,course_id ,grade,</span><br><span class="line"><span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> student_id <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span>,course_id) rK</span><br><span class="line"><span class="keyword">from</span> Enrollments</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1113-报告的记录"><a href="#1113-报告的记录" class="headerlink" title="1113. 报告的记录"></a><a href="https://leetcode-cn.com/problems/reported-posts/">1113. 报告的记录</a></h4><p>难度简单</p><p>SQL架构</p><p>动作表：<code>Actions</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| post_id       | int     |</span><br><span class="line">| action_date   | date    | </span><br><span class="line">| action        | enum    |</span><br><span class="line">| extra         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表没有主键，所以可能会有重复的行。</span><br><span class="line">action 字段是 ENUM 类型的，包含:(&#x27;view&#x27;, &#x27;like&#x27;, &#x27;reaction&#x27;, &#x27;comment&#x27;, &#x27;report&#x27;, &#x27;share&#x27;)</span><br><span class="line">extra 字段是可选的信息（可能为 null），其中的信息例如有：1.报告理由(a reason for report) 2.反应类型(a type of reaction)</span><br></pre></td></tr></table></figure><p>编写一条SQL，查询每种 <em><strong>报告理由</strong></em>（report reason）在昨天的报告数量。假设今天是 <strong>2019-07-05</strong>。</p><p>查询及结果的格式示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Actions table:</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line">| user_id | post_id | action_date | action | extra  |</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line">| 1       | 1       | 2019-07-01  | view   | null   |</span><br><span class="line">| 1       | 1       | 2019-07-01  | like   | null   |</span><br><span class="line">| 1       | 1       | 2019-07-01  | share  | null   |</span><br><span class="line">| 2       | 4       | 2019-07-04  | view   | null   |</span><br><span class="line">| 2       | 4       | 2019-07-04  | report | spam   |</span><br><span class="line">| 3       | 4       | 2019-07-04  | view   | null   |</span><br><span class="line">| 3       | 4       | 2019-07-04  | report | spam   |</span><br><span class="line">| 4       | 3       | 2019-07-02  | view   | null   |</span><br><span class="line">| 4       | 3       | 2019-07-02  | report | spam   |</span><br><span class="line">| 5       | 2       | 2019-07-04  | view   | null   |</span><br><span class="line">| 5       | 2       | 2019-07-04  | report | racism |</span><br><span class="line">| 5       | 5       | 2019-07-04  | view   | null   |</span><br><span class="line">| 5       | 5       | 2019-07-04  | report | racism |</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| report_reason | report_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| spam          | 1            |</span><br><span class="line">| racism        | 2            |</span><br><span class="line">+---------------+--------------+ </span><br><span class="line">注意，我们只关心报告数量非零的结果。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">extra <span class="keyword">AS</span> report_reason,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">distinct</span> post_id) <span class="keyword">AS</span> report_count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Actions</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">`action` <span class="operator">=</span> <span class="string">&#x27;report&#x27;</span> <span class="keyword">AND</span> action_date <span class="operator">=</span> date_add(<span class="string">&#x27;2019-07-05&#x27;</span>,<span class="type">Interval</span> <span class="number">-1</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">extra;</span><br></pre></td></tr></table></figure><h4 id="1132-报告的记录-II"><a href="#1132-报告的记录-II" class="headerlink" title="1132. 报告的记录 II"></a><a href="https://leetcode-cn.com/problems/reported-posts-ii/">1132. 报告的记录 II</a></h4><p>难度中等</p><p>SQL架构</p><p>动作表： <code>Actions</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| post_id       | int     |</span><br><span class="line">| action_date   | date    |</span><br><span class="line">| action        | enum    |</span><br><span class="line">| extra         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">这张表没有主键，并有可能存在重复的行。</span><br><span class="line">action 列的类型是 ENUM，可能的值为 (&#x27;view&#x27;, &#x27;like&#x27;, &#x27;reaction&#x27;, &#x27;comment&#x27;, &#x27;report&#x27;, &#x27;share&#x27;)。</span><br><span class="line">extra 列拥有一些可选信息，例如：报告理由（a reason for report）或反应类型（a type of reaction）等。</span><br></pre></td></tr></table></figure><p>移除表： <code>Removals</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| post_id       | int     |</span><br><span class="line">| remove_date   | date    | </span><br><span class="line">+---------------+---------+</span><br><span class="line">这张表的主键是 post_id。</span><br><span class="line">这张表的每一行表示一个被移除的帖子，原因可能是由于被举报或被管理员审查。</span><br></pre></td></tr></table></figure><p>编写一段 SQL 来查找：在被报告为垃圾广告的帖子中，被移除的帖子的每日平均占比，<strong>四舍五入到小数点后 2 位</strong>。</p><p>查询结果的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Actions table:</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line">| user_id | post_id | action_date | action | extra  |</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line">| 1       | 1       | 2019-07-01  | view   | null   |</span><br><span class="line">| 1       | 1       | 2019-07-01  | like   | null   |</span><br><span class="line">| 1       | 1       | 2019-07-01  | share  | null   |</span><br><span class="line">| 2       | 2       | 2019-07-04  | view   | null   |</span><br><span class="line">| 2       | 2       | 2019-07-04  | report | spam   |</span><br><span class="line">| 3       | 4       | 2019-07-04  | view   | null   |</span><br><span class="line">| 3       | 4       | 2019-07-04  | report | spam   |</span><br><span class="line">| 4       | 3       | 2019-07-02  | view   | null   |</span><br><span class="line">| 4       | 3       | 2019-07-02  | report | spam   |</span><br><span class="line">| 5       | 2       | 2019-07-03  | view   | null   |</span><br><span class="line">| 5       | 2       | 2019-07-03  | report | racism |</span><br><span class="line">| 5       | 5       | 2019-07-03  | view   | null   |</span><br><span class="line">| 5       | 5       | 2019-07-03  | report | racism |</span><br><span class="line">+---------+---------+-------------+--------+--------+</span><br><span class="line"></span><br><span class="line">Removals table:</span><br><span class="line">+---------+-------------+</span><br><span class="line">| post_id | remove_date |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 2       | 2019-07-20  |</span><br><span class="line">| 3       | 2019-07-18  |</span><br><span class="line">+---------+-------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------------------+</span><br><span class="line">| average_daily_percent |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 75.00                 |</span><br><span class="line">+-----------------------+</span><br><span class="line">2019-07-04 的垃圾广告移除率是 50%，因为有两张帖子被报告为垃圾广告，但只有一个得到移除。</span><br><span class="line">2019-07-02 的垃圾广告移除率是 100%，因为有一张帖子被举报为垃圾广告并得到移除。</span><br><span class="line">其余几天没有收到垃圾广告的举报，因此平均值为：(50 + 100) / 2 = 75%</span><br><span class="line">注意，输出仅需要一个平均值即可，我们并不关注移除操作的日期。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(proportion) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> average_daily_percent  </span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> actions.action_date, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> removals.post_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> actions.post_id) <span class="keyword">AS</span> proportion</span><br><span class="line">    <span class="keyword">FROM</span> actions</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> removals</span><br><span class="line">    <span class="keyword">ON</span> actions.post_id <span class="operator">=</span> removals.post_id</span><br><span class="line">    <span class="keyword">WHERE</span> extra <span class="operator">=</span> <span class="string">&#x27;spam&#x27;</span> </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> actions.action_date</span><br><span class="line">) a</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>要理解spam的含义</p></blockquote><h4 id="1126-查询活跃业务"><a href="#1126-查询活跃业务" class="headerlink" title="1126. 查询活跃业务"></a><a href="https://leetcode-cn.com/problems/active-businesses/">1126. 查询活跃业务</a></h4><p>难度中等</p><p>SQL架构</p><p>事件表：<code>Events</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| business_id   | int     |</span><br><span class="line">| event_type    | varchar |</span><br><span class="line">| occurences    | int     | </span><br><span class="line">+---------------+---------+</span><br><span class="line">此表的主键是 (business_id, event_type)。</span><br><span class="line">表中的每一行记录了某种类型的事件在某些业务中多次发生的信息。</span><br></pre></td></tr></table></figure><p>写一段 SQL 来查询所有活跃的业务。</p><p>如果一个业务的某个事件类型的发生次数大于此事件类型在所有业务中的平均发生次数，并且该业务至少有两个这样的事件类型，那么该业务就可被看做是活跃业务。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Events table:</span><br><span class="line">+-------------+------------+------------+</span><br><span class="line">| business_id | event_type | occurences |</span><br><span class="line">+-------------+------------+------------+</span><br><span class="line">| 1           | reviews    | 7          |</span><br><span class="line">| 3           | reviews    | 3          |</span><br><span class="line">| 1           | ads        | 11         |</span><br><span class="line">| 2           | ads        | 7          |</span><br><span class="line">| 3           | ads        | 6          |</span><br><span class="line">| 1           | page views | 3          |</span><br><span class="line">| 2           | page views | 12         |</span><br><span class="line">+-------------+------------+------------+</span><br><span class="line"></span><br><span class="line">结果表</span><br><span class="line">+-------------+</span><br><span class="line">| business_id |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">+-------------+ </span><br><span class="line">&#x27;reviews&#x27;、 &#x27;ads&#x27; 和 &#x27;page views&#x27; 的总平均发生次数分别是 (7+3)/2=5, (11+7+6)/3=8, (3+12)/2=7.5。</span><br><span class="line">id 为 1 的业务有 7 个 &#x27;reviews&#x27; 事件（大于 5）和 11 个 &#x27;ads&#x27; 事件（大于 8），所以它是活跃业务。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> business_id</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> business_id,occurences,</span><br><span class="line">    <span class="built_in">avg</span>(occurences) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> event_type) avo</span><br><span class="line">    <span class="keyword">from</span> Events</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span>  occurences <span class="operator">&gt;</span> avo</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> business_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="1127-用户购买平台"><a href="#1127-用户购买平台" class="headerlink" title="1127. 用户购买平台"></a><a href="https://leetcode-cn.com/problems/user-purchase-platform/">1127. 用户购买平台</a></h4><p>难度困难</p><p>SQL架构</p><p>支出表: <code>Spending</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| user_id     | int     |</span><br><span class="line">| spend_date  | date    |</span><br><span class="line">| platform    | enum    | </span><br><span class="line">| amount      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">这张表记录了用户在一个在线购物网站的支出历史，该在线购物平台同时拥有桌面端（&#x27;desktop&#x27;）和手机端（&#x27;mobile&#x27;）的应用程序。</span><br><span class="line">这张表的主键是 (user_id, spend_date, platform)。</span><br><span class="line">平台列 platform 是一种 ENUM ，类型为（&#x27;desktop&#x27;, &#x27;mobile&#x27;）。</span><br></pre></td></tr></table></figure><p>写一段 SQL 来查找每天 <strong>仅</strong> 使用手机端用户、<strong>仅</strong> 使用桌面端用户和 <strong>同时</strong> 使用桌面端和手机端的用户人数和总支出金额。</p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Spending table:</span><br><span class="line">+---------+------------+----------+--------+</span><br><span class="line">| user_id | spend_date | platform | amount |</span><br><span class="line">+---------+------------+----------+--------+</span><br><span class="line">| 1       | 2019-07-01 | mobile   | 100    |</span><br><span class="line">| 1       | 2019-07-01 | desktop  | 100    |</span><br><span class="line">| 2       | 2019-07-01 | mobile   | 100    |</span><br><span class="line">| 2       | 2019-07-02 | mobile   | 100    |</span><br><span class="line">| 3       | 2019-07-01 | desktop  | 100    |</span><br><span class="line">| 3       | 2019-07-02 | desktop  | 100    |</span><br><span class="line">+---------+------------+----------+--------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+----------+--------------+-------------+</span><br><span class="line">| spend_date | platform | total_amount | total_users |</span><br><span class="line">+------------+----------+--------------+-------------+</span><br><span class="line">| 2019-07-01 | desktop  | 100          | 1           |</span><br><span class="line">| 2019-07-01 | mobile   | 100          | 1           |</span><br><span class="line">| 2019-07-01 | both     | 200          | 1           |</span><br><span class="line">| 2019-07-02 | desktop  | 100          | 1           |</span><br><span class="line">| 2019-07-02 | mobile   | 100          | 1           |</span><br><span class="line">| 2019-07-02 | both     | 0            | 0           |</span><br><span class="line">+------------+----------+--------------+-------------+ </span><br><span class="line">在 2019-07-01, 用户1 同时 使用桌面端和手机端购买, 用户2 仅 使用了手机端购买，而用户3 仅 使用了桌面端购买。</span><br><span class="line">在 2019-07-02, 用户2 仅 使用了手机端购买, 用户3 仅 使用了桌面端购买，且没有用户 同时 使用桌面端和手机端购买。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    spend_date, platform,</span><br><span class="line">    ifnull(<span class="built_in">sum</span>(total_am),<span class="number">0</span>) total_amount,</span><br><span class="line">    ifnull(<span class="built_in">sum</span>(total_u),<span class="number">0</span>) total_users</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> p.spend_date, p.platform, t.total_am, t.total_u</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> spend_date, &quot;desktop&quot; platform <span class="keyword">from</span> Spending</span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> spend_date, &quot;mobile&quot; platform <span class="keyword">from</span> Spending</span><br><span class="line">        <span class="keyword">union</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> spend_date, &quot;both&quot; platform <span class="keyword">from</span> Spending</span><br><span class="line">    ) p</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> spend_date, </span><br><span class="line">            if(<span class="built_in">count</span>(<span class="keyword">distinct</span> platform)<span class="operator">=</span><span class="number">1</span>, platform, <span class="string">&#x27;both&#x27;</span>) plat,</span><br><span class="line">            <span class="built_in">sum</span>(amount) total_am,</span><br><span class="line">            <span class="built_in">count</span>(<span class="keyword">distinct</span> user_id) total_u</span><br><span class="line">        <span class="keyword">from</span> Spending</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> spend_date, user_id</span><br><span class="line">    ) t</span><br><span class="line">    <span class="keyword">on</span> p.platform <span class="operator">=</span> t.plat <span class="keyword">and</span> p.spend_date <span class="operator">=</span> t.spend_date</span><br><span class="line">) temp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> spend_date, platform</span><br></pre></td></tr></table></figure><blockquote><p>必须保证 desktop mobile both的顺序 ，所以 先列出三个字段</p></blockquote><h4 id="1141-查询近30天活跃用户数"><a href="#1141-查询近30天活跃用户数" class="headerlink" title="1141. 查询近30天活跃用户数"></a><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-i/">1141. 查询近30天活跃用户数</a></h4><p>难度简单</p><p>SQL架构</p><p>活动记录表：<code>Activity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| session_id    | int     |</span><br><span class="line">| activity_date | date    |</span><br><span class="line">| activity_type | enum    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表是用户在社交网站的活动记录。</span><br><span class="line">该表没有主键，可能包含重复数据。</span><br><span class="line">activity_type 字段为以下四种值 (&#x27;open_session&#x27;, &#x27;end_session&#x27;, &#x27;scroll_down&#x27;, &#x27;send_message&#x27;)。</span><br><span class="line">每个 session_id 只属于一个用户。</span><br></pre></td></tr></table></figure><p>请写SQL查询出截至 <strong>2019-07-27</strong>（包含2019-07-27）<strong>，近</strong> 30天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。</p><p>查询结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Activity table:</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line">| user_id | session_id | activity_date | activity_type |</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line">| 1       | 1          | 2019-07-20    | open_session  |</span><br><span class="line">| 1       | 1          | 2019-07-20    | scroll_down   |</span><br><span class="line">| 1       | 1          | 2019-07-20    | end_session   |</span><br><span class="line">| 2       | 4          | 2019-07-20    | open_session  |</span><br><span class="line">| 2       | 4          | 2019-07-21    | send_message  |</span><br><span class="line">| 2       | 4          | 2019-07-21    | end_session   |</span><br><span class="line">| 3       | 2          | 2019-07-21    | open_session  |</span><br><span class="line">| 3       | 2          | 2019-07-21    | send_message  |</span><br><span class="line">| 3       | 2          | 2019-07-21    | end_session   |</span><br><span class="line">| 4       | 3          | 2019-06-25    | open_session  |</span><br><span class="line">| 4       | 3          | 2019-06-25    | end_session   |</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+--------------+ </span><br><span class="line">| day        | active_users |</span><br><span class="line">+------------+--------------+ </span><br><span class="line">| 2019-07-20 | 2            |</span><br><span class="line">| 2019-07-21 | 2            |</span><br><span class="line">+------------+--------------+ </span><br><span class="line">非活跃用户的记录不需要展示。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> activity_date <span class="keyword">day</span>,<span class="built_in">count</span>(<span class="keyword">distinct</span> user_id) active_users</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">where</span> activity_date <span class="operator">&gt;</span> date_add(<span class="string">&#x27;2019-07-27&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">MONTH</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> activity_date</span><br></pre></td></tr></table></figure><h4 id="1142-过去30天的用户活动-II"><a href="#1142-过去30天的用户活动-II" class="headerlink" title="1142. 过去30天的用户活动 II"></a><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-ii/">1142. 过去30天的用户活动 II</a></h4><p>难度简单7收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>Table: <code>Activity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| session_id    | int     |</span><br><span class="line">| activity_date | date    |</span><br><span class="line">| activity_type | enum    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表没有主键，它可能有重复的行。</span><br><span class="line">activity_type列是一种类型的ENUM（“ open_session”，“ end_session”，“ scroll_down”，“ send_message”）。</span><br><span class="line">该表显示了社交媒体网站的用户活动。</span><br><span class="line">请注意，每个会话完全属于一个用户。</span><br></pre></td></tr></table></figure><p>编写SQL查询以查找截至2019年7月27日（含）的30天内每个用户的平均会话数，四舍五入到小数点后两位。我们只统计那些会话期间用户至少进行一项活动的有效会话。 </p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Activity table:</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line">| user_id | session_id | activity_date | activity_type |</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line">| 1       | 1          | 2019-07-20    | open_session  |</span><br><span class="line">| 1       | 1          | 2019-07-20    | scroll_down   |</span><br><span class="line">| 1       | 1          | 2019-07-20    | end_session   |</span><br><span class="line">| 2       | 4          | 2019-07-20    | open_session  |</span><br><span class="line">| 2       | 4          | 2019-07-21    | send_message  |</span><br><span class="line">| 2       | 4          | 2019-07-21    | end_session   |</span><br><span class="line">| 3       | 2          | 2019-07-21    | open_session  |</span><br><span class="line">| 3       | 2          | 2019-07-21    | send_message  |</span><br><span class="line">| 3       | 2          | 2019-07-21    | end_session   |</span><br><span class="line">| 3       | 5          | 2019-07-21    | open_session  |</span><br><span class="line">| 3       | 5          | 2019-07-21    | scroll_down   |</span><br><span class="line">| 3       | 5          | 2019-07-21    | end_session   |</span><br><span class="line">| 4       | 3          | 2019-06-25    | open_session  |</span><br><span class="line">| 4       | 3          | 2019-06-25    | end_session   |</span><br><span class="line">+---------+------------+---------------+---------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+---------------------------+ </span><br><span class="line">| average_sessions_per_user |</span><br><span class="line">+---------------------------+ </span><br><span class="line">| 1.33                      |</span><br><span class="line">+---------------------------+ </span><br><span class="line">User 1 和 2 在过去30天内各自进行了1次会话，而用户3进行了2次会话，因此平均值为（1 +1 + 2）/ 3 = 1.33。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(ROUND(<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> session_id) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id), <span class="number">2</span>), <span class="number">0</span>) <span class="keyword">AS</span> average_sessions_per_user</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">where</span> activity_date <span class="operator">&gt;</span> date_add(<span class="string">&#x27;2019-07-27&#x27;</span>,<span class="type">INTERVAL</span> <span class="number">-1</span> <span class="keyword">MONTH</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1个session id 代表一次会话</p></blockquote><h4 id="1148-文章浏览-I"><a href="#1148-文章浏览-I" class="headerlink" title="1148. 文章浏览 I"></a><a href="https://leetcode-cn.com/problems/article-views-i/">1148. 文章浏览 I</a></h4><p>难度简单3收藏分享切换为英文关注反馈</p><p>SQL架构</p><p><code>Views</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| article_id    | int     |</span><br><span class="line">| author_id     | int     |</span><br><span class="line">| viewer_id     | int     |</span><br><span class="line">| view_date     | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表无主键，因此可能会存在重复行。</span><br><span class="line">此表的每一行都表示某人在某天浏览了某位作者的某篇文章。</span><br><span class="line">请注意，同一人的 author_id 和 viewer_id 是相同的。</span><br></pre></td></tr></table></figure><p>请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。</p><p>查询结果的格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Views 表：</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| article_id | author_id | viewer_id | view_date  |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| 1          | 3         | 5         | 2019-08-01 |</span><br><span class="line">| 1          | 3         | 6         | 2019-08-02 |</span><br><span class="line">| 2          | 7         | 7         | 2019-08-01 |</span><br><span class="line">| 2          | 7         | 6         | 2019-08-02 |</span><br><span class="line">| 4          | 7         | 1         | 2019-07-22 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line">结果表：</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 4    |</span><br><span class="line">| 7    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> author_id id</span><br><span class="line"><span class="keyword">from</span> Views</span><br><span class="line"><span class="keyword">where</span> author_id<span class="operator">=</span>  viewer_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure><h4 id="1149-文章浏览-II"><a href="#1149-文章浏览-II" class="headerlink" title="1149. 文章浏览 II"></a><a href="https://leetcode-cn.com/problems/article-views-ii/">1149. 文章浏览 II</a></h4><p>难度中等4收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>Table: <code>Views</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| article_id    | int     |</span><br><span class="line">| author_id     | int     |</span><br><span class="line">| viewer_id     | int     |</span><br><span class="line">| view_date     | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表无主键，因此可能会存在重复行。此表的每一行都表示某人在某天浏览了某位作者的某篇文章。 请注意，同一人的 author_id 和 viewer_id 是相同的。</span><br></pre></td></tr></table></figure><p>编写一条 SQL 查询来找出在同一天阅读至少两篇文章的人，结果按照 id 升序排序。</p><p>查询结果的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Views table:</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| article_id | author_id | viewer_id | view_date  |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| 1          | 3         | 5         | 2019-08-01 |</span><br><span class="line">| 3          | 4         | 5         | 2019-08-01 |</span><br><span class="line">| 1          | 3         | 6         | 2019-08-02 |</span><br><span class="line">| 2          | 7         | 7         | 2019-08-01 |</span><br><span class="line">| 2          | 7         | 6         | 2019-08-02 |</span><br><span class="line">| 4          | 7         | 1         | 2019-07-22 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> viewer_id <span class="keyword">AS</span> id</span><br><span class="line"><span class="keyword">FROM</span> Views</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> view_date, viewer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> article_id) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> viewer_id</span><br></pre></td></tr></table></figure><h4 id="1158-市场分析-I"><a href="#1158-市场分析-I" class="headerlink" title="1158. 市场分析 I"></a><a href="https://leetcode-cn.com/problems/market-analysis-i/">1158. 市场分析 I</a></h4><p>难度中等</p><p>SQL架构</p><p>Table: <code>Users</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| user_id        | int     |</span><br><span class="line">| join_date      | date    |</span><br><span class="line">| favorite_brand | varchar |</span><br><span class="line">+----------------+---------+</span><br><span class="line">此表主键是 user_id，表中描述了购物网站的用户信息，用户可以在此网站上进行商品买卖。</span><br></pre></td></tr></table></figure><p>Table: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| item_id       | int     |</span><br><span class="line">| buyer_id      | int     |</span><br><span class="line">| seller_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表主键是 order_id，外键是 item_id 和（buyer_id，seller_id）。</span><br></pre></td></tr></table></figure><p>Table: <code>Item</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| item_id       | int     |</span><br><span class="line">| item_brand    | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表主键是 item_id。</span><br></pre></td></tr></table></figure><p>请写出一条SQL语句以查询每个用户的注册日期和在 <strong>2019</strong> 年作为买家的订单总数。</p><p>查询结果格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Users table:</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| user_id | join_date  | favorite_brand |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| 1       | 2018-01-01 | Lenovo         |</span><br><span class="line">| 2       | 2018-02-09 | Samsung        |</span><br><span class="line">| 3       | 2018-01-19 | LG             |</span><br><span class="line">| 4       | 2018-05-21 | HP             |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line"></span><br><span class="line">Orders table:</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line">| order_id | order_date | item_id | buyer_id | seller_id |</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line">| 1        | 2019-08-01 | 4       | 1        | 2         |</span><br><span class="line">| 2        | 2018-08-02 | 2       | 1        | 3         |</span><br><span class="line">| 3        | 2019-08-03 | 3       | 2        | 3         |</span><br><span class="line">| 4        | 2018-08-04 | 1       | 4        | 2         |</span><br><span class="line">| 5        | 2018-08-04 | 1       | 3        | 4         |</span><br><span class="line">| 6        | 2019-08-05 | 2       | 2        | 4         |</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line"></span><br><span class="line">Items table:</span><br><span class="line">+---------+------------+</span><br><span class="line">| item_id | item_brand |</span><br><span class="line">+---------+------------+</span><br><span class="line">| 1       | Samsung    |</span><br><span class="line">| 2       | Lenovo     |</span><br><span class="line">| 3       | LG         |</span><br><span class="line">| 4       | HP         |</span><br><span class="line">+---------+------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------+------------+----------------+</span><br><span class="line">| buyer_id  | join_date  | orders_in_2019 |</span><br><span class="line">+-----------+------------+----------------+</span><br><span class="line">| 1         | 2018-01-01 | 1              |</span><br><span class="line">| 2         | 2018-02-09 | 2              |</span><br><span class="line">| 3         | 2018-01-19 | 0              |</span><br><span class="line">| 4         | 2018-05-21 | 0              |</span><br><span class="line">+-----------+------------+----------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id buyer_id,join_date, ifnull(cnt,<span class="number">0</span>)orders_in_2019</span><br><span class="line"><span class="keyword">from</span> Users u <span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> buyer_id,<span class="built_in">count</span>(<span class="operator">*</span>) cnt</span><br><span class="line"><span class="keyword">from</span> Orders</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(order_date) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  buyer_id</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">on</span> u.user_id <span class="operator">=</span>t1.buyer_id</span><br></pre></td></tr></table></figure><h4 id="1159-市场分析-II"><a href="#1159-市场分析-II" class="headerlink" title="1159. 市场分析 II"></a><a href="https://leetcode-cn.com/problems/market-analysis-ii/">1159. 市场分析 II</a></h4><p>难度困难</p><p>SQL架构</p><p>表: <code>Users</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| user_id        | int     |</span><br><span class="line">| join_date      | date    |</span><br><span class="line">| favorite_brand | varchar |</span><br><span class="line">+----------------+---------+</span><br><span class="line">user_id 是该表的主键</span><br><span class="line">表中包含一位在线购物网站用户的个人信息，用户可以在该网站出售和购买商品。</span><br></pre></td></tr></table></figure><p>表: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| item_id       | int     |</span><br><span class="line">| buyer_id      | int     |</span><br><span class="line">| seller_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">order_id 是该表的主键</span><br><span class="line">item_id 是 Items 表的外键</span><br><span class="line">buyer_id 和 seller_id 是 Users 表的外键</span><br></pre></td></tr></table></figure><p>表: <code>Items</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| item_id       | int     |</span><br><span class="line">| item_brand    | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">item_id 是该表的主键</span><br></pre></td></tr></table></figure><p>写一个 SQL 查询确定每一个用户按日期顺序卖出的第二件商品的品牌是否是他们最喜爱的品牌。如果一个用户卖出少于两件商品，查询的结果是 <code>no</code> 。</p><p>题目保证没有一个用户在一天中卖出超过一件商品</p><p>下面是查询结果格式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Users table:</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| user_id | join_date  | favorite_brand |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| 1       | 2019-01-01 | Lenovo         |</span><br><span class="line">| 2       | 2019-02-09 | Samsung        |</span><br><span class="line">| 3       | 2019-01-19 | LG             |</span><br><span class="line">| 4       | 2019-05-21 | HP             |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line"></span><br><span class="line">Orders table:</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line">| order_id | order_date | item_id | buyer_id | seller_id |</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line">| 1        | 2019-08-01 | 4       | 1        | 2         |</span><br><span class="line">| 2        | 2019-08-02 | 2       | 1        | 3         |</span><br><span class="line">| 3        | 2019-08-03 | 3       | 2        | 3         |</span><br><span class="line">| 4        | 2019-08-04 | 1       | 4        | 2         |</span><br><span class="line">| 5        | 2019-08-04 | 1       | 3        | 4         |</span><br><span class="line">| 6        | 2019-08-05 | 2       | 2        | 4         |</span><br><span class="line">+----------+------------+---------+----------+-----------+</span><br><span class="line"></span><br><span class="line">Items table:</span><br><span class="line">+---------+------------+</span><br><span class="line">| item_id | item_brand |</span><br><span class="line">+---------+------------+</span><br><span class="line">| 1       | Samsung    |</span><br><span class="line">| 2       | Lenovo     |</span><br><span class="line">| 3       | LG         |</span><br><span class="line">| 4       | HP         |</span><br><span class="line">+---------+------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| seller_id | 2nd_item_fav_brand |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line">| 1         | no                 |</span><br><span class="line">| 2         | yes                |</span><br><span class="line">| 3         | yes                |</span><br><span class="line">| 4         | no                 |</span><br><span class="line">+-----------+--------------------+</span><br><span class="line"></span><br><span class="line">id 为 1 的用户的查询结果是 no，因为他什么也没有卖出</span><br><span class="line">id为 2 和 3 的用户的查询结果是 yes，因为他们卖出的第二件商品的品牌是他们自己最喜爱的品牌</span><br><span class="line">id为 4 的用户的查询结果是 no，因为他卖出的第二件商品的品牌不是他最喜爱的品牌</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id seller_id, if(item_brand<span class="operator">=</span>favorite_brand,<span class="string">&#x27;yes&#x27;</span>,<span class="string">&#x27;no&#x27;</span>) <span class="number">2</span>nd_item_fav_brand </span><br><span class="line"><span class="keyword">from</span> Users u</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> i.item_id,seller_id,item_brand</span><br><span class="line">    <span class="keyword">from</span> Items i</span><br><span class="line">    <span class="keyword">join</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> seller_id,item_id,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> seller_id  <span class="keyword">order</span> <span class="keyword">by</span> order_date ) rk</span><br><span class="line">        <span class="keyword">from</span> Orders </span><br><span class="line">    )t1 </span><br><span class="line">    <span class="keyword">on</span> i.item_id <span class="operator">=</span> t1.item_id </span><br><span class="line">    <span class="keyword">where</span> rk  <span class="operator">=</span><span class="number">2</span></span><br><span class="line">)t2</span><br><span class="line"><span class="keyword">on</span> u.user_id <span class="operator">=</span> t2.seller_id</span><br></pre></td></tr></table></figure><h4 id="1164-指定日期的产品价格"><a href="#1164-指定日期的产品价格" class="headerlink" title="1164. 指定日期的产品价格"></a><a href="https://leetcode-cn.com/problems/product-price-at-a-given-date/">1164. 指定日期的产品价格</a></h4><p>难度中等</p><p>SQL架构</p><p>产品数据表: <code>Products</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| new_price     | int     |</span><br><span class="line">| change_date   | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">这张表的主键是 (product_id, change_date)。</span><br><span class="line">这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。</span><br></pre></td></tr></table></figure><p>写一段 SQL来查找在 <strong>2019-08-16</strong> 时全部产品的价格，假设所有产品在修改前的价格都是 <strong>10。</strong></p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Products table:</span><br><span class="line">+------------+-----------+-------------+</span><br><span class="line">| product_id | new_price | change_date |</span><br><span class="line">+------------+-----------+-------------+</span><br><span class="line">| 1          | 20        | 2019-08-14  |</span><br><span class="line">| 2          | 50        | 2019-08-14  |</span><br><span class="line">| 1          | 30        | 2019-08-15  |</span><br><span class="line">| 1          | 35        | 2019-08-16  |</span><br><span class="line">| 2          | 65        | 2019-08-17  |</span><br><span class="line">| 3          | 20        | 2019-08-18  |</span><br><span class="line">+------------+-----------+-------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+-------+</span><br><span class="line">| product_id | price |</span><br><span class="line">+------------+-------+</span><br><span class="line">| 2          | 50    |</span><br><span class="line">| 1          | 35    |</span><br><span class="line">| 3          | 10    |</span><br><span class="line">+------------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> p.product_id,ifnull(t1.new_price,<span class="number">10</span>) price</span><br><span class="line"><span class="keyword">from</span> Products p</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> product_id,new_price</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> product_id,new_price,change_date,<span class="built_in">Max</span>(change_date) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> product_id  ) md</span><br><span class="line">        <span class="keyword">from</span>  Products</span><br><span class="line">        <span class="keyword">where</span> change_date<span class="operator">&lt;=</span><span class="string">&#x27;2019-08-16&#x27;</span></span><br><span class="line">    )tmp</span><br><span class="line">    <span class="keyword">where</span> change_date <span class="operator">=</span> md</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">on</span> p. product_id <span class="operator">=</span> t1.product_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1173-即时食物配送-I"><a href="#1173-即时食物配送-I" class="headerlink" title="1173. 即时食物配送 I"></a><a href="https://leetcode-cn.com/problems/immediate-food-delivery-i/">1173. 即时食物配送 I</a></h4><p>难度简单</p><p>SQL架构</p><p>配送表: <code>Delivery</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+---------+</span><br><span class="line">| Column Name                 | Type    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">| delivery_id                 | int     |</span><br><span class="line">| customer_id                 | int     |</span><br><span class="line">| order_date                  | date    |</span><br><span class="line">| customer_pref_delivery_date | date    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">delivery_id 是表的主键。</span><br><span class="line">该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。</span><br></pre></td></tr></table></figure><p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p><p>写一条 SQL 查询语句获取即时订单所占的百分比， <strong>保留两位小数。</strong></p><p>查询结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Delivery 表:</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| delivery_id | customer_id | order_date | customer_pref_delivery_date |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| 1           | 1           | 2019-08-01 | 2019-08-02                  |</span><br><span class="line">| 2           | 5           | 2019-08-02 | 2019-08-02                  |</span><br><span class="line">| 3           | 1           | 2019-08-11 | 2019-08-11                  |</span><br><span class="line">| 4           | 3           | 2019-08-24 | 2019-08-26                  |</span><br><span class="line">| 5           | 4           | 2019-08-21 | 2019-08-22                  |</span><br><span class="line">| 6           | 2           | 2019-08-11 | 2019-08-13                  |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----------------------+</span><br><span class="line">| immediate_percentage |</span><br><span class="line">+----------------------+</span><br><span class="line">| 33.33                |</span><br><span class="line">+----------------------+</span><br><span class="line">2 和 3 号订单为即时订单，其他的为计划订单。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="built_in">sum</span>(if(order_date<span class="operator">=</span>customer_pref_delivery_date,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100</span>,<span class="number">2</span>) immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure><h4 id="1174-即时食物配送-II"><a href="#1174-即时食物配送-II" class="headerlink" title="1174. 即时食物配送 II"></a><a href="https://leetcode-cn.com/problems/immediate-food-delivery-ii/">1174. 即时食物配送 II</a></h4><p>难度中等</p><p>SQL架构</p><p>配送表: <code>Delivery</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+---------+</span><br><span class="line">| Column Name                 | Type    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">| delivery_id                 | int     |</span><br><span class="line">| customer_id                 | int     |</span><br><span class="line">| order_date                  | date    |</span><br><span class="line">| customer_pref_delivery_date | date    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">delivery_id 是表的主键。</span><br><span class="line">该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。</span><br></pre></td></tr></table></figure><p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p><p>「首次订单」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。</p><p>写一条 SQL 查询语句获取即时订单在所有用户的首次订单中的比例。<strong>保留两位小数。</strong></p><p>查询结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Delivery 表：</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| delivery_id | customer_id | order_date | customer_pref_delivery_date |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| 1           | 1           | 2019-08-01 | 2019-08-02                  |</span><br><span class="line">| 2           | 2           | 2019-08-02 | 2019-08-02                  |</span><br><span class="line">| 3           | 1           | 2019-08-11 | 2019-08-12                  |</span><br><span class="line">| 4           | 3           | 2019-08-24 | 2019-08-24                  |</span><br><span class="line">| 5           | 3           | 2019-08-21 | 2019-08-22                  |</span><br><span class="line">| 6           | 2           | 2019-08-11 | 2019-08-13                  |</span><br><span class="line">| 7           | 4           | 2019-08-09 | 2019-08-09                  |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+----------------------+</span><br><span class="line">| immediate_percentage |</span><br><span class="line">+----------------------+</span><br><span class="line">| 50.00                |</span><br><span class="line">+----------------------+</span><br><span class="line">1 号顾客的 1 号订单是首次订单，并且是计划订单。</span><br><span class="line">2 号顾客的 2 号订单是首次订单，并且是即时订单。</span><br><span class="line">3 号顾客的 5 号订单是首次订单，并且是计划订单。</span><br><span class="line">4 号顾客的 7 号订单是首次订单，并且是即时订单。</span><br><span class="line">因此，一半顾客的首次订单是即时的。</span><br></pre></td></tr></table></figure><p>开窗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="built_in">sum</span>(if(order_date <span class="operator">=</span> fo <span class="operator">&amp;&amp;</span> fo<span class="operator">=</span>d,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">distinct</span> customer_id)<span class="operator">*</span><span class="number">100</span>,<span class="number">2</span>) immediate_percentage </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> customer_id,order_date,<span class="built_in">min</span>(order_date)<span class="keyword">over</span> ( <span class="keyword">partition</span> <span class="keyword">by</span> customer_id) fo,</span><br><span class="line">    if(order_date<span class="operator">=</span>customer_pref_delivery_date,order_date ,<span class="keyword">null</span>) d</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br><span class="line">)t1</span><br></pre></td></tr></table></figure><p>另一种思路</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> round (</span><br><span class="line">    <span class="built_in">sum</span>(order_date <span class="operator">=</span> customer_pref_delivery_date) <span class="operator">*</span> <span class="number">100</span> <span class="operator">/</span></span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>),</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">) <span class="keyword">as</span> immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br><span class="line"><span class="keyword">where</span> (customer_id, order_date) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> customer_id, <span class="built_in">min</span>(order_date)</span><br><span class="line">    <span class="keyword">from</span> delivery</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="1179-重新格式化部门表"><a href="#1179-重新格式化部门表" class="headerlink" title="1179. 重新格式化部门表"></a><a href="https://leetcode-cn.com/problems/reformat-department-table/">1179. 重新格式化部门表</a></h4><p>难度</p><p>SQL架构</p><p>部门表 <code>Department</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| revenue       | int     |</span><br><span class="line">| month         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, month) 是表的联合主键。</span><br><span class="line">这个表格有关于每个部门每月收入的信息。</span><br><span class="line">月份（month）可以取下列值 [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 <strong>每个月</strong> 的收入（revenue）列。</p><p>查询结果格式如下面的示例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Department 表：</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| id   | revenue | month |</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| 1    | 8000    | Jan   |</span><br><span class="line">| 2    | 9000    | Jan   |</span><br><span class="line">| 3    | 10000   | Feb   |</span><br><span class="line">| 1    | 7000    | Feb   |</span><br><span class="line">| 1    | 6000    | Mar   |</span><br><span class="line">+------+---------+-------+</span><br><span class="line"></span><br><span class="line">查询得到的结果表：</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| 1    | 8000        | 7000        | 6000        | ... | null        |</span><br><span class="line">| 2    | 9000        | null        | null        | ... | null        |</span><br><span class="line">| 3    | null        | 10000       | null        | ... | null        |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line"></span><br><span class="line">注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Jan&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Jan_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Feb&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Feb_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Mar&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Mar_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Apr&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Apr_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;May&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) May_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Jun&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Jun_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Jul&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Jul_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Aug&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Aug_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Sep&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Sep_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Oct&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Oct_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Nov&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Nov_Revenue,</span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">CASE</span> `<span class="keyword">month</span>` <span class="keyword">WHEN</span> <span class="string">&#x27;Dec&#x27;</span> <span class="keyword">THEN</span> revenue <span class="keyword">END</span>) Dec_Revenue</span><br><span class="line"><span class="keyword">FROM</span> Department</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1193.</span> 每月交易 I</span><br><span class="line"><span class="keyword">SQL</span>架构</span><br><span class="line"><span class="keyword">Table</span>: Transactions</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name   <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id            <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> country       <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> state         <span class="operator">|</span> enum    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> amount        <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> trans_date    <span class="operator">|</span> <span class="type">date</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line">id 是这个表的主键。</span><br><span class="line">该表包含有关传入事务的信息。</span><br><span class="line">state 列类型为 “[”批准“，”拒绝“] 之一。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">编写一个 <span class="keyword">sql</span> 查询来查找每个月和每个国家<span class="operator">/</span>地区的事务数及其总金额、已批准的事务数及其总金额。</span><br><span class="line"></span><br><span class="line">查询结果格式如下所示：</span><br><span class="line"></span><br><span class="line">Transactions <span class="keyword">table</span>:</span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+----------+--------+------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> country <span class="operator">|</span> state    <span class="operator">|</span> amount <span class="operator">|</span> trans_date <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+----------+--------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">121</span>  <span class="operator">|</span> US      <span class="operator">|</span> approved <span class="operator">|</span> <span class="number">1000</span>   <span class="operator">|</span> <span class="number">2018</span><span class="number">-12</span><span class="number">-18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">122</span>  <span class="operator">|</span> US      <span class="operator">|</span> declined <span class="operator">|</span> <span class="number">2000</span>   <span class="operator">|</span> <span class="number">2018</span><span class="number">-12</span><span class="number">-19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">123</span>  <span class="operator">|</span> US      <span class="operator">|</span> approved <span class="operator">|</span> <span class="number">2000</span>   <span class="operator">|</span> <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">124</span>  <span class="operator">|</span> DE      <span class="operator">|</span> approved <span class="operator">|</span> <span class="number">2000</span>   <span class="operator">|</span> <span class="number">2019</span><span class="number">-01</span><span class="number">-07</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+---------+----------+--------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Result</span> <span class="keyword">table</span>:</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+-------------+----------------+--------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">month</span>    <span class="operator">|</span> country <span class="operator">|</span> trans_count <span class="operator">|</span> approved_count <span class="operator">|</span> trans_total_amount <span class="operator">|</span> approved_total_amount <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+-------------+----------------+--------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2018</span><span class="number">-12</span>  <span class="operator">|</span> US      <span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span> <span class="number">1</span>              <span class="operator">|</span> <span class="number">3000</span>               <span class="operator">|</span> <span class="number">1000</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2019</span><span class="number">-01</span>  <span class="operator">|</span> US      <span class="operator">|</span> <span class="number">1</span>           <span class="operator">|</span> <span class="number">1</span>              <span class="operator">|</span> <span class="number">2000</span>               <span class="operator">|</span> <span class="number">2000</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2019</span><span class="number">-01</span>  <span class="operator">|</span> DE      <span class="operator">|</span> <span class="number">1</span>           <span class="operator">|</span> <span class="number">1</span>              <span class="operator">|</span> <span class="number">2000</span>               <span class="operator">|</span> <span class="number">2000</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+-------------+----------------+--------------------+-----------------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(trans_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    country,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> trans_count,</span><br><span class="line">    <span class="built_in">COUNT</span>(IF(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>, <span class="number">1</span>, <span class="keyword">NULL</span>)) <span class="keyword">AS</span> approved_count,</span><br><span class="line">    <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> trans_total_amount,</span><br><span class="line">    <span class="built_in">SUM</span>(IF(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>, amount, <span class="number">0</span>)) <span class="keyword">AS</span> approved_total_amount</span><br><span class="line"><span class="keyword">FROM</span> Transactions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>, country</span><br></pre></td></tr></table></figure><h4 id="1193-每月交易-I"><a href="#1193-每月交易-I" class="headerlink" title="1193. 每月交易 I"></a><a href="https://leetcode-cn.com/problems/monthly-transactions-i/">1193. 每月交易 I</a></h4><p>难度中等</p><p>SQL架构</p><p>Table: <code>Transactions</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| country       | varchar |</span><br><span class="line">| state         | enum    |</span><br><span class="line">| amount        | int     |</span><br><span class="line">| trans_date    | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是这个表的主键。</span><br><span class="line">该表包含有关传入事务的信息。</span><br><span class="line">state 列类型为 “[”批准“，”拒绝“] 之一。</span><br></pre></td></tr></table></figure><p>编写一个 sql 查询来查找每个月和每个国家/地区的事务数及其总金额、已批准的事务数及其总金额。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Transactions table:</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line">| id   | country | state    | amount | trans_date |</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line">| 121  | US      | approved | 1000   | 2018-12-18 |</span><br><span class="line">| 122  | US      | declined | 2000   | 2018-12-19 |</span><br><span class="line">| 123  | US      | approved | 2000   | 2019-01-01 |</span><br><span class="line">| 124  | DE      | approved | 2000   | 2019-01-07 |</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+----------+---------+-------------+----------------+--------------------+-----------------------+</span><br><span class="line">| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |</span><br><span class="line">+----------+---------+-------------+----------------+--------------------+-----------------------+</span><br><span class="line">| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |</span><br><span class="line">| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |</span><br><span class="line">| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |</span><br><span class="line">+----------+---------+-------------+----------------+--------------------+-----------------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(trans_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    country,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> trans_count,</span><br><span class="line">    <span class="built_in">COUNT</span>(IF(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>, <span class="number">1</span>, <span class="keyword">NULL</span>)) <span class="keyword">AS</span> approved_count,</span><br><span class="line">    <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> trans_total_amount,</span><br><span class="line">    <span class="built_in">SUM</span>(IF(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>, amount, <span class="number">0</span>)) <span class="keyword">AS</span> approved_total_amount</span><br><span class="line"><span class="keyword">FROM</span> Transactions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">month</span>, country</span><br></pre></td></tr></table></figure><h4 id="1205-每月交易II"><a href="#1205-每月交易II" class="headerlink" title="1205. 每月交易II"></a><a href="https://leetcode-cn.com/problems/monthly-transactions-ii/">1205. 每月交易II</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Transactions</code> 记录表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| id             | int     |</span><br><span class="line">| country        | varchar |</span><br><span class="line">| state          | enum    |</span><br><span class="line">| amount         | int     |</span><br><span class="line">| trans_date     | date    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">id 是这个表的主键。</span><br><span class="line">该表包含有关传入事务的信息。</span><br><span class="line">状态列是类型为 [approved（已批准）、declined（已拒绝）] 的枚举。</span><br></pre></td></tr></table></figure><p><code>Chargebacks</code> 表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| trans_id       | int     |</span><br><span class="line">| charge_date    | date    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">退单包含有关放置在事务表中的某些事务的传入退单的基本信息。</span><br><span class="line">trans_id 是 transactions 表的 id 列的外键。</span><br><span class="line">每项退单都对应于之前进行的交易，即使未经批准。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，以查找每个月和每个国家/地区的已批准交易的数量及其总金额、退单的数量及其总金额。</p><p>注意：在您的查询中，给定月份和国家，忽略所有为零的行。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Transactions 表：</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line">| id   | country | state    | amount | trans_date |</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line">| 101  | US      | approved | 1000   | 2019-05-18 |</span><br><span class="line">| 102  | US      | declined | 2000   | 2019-05-19 |</span><br><span class="line">| 103  | US      | approved | 3000   | 2019-06-10 |</span><br><span class="line">| 104  | US      | declined | 4000   | 2019-06-13 |</span><br><span class="line">| 105  | US      | approved | 5000   | 2019-06-15 |</span><br><span class="line">+------+---------+----------+--------+------------+</span><br><span class="line"></span><br><span class="line">Chargebacks 表：</span><br><span class="line">+------------+------------+</span><br><span class="line">| trans_id   | trans_date |</span><br><span class="line">+------------+------------+</span><br><span class="line">| 102        | 2019-05-29 |</span><br><span class="line">| 101        | 2019-06-30 |</span><br><span class="line">| 105        | 2019-09-18 |</span><br><span class="line">+------------+------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+----------+---------+----------------+-----------------+-------------------+--------------------+</span><br><span class="line">| month    | country | approved_count | approved_amount | chargeback_count  | chargeback_amount  |</span><br><span class="line">+----------+---------+----------------+-----------------+-------------------+--------------------+</span><br><span class="line">| 2019-05  | US      | 1              | 1000            | 1                 | 2000               |</span><br><span class="line">| 2019-06  | US      | 2              | 8000            | 1                 | 1000               |</span><br><span class="line">| 2019-09  | US      | 0              | 0               | 1                 | 5000               |</span><br><span class="line">+----------+---------+----------------+-----------------+-------------------+--------------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    date_format(trans_date, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">month</span>, </span><br><span class="line">    country,</span><br><span class="line">    <span class="built_in">sum</span>(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>) approved_count,</span><br><span class="line">    <span class="built_in">sum</span>(if(state <span class="operator">=</span> <span class="string">&#x27;approved&#x27;</span>, amount, <span class="number">0</span>)) approved_amount,</span><br><span class="line">    <span class="built_in">sum</span>(state <span class="operator">=</span> <span class="string">&#x27;chargeback&#x27;</span>) chargeback_count,</span><br><span class="line">    <span class="built_in">sum</span>(if(state <span class="operator">=</span> <span class="string">&#x27;chargeback&#x27;</span>, amount, <span class="number">0</span>)) chargeback_amount</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> transactions</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> id, country, <span class="string">&#x27;chargeback&#x27;</span> state, amount, c.trans_date</span><br><span class="line">    <span class="keyword">from</span> chargebacks c <span class="keyword">left</span> <span class="keyword">join</span> transactions t </span><br><span class="line">    <span class="keyword">on</span> c.trans_id <span class="operator">=</span> t.id</span><br><span class="line">) tmp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>, country</span><br><span class="line"><span class="keyword">having</span> approved_amount <span class="keyword">or</span> chargeback_amount</span><br></pre></td></tr></table></figure><h4 id="1194-锦标赛优胜者"><a href="#1194-锦标赛优胜者" class="headerlink" title="1194. 锦标赛优胜者"></a><a href="https://leetcode-cn.com/problems/tournament-winners/">1194. 锦标赛优胜者</a></h4><p>难度困难</p><p>SQL架构</p><p><code>Players</code> 玩家表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| player_id   | int   |</span><br><span class="line">| group_id    | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">玩家 ID 是此表的主键。</span><br><span class="line">此表的每一行表示每个玩家的组。</span><br></pre></td></tr></table></figure><p><code>Matches</code> 赛事表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| match_id      | int     |</span><br><span class="line">| first_player  | int     |</span><br><span class="line">| second_player | int     | </span><br><span class="line">| first_score   | int     |</span><br><span class="line">| second_score  | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">match_id 是此表的主键。</span><br><span class="line">每一行是一场比赛的记录，第一名和第二名球员包含每场比赛的球员 ID。</span><br><span class="line">第一个玩家和第二个玩家的分数分别包含第一个玩家和第二个玩家的分数。</span><br><span class="line">你可以假设，在每一场比赛中，球员都属于同一组。</span><br></pre></td></tr></table></figure><p>每组的获胜者是在组内得分最高的选手。如果平局，player_id <strong>最小</strong> 的选手获胜。</p><p>编写一个 SQL 查询来查找每组中的获胜者。</p><p>查询结果格式如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Players 表:</span><br><span class="line">+-----------+------------+</span><br><span class="line">| player_id | group_id   |</span><br><span class="line">+-----------+------------+</span><br><span class="line">| 15        | 1          |</span><br><span class="line">| 25        | 1          |</span><br><span class="line">| 30        | 1          |</span><br><span class="line">| 45        | 1          |</span><br><span class="line">| 10        | 2          |</span><br><span class="line">| 35        | 2          |</span><br><span class="line">| 50        | 2          |</span><br><span class="line">| 20        | 3          |</span><br><span class="line">| 40        | 3          |</span><br><span class="line">+-----------+------------+</span><br><span class="line"></span><br><span class="line">Matches 表:</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| match_id   | first_player | second_player | first_score | second_score |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| 1          | 15           | 45            | 3           | 0            |</span><br><span class="line">| 2          | 30           | 25            | 1           | 2            |</span><br><span class="line">| 3          | 30           | 15            | 2           | 0            |</span><br><span class="line">| 4          | 40           | 20            | 5           | 2            |</span><br><span class="line">| 5          | 35           | 50            | 1           | 1            |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+-----------+------------+</span><br><span class="line">| group_id  | player_id  |</span><br><span class="line">+-----------+------------+ </span><br><span class="line">| 1         | 15         |</span><br><span class="line">| 2         | 35         |</span><br><span class="line">| 3         | 40         |</span><br><span class="line">+-----------+------------+</span><br></pre></td></tr></table></figure><p>union all</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> group_id, player_id</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> group_id, player_id, <span class="built_in">SUM</span>(score) <span class="keyword">AS</span> score</span><br><span class="line">    <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="comment">-- 每个用户总的 first_score</span></span><br><span class="line">        <span class="keyword">SELECT</span> Players.group_id, Players.player_id, <span class="built_in">SUM</span>(Matches.first_score) <span class="keyword">AS</span> score</span><br><span class="line">        <span class="keyword">FROM</span> Players <span class="keyword">JOIN</span> <span class="keyword">Matches</span> <span class="keyword">ON</span> Players.player_id <span class="operator">=</span> Matches.first_player</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> Players.player_id</span><br><span class="line"></span><br><span class="line">        <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 每个用户总的 second_score</span></span><br><span class="line">        <span class="keyword">SELECT</span> Players.group_id, Players.player_id, <span class="built_in">SUM</span>(Matches.second_score) <span class="keyword">AS</span> score</span><br><span class="line">        <span class="keyword">FROM</span> Players <span class="keyword">JOIN</span> <span class="keyword">Matches</span> <span class="keyword">ON</span> Players.player_id <span class="operator">=</span> Matches.second_player</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> Players.player_id</span><br><span class="line">    ) s</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> player_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>, player_id</span><br><span class="line">) <span class="keyword">result</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> group_id</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_id, player_id</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> players.<span class="operator">*</span>, <span class="built_in">sum</span>(if(player_id <span class="operator">=</span> first_player, first_score, second_score)) score</span><br><span class="line">    <span class="keyword">from</span> players <span class="keyword">join</span> <span class="keyword">matches</span></span><br><span class="line">    <span class="keyword">on</span> player_id <span class="operator">=</span> first_player <span class="keyword">or</span> player_id <span class="operator">=</span> second_player</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> player_id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>, player_id</span><br><span class="line">) tmp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> group_id</span><br></pre></td></tr></table></figure><h4 id="1204-最后一个能进入电梯的人"><a href="#1204-最后一个能进入电梯的人" class="headerlink" title="1204. 最后一个能进入电梯的人"></a><a href="https://leetcode-cn.com/problems/last-person-to-fit-in-the-elevator/">1204. 最后一个能进入电梯的人</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Queue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| person_id   | int     |</span><br><span class="line">| person_name | varchar |</span><br><span class="line">| weight      | int     |</span><br><span class="line">| turn        | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">person_id 是这个表的主键。</span><br><span class="line">该表展示了所有等待电梯的人的信息。</span><br><span class="line">表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。</span><br></pre></td></tr></table></figure><p>电梯最大载重量为 <strong>1000</strong>。</p><p>写一条 SQL 查询语句查找最后一个能进入电梯且不超过重量限制的 <code>person_name</code> 。题目确保队列中第一位的人可以进入电梯 。</p><p>查询结果如下所示 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Queue 表</span><br><span class="line">+-----------+-------------------+--------+------+</span><br><span class="line">| person_id | person_name       | weight | turn |</span><br><span class="line">+-----------+-------------------+--------+------+</span><br><span class="line">| 5         | George Washington | 250    | 1    |</span><br><span class="line">| 3         | John Adams        | 350    | 2    |</span><br><span class="line">| 6         | Thomas Jefferson  | 400    | 3    |</span><br><span class="line">| 2         | Will Johnliams    | 200    | 4    |</span><br><span class="line">| 4         | Thomas Jefferson  | 175    | 5    |</span><br><span class="line">| 1         | James Elephant    | 500    | 6    |</span><br><span class="line">+-----------+-------------------+--------+------+</span><br><span class="line"></span><br><span class="line">Result 表</span><br><span class="line">+-------------------+</span><br><span class="line">| person_name       |</span><br><span class="line">+-------------------+</span><br><span class="line">| Thomas Jefferson  |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">为了简化，Queue 表按 turn 列由小到大排序。</span><br><span class="line">上例中 George Washington(id 5), John Adams(id 3) 和 Thomas Jefferson(id 6) 将可以进入电梯,因为他们的体重和为 250 + 350 + 400 = 1000。</span><br><span class="line">Thomas Jefferson(id 6) 是最后一个体重合适并进入电梯的人。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> person_name</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> person_name  ,<span class="built_in">sum</span>(weight) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> turn) t</span><br><span class="line">    <span class="keyword">from</span> Queue</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> t<span class="operator">&lt;=</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t <span class="keyword">desc</span> </span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1211-查询结果的质量和占比"><a href="#1211-查询结果的质量和占比" class="headerlink" title="1211. 查询结果的质量和占比"></a><a href="https://leetcode-cn.com/problems/queries-quality-and-percentage/">1211. 查询结果的质量和占比</a></h4><p>难度简单</p><p>SQL架构</p><p>查询表 <code>Queries</code>： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| query_name  | varchar |</span><br><span class="line">| result      | varchar |</span><br><span class="line">| position    | int     |</span><br><span class="line">| rating      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">此表没有主键，并可能有重复的行。</span><br><span class="line">此表包含了一些从数据库中收集的查询信息。</span><br><span class="line">“位置”（position）列的值为 1 到 500 。</span><br><span class="line">“评分”（rating）列的值为 1 到 5 。评分小于 3 的查询被定义为质量很差的查询。</span><br></pre></td></tr></table></figure><p>将查询结果的质量 <code>quality</code> 定义为：</p><blockquote><p>各查询结果的评分与其位置之间比率的平均值。</p></blockquote><p>将劣质查询百分比 <code>poor_query_percentage</code> 为：</p><blockquote><p>评分小于 3 的查询结果占全部查询结果的百分比。</p></blockquote><p>编写一组 SQL 来查找每次查询的<code>名称</code>(<code>query_name</code>)、<code>质量</code>(<code>quality</code>) 和 <code>劣质查询百分比</code>(<code>poor_query_percentage</code>)。</p><p><code>质量</code>(<code>quality</code>) 和<code>劣质查询百分比</code>(<code>poor_query_percentage</code>) 都应四舍五入到小数点后两位。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Queries table:</span><br><span class="line">+------------+-------------------+----------+--------+</span><br><span class="line">| query_name | result            | position | rating |</span><br><span class="line">+------------+-------------------+----------+--------+</span><br><span class="line">| Dog        | Golden Retriever  | 1        | 5      |</span><br><span class="line">| Dog        | German Shepherd   | 2        | 5      |</span><br><span class="line">| Dog        | Mule              | 200      | 1      |</span><br><span class="line">| Cat        | Shirazi           | 5        | 2      |</span><br><span class="line">| Cat        | Siamese           | 3        | 3      |</span><br><span class="line">| Cat        | Sphynx            | 7        | 4      |</span><br><span class="line">+------------+-------------------+----------+--------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+---------+-----------------------+</span><br><span class="line">| query_name | quality | poor_query_percentage |</span><br><span class="line">+------------+---------+-----------------------+</span><br><span class="line">| Dog        | 2.50    | 33.33                 |</span><br><span class="line">| Cat        | 0.66    | 33.33                 |</span><br><span class="line">+------------+---------+-----------------------+</span><br><span class="line"></span><br><span class="line">Dog 查询结果的质量为 ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50</span><br><span class="line">Dog 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33</span><br><span class="line"></span><br><span class="line">Cat 查询结果的质量为 ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66</span><br><span class="line">Cat 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> query_name,</span><br><span class="line">    round(<span class="built_in">avg</span>(rating<span class="operator">/</span>position),<span class="number">2</span>) quality,</span><br><span class="line">    round(<span class="built_in">sum</span>(if(rating<span class="operator">&lt;</span><span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100</span>,<span class="number">2</span>) poor_query_percentage</span><br><span class="line"><span class="keyword">from</span> Queries</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> query_name</span><br></pre></td></tr></table></figure><h4 id="1212-查询球队积分"><a href="#1212-查询球队积分" class="headerlink" title="1212. 查询球队积分"></a><a href="https://leetcode-cn.com/problems/team-scores-in-football-tournament/">1212. 查询球队积分</a></h4><p>难度中等</p><p>SQL架构</p><p>Table: <code>Teams</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+----------+</span><br><span class="line">| Column Name   | Type     |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| team_id       | int      |</span><br><span class="line">| team_name     | varchar  |</span><br><span class="line">+---------------+----------+</span><br><span class="line">此表的主键是 team_id，表中的每一行都代表一支独立足球队。</span><br></pre></td></tr></table></figure><p>Table: <code>Matches</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| match_id      | int     |</span><br><span class="line">| host_team     | int     |</span><br><span class="line">| guest_team    | int     | </span><br><span class="line">| host_goals    | int     |</span><br><span class="line">| guest_goals   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表的主键是 match_id，表中的每一行都代表一场已结束的比赛，比赛的主客队分别由它们自己的 id 表示，他们的进球由 host_goals 和 guest_goals 分别表示。</span><br></pre></td></tr></table></figure><p>积分规则如下：</p><ul><li>赢一场得三分；</li><li>平一场得一分；</li><li>输一场不得分。</li></ul><p>写出一条SQL语句以查询每个队的 <strong>team_id</strong>，<strong>team_name</strong> 和 <strong>num_points</strong>。结果根据 num_points <strong>降序排序</strong>，如果有两队积分相同，那么这两队按 team_id <strong>升序排序</strong>。</p><p>查询结果格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Teams table:</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| team_id   | team_name    |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 10        | Leetcode FC  |</span><br><span class="line">| 20        | NewYork FC   |</span><br><span class="line">| 30        | Atlanta FC   |</span><br><span class="line">| 40        | Chicago FC   |</span><br><span class="line">| 50        | Toronto FC   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line"></span><br><span class="line">Matches table:</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| match_id   | host_team    | guest_team    | host_goals  | guest_goals  |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| 1          | 10           | 20            | 3           | 0            |</span><br><span class="line">| 2          | 30           | 10            | 2           | 2            |</span><br><span class="line">| 3          | 10           | 50            | 5           | 1            |</span><br><span class="line">| 4          | 20           | 30            | 1           | 0            |</span><br><span class="line">| 5          | 50           | 30            | 1           | 0            |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| team_id    | team_name    | num_points    |</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| 10         | Leetcode FC  | 7             |</span><br><span class="line">| 20         | NewYork FC   | 3             |</span><br><span class="line">| 50         | Toronto FC   | 3             |</span><br><span class="line">| 30         | Atlanta FC   | 1             |</span><br><span class="line">| 40         | Chicago FC   | 0             |</span><br><span class="line">+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> team_id , team_name ,<span class="built_in">sum</span>(</span><br><span class="line">if(team_id <span class="operator">=</span> host_team <span class="operator">&amp;&amp;</span> host_goals<span class="operator">&gt;</span>guest_goals ,<span class="number">3</span>,<span class="number">0</span>)<span class="operator">+</span></span><br><span class="line">if(team_id <span class="operator">=</span> host_team <span class="operator">&amp;&amp;</span> host_goals<span class="operator">=</span>guest_goals,<span class="number">1</span>,<span class="number">0</span>)<span class="operator">+</span></span><br><span class="line">if(team_id <span class="operator">=</span> guest_team <span class="operator">&amp;&amp;</span> host_goals<span class="operator">=</span>guest_goals,<span class="number">1</span>,<span class="number">0</span>)<span class="operator">+</span></span><br><span class="line">if(team_id <span class="operator">=</span> guest_team <span class="operator">&amp;&amp;</span> host_goals<span class="operator">&lt;</span>guest_goals ,<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">)num_points</span><br><span class="line"><span class="keyword">from</span> Teams t <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">Matches</span> m</span><br><span class="line"><span class="keyword">on</span> t.team_id <span class="operator">=</span>m.host_team  <span class="keyword">or</span> t.team_id <span class="operator">=</span>m.guest_team  </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> team_id ,team_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> num_points <span class="keyword">desc</span>,team_id</span><br></pre></td></tr></table></figure><h4 id="1225-报告系统状态的连续日期"><a href="#1225-报告系统状态的连续日期" class="headerlink" title="1225. 报告系统状态的连续日期"></a><a href="https://leetcode-cn.com/problems/report-contiguous-dates/">1225. 报告系统状态的连续日期</a></h4><p>难度困难</p><p>SQL架构</p><p>Table: <code>Failed</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| fail_date    | date    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">该表主键为 fail_date。</span><br><span class="line">该表包含失败任务的天数.</span><br></pre></td></tr></table></figure><p>Table: <code>Succeeded</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| success_date | date    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">该表主键为 success_date。</span><br><span class="line">该表包含成功任务的天数.</span><br></pre></td></tr></table></figure><p>系统 <strong>每天</strong> 运行一个任务。每个任务都独立于先前的任务。任务的状态可以是失败或是成功。</p><p>编写一个 SQL 查询 <strong>2019-01-01</strong> 到 <strong>2019-12-31</strong> 期间任务连续同状态 <code>period_state</code> 的起止日期（<code>start_date</code> 和 <code>end_date</code>）。即如果任务失败了，就是失败状态的起止日期，如果任务成功了，就是成功状态的起止日期。</p><p>最后结果按照起始日期 <code>start_date</code> 排序</p><p>查询结果样例如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Failed table:</span><br><span class="line">+-------------------+</span><br><span class="line">| fail_date         |</span><br><span class="line">+-------------------+</span><br><span class="line">| 2018-12-28        |</span><br><span class="line">| 2018-12-29        |</span><br><span class="line">| 2019-01-04        |</span><br><span class="line">| 2019-01-05        |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">Succeeded table:</span><br><span class="line">+-------------------+</span><br><span class="line">| success_date      |</span><br><span class="line">+-------------------+</span><br><span class="line">| 2018-12-30        |</span><br><span class="line">| 2018-12-31        |</span><br><span class="line">| 2019-01-01        |</span><br><span class="line">| 2019-01-02        |</span><br><span class="line">| 2019-01-03        |</span><br><span class="line">| 2019-01-06        |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+--------------+--------------+--------------+</span><br><span class="line">| period_state | start_date   | end_date     |</span><br><span class="line">+--------------+--------------+--------------+</span><br><span class="line">| succeeded    | 2019-01-01   | 2019-01-03   |</span><br><span class="line">| failed       | 2019-01-04   | 2019-01-05   |</span><br><span class="line">| succeeded    | 2019-01-06   | 2019-01-06   |</span><br><span class="line">+--------------+--------------+--------------+</span><br><span class="line"></span><br><span class="line">结果忽略了 2018 年的记录，因为我们只关心从 2019-01-01 到 2019-12-31 的记录</span><br><span class="line">从 2019-01-01 到 2019-01-03 所有任务成功，系统状态为 &quot;succeeded&quot;。</span><br><span class="line">从 2019-01-04 到 2019-01-05 所有任务失败，系统状态为 &quot;failed&quot;。</span><br><span class="line">从 2019-01-06 到 2019-01-06 所有任务成功，系统状态为 &quot;succeeded&quot;。</span><br></pre></td></tr></table></figure><p>开窗函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> type  period_state, <span class="built_in">min</span>(<span class="type">date</span>) start_date, <span class="built_in">max</span>(<span class="type">date</span>) <span class="keyword">as</span> end_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> type, <span class="type">date</span>, subdate(<span class="type">date</span>,<span class="built_in">row_number</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> type <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>)) <span class="keyword">as</span> diff</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="string">&#x27;failed&#x27;</span> <span class="keyword">as</span> type, fail_date <span class="keyword">as</span> <span class="type">date</span> <span class="keyword">from</span> Failed</span><br><span class="line">        <span class="keyword">where</span> fail_date <span class="keyword">between</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-12-31&#x27;</span></span><br><span class="line">        <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">        <span class="keyword">select</span> <span class="string">&#x27;succeeded&#x27;</span> <span class="keyword">as</span> type, success_date <span class="keyword">as</span> <span class="type">date</span> <span class="keyword">from</span> Succeeded</span><br><span class="line">        <span class="keyword">where</span> success_date <span class="keyword">between</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2019-12-31&#x27;</span></span><br><span class="line">    ) a</span><br><span class="line">)b</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> type,diff</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> start_date</span><br></pre></td></tr></table></figure><h4 id="1241-每个帖子的评论数"><a href="#1241-每个帖子的评论数" class="headerlink" title="1241. 每个帖子的评论数"></a><a href="https://leetcode-cn.com/problems/number-of-comments-per-post/">1241. 每个帖子的评论数</a></h4><p>难度简单</p><p>SQL架构</p><p>表 <code>Submissions</code> 结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+----------+</span><br><span class="line">| 列名           | 类型     |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| sub_id        | int      |</span><br><span class="line">| parent_id     | int      |</span><br><span class="line">+---------------+----------+</span><br><span class="line">上表没有主键, 所以可能会出现重复的行。</span><br><span class="line">每行可以是一个帖子或对该帖子的评论。</span><br><span class="line">如果是帖子的话，parent_id 就是 null。</span><br><span class="line">对于评论来说，parent_id 就是表中对应帖子的 sub_id。</span><br></pre></td></tr></table></figure><p>编写 SQL 语句以查找每个帖子的评论数。</p><p>结果表应包含帖子的 <code>post_id</code> 和对应的评论数 <code>number_of_comments</code> 并且按 <code>post_id</code> 升序排列。</p><p><code>Submissions</code> 可能包含重复的评论。您应该计算每个帖子的唯一评论数。</p><p><code>Submissions</code> 可能包含重复的帖子。您应该将它们视为一个帖子。</p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Submissions table:</span><br><span class="line">+---------+------------+</span><br><span class="line">| sub_id  | parent_id  |</span><br><span class="line">+---------+------------+</span><br><span class="line">| 1       | Null       |</span><br><span class="line">| 2       | Null       |</span><br><span class="line">| 1       | Null       |</span><br><span class="line">| 12      | Null       |</span><br><span class="line">| 3       | 1          |</span><br><span class="line">| 5       | 2          |</span><br><span class="line">| 3       | 1          |</span><br><span class="line">| 4       | 1          |</span><br><span class="line">| 9       | 1          |</span><br><span class="line">| 10      | 2          |</span><br><span class="line">| 6       | 7          |</span><br><span class="line">+---------+------------+</span><br><span class="line"></span><br><span class="line">结果表：</span><br><span class="line">+---------+--------------------+</span><br><span class="line">| post_id | number_of_comments |</span><br><span class="line">+---------+--------------------+</span><br><span class="line">| 1       | 3                  |</span><br><span class="line">| 2       | 2                  |</span><br><span class="line">| 12      | 0                  |</span><br><span class="line">+---------+--------------------+</span><br><span class="line"></span><br><span class="line">表中 ID 为 1 的帖子有 ID 为 3、4 和 9 的三个评论。表中 ID 为 3 的评论重复出现了，所以我们只对它进行了一次计数。</span><br><span class="line">表中 ID 为 2 的帖子有 ID 为 5 和 10 的两个评论。</span><br><span class="line">ID 为 12 的帖子在表中没有评论。</span><br><span class="line">表中 ID 为 6 的评论是对 ID 为 7 的已删除帖子的评论，因此我们将其忽略。</span><br></pre></td></tr></table></figure><p>后join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sub_id post_id,ifnull(number_of_comments,<span class="number">0</span>) number_of_comments</span><br><span class="line"><span class="keyword">from</span> Submissions s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">  <span class="keyword">select</span> parent_id ,<span class="built_in">count</span>(<span class="keyword">distinct</span> sub_id) number_of_comments</span><br><span class="line">  <span class="keyword">from</span> Submissions </span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> parent_id</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">on</span> s.sub_id <span class="operator">=</span> t1.parent_id</span><br><span class="line"><span class="keyword">where</span> s.parent_id  <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> post_id,number_of_comments</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sub_id</span><br></pre></td></tr></table></figure><p>先join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> post_id, <span class="built_in">COUNT</span>(sub_id) <span class="keyword">AS</span> number_of_comments</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> post.sub_id <span class="keyword">AS</span> post_id, sub.sub_id <span class="keyword">AS</span> sub_id</span><br><span class="line">    <span class="keyword">FROM</span> Submissions post</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Submissions sub</span><br><span class="line">    <span class="keyword">ON</span> post.sub_id <span class="operator">=</span> sub.parent_id</span><br><span class="line">    <span class="keyword">WHERE</span> post.parent_id <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line">) T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> post_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> post_id <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><h4 id="1251-平均售价"><a href="#1251-平均售价" class="headerlink" title="1251. 平均售价"></a><a href="https://leetcode-cn.com/problems/average-selling-price/">1251. 平均售价</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Prices</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| start_date    | date    |</span><br><span class="line">| end_date      | date    |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(product_id，start_date，end_date) 是 Prices 表的主键。</span><br><span class="line">Prices 表的每一行表示的是某个产品在一段时期内的价格。</span><br><span class="line">每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。</span><br></pre></td></tr></table></figure><p>Table: <code>UnitsSold</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| purchase_date | date    |</span><br><span class="line">| units         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">UnitsSold 表没有主键，它可能包含重复项。</span><br><span class="line">UnitsSold 表的每一行表示的是每种产品的出售日期，单位和产品 id。</span><br></pre></td></tr></table></figure><p>编写SQL查询以查找每种产品的平均售价。<br><code>average_price</code> 应该四舍五入到小数点后两位。<br>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Prices table:</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| product_id | start_date | end_date   | price  |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| 1          | 2019-02-17 | 2019-02-28 | 5      |</span><br><span class="line">| 1          | 2019-03-01 | 2019-03-22 | 20     |</span><br><span class="line">| 2          | 2019-02-01 | 2019-02-20 | 15     |</span><br><span class="line">| 2          | 2019-02-21 | 2019-03-31 | 30     |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line"> </span><br><span class="line">UnitsSold table:</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| product_id | purchase_date | units |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| 1          | 2019-02-25    | 100   |</span><br><span class="line">| 1          | 2019-03-01    | 15    |</span><br><span class="line">| 2          | 2019-02-10    | 200   |</span><br><span class="line">| 2          | 2019-03-22    | 30    |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+---------------+</span><br><span class="line">| product_id | average_price |</span><br><span class="line">+------------+---------------+</span><br><span class="line">| 1          | 6.96          |</span><br><span class="line">| 2          | 16.96         |</span><br><span class="line">+------------+---------------+</span><br><span class="line">平均售价 = 产品总价 / 销售的产品数量。</span><br><span class="line">产品 1 的平均售价 = ((100 * 5)+(15 * 20) )/ 115 = 6.96</span><br><span class="line">产品 2 的平均售价 = ((200 * 15)+(30 * 30) )/ 230 = 16.96</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    product_id,</span><br><span class="line">    Round(<span class="built_in">SUM</span>(sales) <span class="operator">/</span> <span class="built_in">SUM</span>(units), <span class="number">2</span>) <span class="keyword">AS</span> average_price</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        Prices.product_id <span class="keyword">AS</span> product_id,</span><br><span class="line">        Prices.price <span class="operator">*</span> UnitsSold.units <span class="keyword">AS</span> sales,</span><br><span class="line">        UnitsSold.units <span class="keyword">AS</span> units</span><br><span class="line">    <span class="keyword">FROM</span> Prices </span><br><span class="line">    <span class="keyword">JOIN</span> UnitsSold <span class="keyword">ON</span> Prices.product_id <span class="operator">=</span> UnitsSold.product_id</span><br><span class="line">    <span class="keyword">WHERE</span> UnitsSold.purchase_date <span class="keyword">BETWEEN</span> Prices.start_date <span class="keyword">AND</span> Prices.end_date</span><br><span class="line">) T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br></pre></td></tr></table></figure><blockquote><p>2表关联的时候直接把日期做过滤</p></blockquote><h4 id="1264-页面推荐"><a href="#1264-页面推荐" class="headerlink" title="1264. 页面推荐"></a><a href="https://leetcode-cn.com/problems/page-recommendations/">1264. 页面推荐</a></h4><p>难度中等</p><p>SQL架构</p><p>朋友关系列表： <code>Friendship</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user1_id      | int     |</span><br><span class="line">| user2_id      | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">这张表的主键是 (user1_id, user2_id)。</span><br><span class="line">这张表的每一行代表着 user1_id 和 user2_id 之间存在着朋友关系。</span><br></pre></td></tr></table></figure><p>喜欢列表： <code>Likes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| user_id     | int     |</span><br><span class="line">| page_id     | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">这张表的主键是 (user_id, page_id)。</span><br><span class="line">这张表的每一行代表着 user_id 喜欢 page_id。</span><br></pre></td></tr></table></figure><p>写一段 SQL  向<code>user_id</code> = 1 的用户，推荐其朋友们喜欢的页面。不要推荐该用户已经喜欢的页面。</p><p>你返回的结果中不应当包含重复项。</p><p>返回结果的格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Friendship table:</span><br><span class="line">+----------+----------+</span><br><span class="line">| user1_id | user2_id |</span><br><span class="line">+----------+----------+</span><br><span class="line">| 1        | 2        |</span><br><span class="line">| 1        | 3        |</span><br><span class="line">| 1        | 4        |</span><br><span class="line">| 2        | 3        |</span><br><span class="line">| 2        | 4        |</span><br><span class="line">| 2        | 5        |</span><br><span class="line">| 6        | 1        |</span><br><span class="line">+----------+----------+</span><br><span class="line"> </span><br><span class="line">Likes table:</span><br><span class="line">+---------+---------+</span><br><span class="line">| user_id | page_id |</span><br><span class="line">+---------+---------+</span><br><span class="line">| 1       | 88      |</span><br><span class="line">| 2       | 23      |</span><br><span class="line">| 3       | 24      |</span><br><span class="line">| 4       | 56      |</span><br><span class="line">| 5       | 11      |</span><br><span class="line">| 6       | 33      |</span><br><span class="line">| 2       | 77      |</span><br><span class="line">| 3       | 77      |</span><br><span class="line">| 6       | 88      |</span><br><span class="line">+---------+---------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------------+</span><br><span class="line">| recommended_page |</span><br><span class="line">+------------------+</span><br><span class="line">| 23               |</span><br><span class="line">| 24               |</span><br><span class="line">| 56               |</span><br><span class="line">| 33               |</span><br><span class="line">| 77               |</span><br><span class="line">+------------------+</span><br><span class="line">用户1 同 用户2, 3, 4, 6 是朋友关系。</span><br><span class="line">推荐页面为： 页面23 来自于 用户2, 页面24 来自于 用户3, 页面56 来自于 用户3 以及 页面33 来自于 用户6。</span><br><span class="line">页面77 同时被 用户2 和 用户3 推荐。</span><br><span class="line">页面88 没有被推荐，因为 用户1 已经喜欢了它。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> page_id  recommended_page</span><br><span class="line"><span class="keyword">from</span> Likes</span><br><span class="line"><span class="keyword">where</span> user_id <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">select</span> if(user1_id<span class="operator">=</span><span class="number">1</span>,user2_id,user1_id) user_id</span><br><span class="line"><span class="keyword">from</span>  Friendship</span><br><span class="line"><span class="keyword">where</span>  user1_id <span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> user2_id <span class="operator">=</span><span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">and</span> page_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> page_id <span class="keyword">from</span> Likes <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1270-向公司CEO汇报工作的所有人"><a href="#1270-向公司CEO汇报工作的所有人" class="headerlink" title="1270. 向公司CEO汇报工作的所有人"></a><a href="https://leetcode-cn.com/problems/all-people-report-to-the-given-manager/">1270. 向公司CEO汇报工作的所有人</a></h4><p>难度中等</p><p>SQL架构</p><p>员工表：<code>Employees</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| employee_id   | int     |</span><br><span class="line">| employee_name | varchar |</span><br><span class="line">| manager_id    | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">employee_id 是这个表的主键。</span><br><span class="line">这个表中每一行中，employee_id 表示职工的 ID，employee_name 表示职工的名字，manager_id 表示该职工汇报工作的直线经理。</span><br><span class="line">这个公司 CEO 是 employee_id = 1 的人。</span><br></pre></td></tr></table></figure><p>用 SQL 查询出所有直接或间接向公司 CEO 汇报工作的职工的 employee_id 。</p><p>由于公司规模较小，经理之间的间接关系不超过 3 个经理。</p><p>可以以任何顺序返回的结果，不需要去重。</p><p>查询结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Employees table:</span><br><span class="line">+-------------+---------------+------------+</span><br><span class="line">| employee_id | employee_name | manager_id |</span><br><span class="line">+-------------+---------------+------------+</span><br><span class="line">| 1           | Boss          | 1          |</span><br><span class="line">| 3           | Alice         | 3          |</span><br><span class="line">| 2           | Bob           | 1          |</span><br><span class="line">| 4           | Daniel        | 2          |</span><br><span class="line">| 7           | Luis          | 4          |</span><br><span class="line">| 8           | Jhon          | 3          |</span><br><span class="line">| 9           | Angela        | 8          |</span><br><span class="line">| 77          | Robert        | 1          |</span><br><span class="line">+-------------+---------------+------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-------------+</span><br><span class="line">| employee_id |</span><br><span class="line">+-------------+</span><br><span class="line">| 2           |</span><br><span class="line">| 77          |</span><br><span class="line">| 4           |</span><br><span class="line">| 7           |</span><br><span class="line">+-------------+</span><br><span class="line"></span><br><span class="line">公司 CEO 的 employee_id 是 1.</span><br><span class="line">employee_id 是 2 和 77 的职员直接汇报给公司 CEO。</span><br><span class="line">employee_id 是 4 的职员间接汇报给公司 CEO 4 --&gt; 2 --&gt; 1 。</span><br><span class="line">employee_id 是 7 的职员间接汇报给公司 CEO 7 --&gt; 4 --&gt; 2 --&gt; 1 。</span><br><span class="line">employee_id 是 3, 8 ，9 的职员不会直接或间接的汇报给公司 CEO。 </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> a.employee_id</span><br><span class="line"><span class="keyword">from</span> Employees a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Employees b <span class="keyword">on</span> a.manager_id <span class="operator">=</span> b.employee_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Employees c <span class="keyword">on</span> b.manager_id <span class="operator">=</span> c.employee_id</span><br><span class="line"><span class="keyword">where</span> a.manager_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> b.manager_id<span class="operator">=</span><span class="number">1</span>  <span class="keyword">or</span> c.manager_id<span class="operator">=</span><span class="number">1</span></span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> employee_id<span class="operator">!=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1280-学生们参加各科测试的次数"><a href="#1280-学生们参加各科测试的次数" class="headerlink" title="1280. 学生们参加各科测试的次数"></a><a href="https://leetcode-cn.com/problems/students-and-examinations/">1280. 学生们参加各科测试的次数</a></h4><p>难度简单</p><p>SQL架构</p><p>学生表: <code>Students</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| student_id    | int     |</span><br><span class="line">| student_name  | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">主键为 student_id（学生ID），该表内的每一行都记录有学校一名学生的信息。</span><br></pre></td></tr></table></figure><p>科目表: <code>Subjects</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| subject_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">主键为 subject_name（科目名称），每一行记录学校的一门科目名称。</span><br></pre></td></tr></table></figure><p>考试表: <code>Examinations</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| student_id   | int     |</span><br><span class="line">| subject_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">这张表压根没有主键，可能会有重复行。</span><br><span class="line">学生表里的一个学生修读科目表里的每一门科目，而这张考试表的每一行记录就表示学生表里的某个学生参加了一次科目表里某门科目的测试。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.student_id, a.student_name, b.subject_name, <span class="built_in">COUNT</span>(e.subject_name) <span class="keyword">AS</span> attended_exams</span><br><span class="line"><span class="keyword">FROM</span> Students a <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> Subjects b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Examinations e <span class="keyword">ON</span> a.student_id <span class="operator">=</span> e.student_id <span class="keyword">AND</span> b.subject_name <span class="operator">=</span> e.subject_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.student_id, b.subject_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.student_id, b.subject_name</span><br></pre></td></tr></table></figure><blockquote><p> CROSS JOIN Mysql中没有full outer join     hive中可以用</p></blockquote><h4 id="1285-找到连续区间的开始和结束数字"><a href="#1285-找到连续区间的开始和结束数字" class="headerlink" title="1285. 找到连续区间的开始和结束数字"></a><a href="https://leetcode-cn.com/problems/find-the-start-and-end-number-of-continuous-ranges/">1285. 找到连续区间的开始和结束数字</a></h4><p>难度中等</p><p>SQL架构</p><p>表：<code>Logs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| log_id        | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是上表的主键。</span><br><span class="line">上表的每一行包含日志表中的一个 ID。</span><br></pre></td></tr></table></figure><p>后来一些 ID 从 <code>Logs</code> 表中删除。编写一个 SQL 查询得到 <code>Logs</code> 表中的连续区间的开始数字和结束数字。</p><p>将查询表按照 <code>start_id</code> 排序。</p><p>查询结果格式如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Logs 表：</span><br><span class="line">+------------+</span><br><span class="line">| log_id     |</span><br><span class="line">+------------+</span><br><span class="line">| 1          |</span><br><span class="line">| 2          |</span><br><span class="line">| 3          |</span><br><span class="line">| 7          |</span><br><span class="line">| 8          |</span><br><span class="line">| 10         |</span><br><span class="line">+------------+</span><br><span class="line"></span><br><span class="line">结果表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| start_id   | end_id       |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 1          | 3            |</span><br><span class="line">| 7          | 8            |</span><br><span class="line">| 10         | 10           |</span><br><span class="line">+------------+--------------+</span><br><span class="line">结果表应包含 Logs 表中的所有区间。</span><br><span class="line">从 1 到 3 在表中。</span><br><span class="line">从 4 到 6 不在表中。</span><br><span class="line">从 7 到 8 在表中。</span><br><span class="line">9 不在表中。</span><br><span class="line">10 在表中。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">MIN</span>(log_id) start_id,</span><br><span class="line">    <span class="built_in">MAX</span>(log_id) end_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        log_id, </span><br><span class="line">        log_id <span class="operator">-</span> <span class="built_in">row_number</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> log_id) <span class="keyword">as</span> diff</span><br><span class="line">    <span class="keyword">FROM</span> Logs) t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> diff</span><br></pre></td></tr></table></figure><blockquote><p>相似1225题</p></blockquote><h4 id="1294-不同国家的天气类型"><a href="#1294-不同国家的天气类型" class="headerlink" title="1294. 不同国家的天气类型"></a><a href="https://leetcode-cn.com/problems/weather-type-in-each-country/">1294. 不同国家的天气类型</a></h4><p>难度简单</p><p>SQL架构</p><p>国家表：<code>Countries</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| country_id    | int     |</span><br><span class="line">| country_name  | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">country_id 是这张表的主键。</span><br><span class="line">该表的每行有 country_id 和 country_name 两列。</span><br></pre></td></tr></table></figure><p>天气表：<code>Weather</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| country_id    | int     |</span><br><span class="line">| weather_state | varchar |</span><br><span class="line">| day           | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(country_id, day) 是该表的复合主键。</span><br><span class="line">该表的每一行记录了某个国家某一天的天气情况。</span><br></pre></td></tr></table></figure><p>写一段 SQL 来找到表中每个国家在 2019 年 11 月的天气类型。</p><p>天气类型的定义如下：当 weather_state 的平均值小于或等于15返回 <strong>Cold</strong>，当 weather_state 的平均值大于或等于 25 返回 <strong>Hot</strong>，否则返回 <strong>Warm</strong>。</p><p>你可以以任意顺序返回你的查询结果。</p><p>查询结果格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Countries table:</span><br><span class="line">+------------+--------------+</span><br><span class="line">| country_id | country_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 2          | USA          |</span><br><span class="line">| 3          | Australia    |</span><br><span class="line">| 7          | Peru         |</span><br><span class="line">| 5          | China        |</span><br><span class="line">| 8          | Morocco      |</span><br><span class="line">| 9          | Spain        |</span><br><span class="line">+------------+--------------+</span><br><span class="line">Weather table:</span><br><span class="line">+------------+---------------+------------+</span><br><span class="line">| country_id | weather_state | day        |</span><br><span class="line">+------------+---------------+------------+</span><br><span class="line">| 2          | 15            | 2019-11-01 |</span><br><span class="line">| 2          | 12            | 2019-10-28 |</span><br><span class="line">| 2          | 12            | 2019-10-27 |</span><br><span class="line">| 3          | -2            | 2019-11-10 |</span><br><span class="line">| 3          | 0             | 2019-11-11 |</span><br><span class="line">| 3          | 3             | 2019-11-12 |</span><br><span class="line">| 5          | 16            | 2019-11-07 |</span><br><span class="line">| 5          | 18            | 2019-11-09 |</span><br><span class="line">| 5          | 21            | 2019-11-23 |</span><br><span class="line">| 7          | 25            | 2019-11-28 |</span><br><span class="line">| 7          | 22            | 2019-12-01 |</span><br><span class="line">| 7          | 20            | 2019-12-02 |</span><br><span class="line">| 8          | 25            | 2019-11-05 |</span><br><span class="line">| 8          | 27            | 2019-11-15 |</span><br><span class="line">| 8          | 31            | 2019-11-25 |</span><br><span class="line">| 9          | 7             | 2019-10-23 |</span><br><span class="line">| 9          | 3             | 2019-12-23 |</span><br><span class="line">+------------+---------------+------------+</span><br><span class="line">Result table:</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| country_name | weather_type |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| USA          | Cold         |</span><br><span class="line">| Austraila    | Cold         |</span><br><span class="line">| Peru         | Hot          |</span><br><span class="line">| China        | Warm         |</span><br><span class="line">| Morocco      | Hot          |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">USA 11 月的平均 weather_state 为 (15) / 1 = 15 所以天气类型为 Cold。</span><br><span class="line">Australia 11 月的平均 weather_state 为 (-2 + 0 + 3) / 3 = 0.333 所以天气类型为 Cold。</span><br><span class="line">Peru 11 月的平均 weather_state 为 (25) / 1 = 25 所以天气类型为 Hot。</span><br><span class="line">China 11 月的平均 weather_state 为 (16 + 18 + 21) / 3 = 18.333 所以天气类型为 Warm。</span><br><span class="line">Morocco 11 月的平均 weather_state 为 (25 + 27 + 31) / 3 = 27.667 所以天气类型为 Hot。</span><br><span class="line">我们并不知道 Spain 在 11 月的 weather_state 情况所以无需将他包含在结果中。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> country_name,( <span class="keyword">case</span> <span class="keyword">when</span> <span class="built_in">avg</span>(weather_state)<span class="operator">&lt;=</span><span class="number">15</span> <span class="keyword">then</span> <span class="string">&#x27;Cold&#x27;</span></span><br><span class="line">                        <span class="keyword">when</span> <span class="built_in">avg</span>(weather_state)<span class="operator">&gt;=</span><span class="number">25</span> <span class="keyword">then</span> <span class="string">&#x27;Hot&#x27;</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="string">&#x27;Warm&#x27;</span> <span class="keyword">end</span> ) weather_type</span><br><span class="line"><span class="keyword">from</span> Countries c <span class="keyword">join</span> Weather w <span class="keyword">on</span> c.country_id <span class="operator">=</span> w.country_id</span><br><span class="line"><span class="keyword">where</span> date_format(<span class="keyword">day</span>,&quot;%Y-%m&quot;)<span class="operator">=</span><span class="string">&#x27;2019-11&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> country_name</span><br></pre></td></tr></table></figure><h4 id="1303-求团队人数"><a href="#1303-求团队人数" class="headerlink" title="1303. 求团队人数"></a><a href="https://leetcode-cn.com/problems/find-the-team-size/">1303. 求团队人数</a></h4><p>难度简单</p><p>SQL架构</p><p>员工表：<code>Employee</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| employee_id   | int     |</span><br><span class="line">| team_id       | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">employee_id 字段是这张表的主键，表中的每一行都包含每个员工的 ID 和他们所属的团队。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，以求得每个员工所在团队的总人数。</p><p>查询结果中的顺序无特定要求。</p><p>查询结果格式示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Employee Table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_id    |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     8      |</span><br><span class="line">|     2       |     8      |</span><br><span class="line">|     3       |     8      |</span><br><span class="line">|     4       |     7      |</span><br><span class="line">|     5       |     9      |</span><br><span class="line">|     6       |     9      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">Result table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_size  |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     3      |</span><br><span class="line">|     2       |     3      |</span><br><span class="line">|     3       |     3      |</span><br><span class="line">|     4       |     1      |</span><br><span class="line">|     5       |     2      |</span><br><span class="line">|     6       |     2      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">ID 为 1、2、3 的员工是 team_id 为 8 的团队的成员，</span><br><span class="line">ID 为 4 的员工是 team_id 为 7 的团队的成员，</span><br><span class="line">ID 为 5、6 的员工是 team_id 为 9 的团队的成员。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> team_id) team_size </span><br><span class="line"><span class="keyword">from</span> Employee</span><br></pre></td></tr></table></figure><h4 id="1308-不同性别每日分数总计"><a href="#1308-不同性别每日分数总计" class="headerlink" title="1308. 不同性别每日分数总计"></a><a href="https://leetcode-cn.com/problems/running-total-for-different-genders/">1308. 不同性别每日分数总计</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Scores</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| player_name   | varchar |</span><br><span class="line">| gender        | varchar |</span><br><span class="line">| day           | date    |</span><br><span class="line">| score_points  | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(gender, day)是该表的主键</span><br><span class="line">一场比赛是在女队和男队之间举行的</span><br><span class="line">该表的每一行表示一个名叫 (player_name) 性别为 (gender) 的参赛者在某一天获得了 (score_points) 的分数</span><br><span class="line">如果参赛者是女性，那么 gender 列为 &#x27;F&#x27;，如果参赛者是男性，那么 gender 列为 &#x27;M&#x27;</span><br></pre></td></tr></table></figure><p>写一条SQL语句查询每种性别在每一天的总分，并按性别和日期对查询结果排序</p><p>下面是查询结果格式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Scores表:</span><br><span class="line">+-------------+--------+------------+--------------+</span><br><span class="line">| player_name | gender | day        | score_points |</span><br><span class="line">+-------------+--------+------------+--------------+</span><br><span class="line">| Aron        | F      | 2020-01-01 | 17           |</span><br><span class="line">| Alice       | F      | 2020-01-07 | 23           |</span><br><span class="line">| Bajrang     | M      | 2020-01-07 | 7            |</span><br><span class="line">| Khali       | M      | 2019-12-25 | 11           |</span><br><span class="line">| Slaman      | M      | 2019-12-30 | 13           |</span><br><span class="line">| Joe         | M      | 2019-12-31 | 3            |</span><br><span class="line">| Jose        | M      | 2019-12-18 | 2            |</span><br><span class="line">| Priya       | F      | 2019-12-31 | 23           |</span><br><span class="line">| Priyanka    | F      | 2019-12-30 | 17           |</span><br><span class="line">+-------------+--------+------------+--------------+</span><br><span class="line">结果表:</span><br><span class="line">+--------+------------+-------+</span><br><span class="line">| gender | day        | total |</span><br><span class="line">+--------+------------+-------+</span><br><span class="line">| F      | 2019-12-30 | 17    |</span><br><span class="line">| F      | 2019-12-31 | 40    |</span><br><span class="line">| F      | 2020-01-01 | 57    |</span><br><span class="line">| F      | 2020-01-07 | 80    |</span><br><span class="line">| M      | 2019-12-18 | 2     |</span><br><span class="line">| M      | 2019-12-25 | 13    |</span><br><span class="line">| M      | 2019-12-30 | 26    |</span><br><span class="line">| M      | 2019-12-31 | 29    |</span><br><span class="line">| M      | 2020-01-07 | 36    |</span><br><span class="line">+--------+------------+-------+</span><br><span class="line">女性队伍:</span><br><span class="line">第一天是 2019-12-30，Priyanka 获得 17 分，队伍的总分是 17 分</span><br><span class="line">第二天是 2019-12-31, Priya 获得 23 分，队伍的总分是 40 分</span><br><span class="line">第三天是 2020-01-01, Aron 获得 17 分，队伍的总分是 57 分</span><br><span class="line">第四天是 2020-01-07, Alice 获得 23 分，队伍的总分是 80 分</span><br><span class="line">男性队伍：</span><br><span class="line">第一天是 2019-12-18, Jose 获得 2 分，队伍的总分是 2 分</span><br><span class="line">第二天是 2019-12-25, Khali 获得 11 分，队伍的总分是 13 分</span><br><span class="line">第三天是 2019-12-30, Slaman 获得 13 分，队伍的总分是 26 分</span><br><span class="line">第四天是 2019-12-31, Joe 获得 3 分，队伍的总分是 29 分</span><br><span class="line">第五天是 2020-01-07, Bajrang 获得 7 分，队伍的总分是 36 分</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gender , <span class="keyword">day</span>  ,<span class="built_in">sum</span>( score_points) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> gender <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">day</span>)  total</span><br><span class="line"><span class="keyword">from</span> Scores </span><br></pre></td></tr></table></figure><h4 id="1321-餐馆营业额变化增长"><a href="#1321-餐馆营业额变化增长" class="headerlink" title="1321. 餐馆营业额变化增长"></a><a href="https://leetcode-cn.com/problems/restaurant-growth/">1321. 餐馆营业额变化增长</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Customer</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| visited_on    | date    |</span><br><span class="line">| amount        | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(customer_id, visited_on) 是该表的主键</span><br><span class="line">该表包含一家餐馆的顾客交易数据</span><br><span class="line">visited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆</span><br><span class="line">amount 是一个顾客某一天的消费总额</span><br></pre></td></tr></table></figure><p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）</p><p>写一条 SQL 查询计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值</p><p>查询结果格式的例子如下：</p><ul><li>查询结果按 <code>visited_on</code> 排序</li><li><code>average_amount</code> 要 <strong>保留两位小数</strong>，日期数据的格式为 (‘YYYY-MM-DD’)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Customer 表:</span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line">| customer_id | name         | visited_on   | amount      |</span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line">| 1           | Jhon         | 2019-01-01   | 100         |</span><br><span class="line">| 2           | Daniel       | 2019-01-02   | 110         |</span><br><span class="line">| 3           | Jade         | 2019-01-03   | 120         |</span><br><span class="line">| 4           | Khaled       | 2019-01-04   | 130         |</span><br><span class="line">| 5           | Winston      | 2019-01-05   | 110         | </span><br><span class="line">| 6           | Elvis        | 2019-01-06   | 140         | </span><br><span class="line">| 7           | Anna         | 2019-01-07   | 150         |</span><br><span class="line">| 8           | Maria        | 2019-01-08   | 80          |</span><br><span class="line">| 9           | Jaze         | 2019-01-09   | 110         | </span><br><span class="line">| 1           | Jhon         | 2019-01-10   | 130         | </span><br><span class="line">| 3           | Jade         | 2019-01-10   | 150         | </span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line"></span><br><span class="line">结果表:</span><br><span class="line">+--------------+--------------+----------------+</span><br><span class="line">| visited_on   | amount       | average_amount |</span><br><span class="line">+--------------+--------------+----------------+</span><br><span class="line">| 2019-01-07   | 860          | 122.86         |</span><br><span class="line">| 2019-01-08   | 840          | 120            |</span><br><span class="line">| 2019-01-09   | 840          | 120            |</span><br><span class="line">| 2019-01-10   | 1000         | 142.86         |</span><br><span class="line">+--------------+--------------+----------------+</span><br><span class="line"></span><br><span class="line">第一个七天消费平均值从 2019-01-01 到 2019-01-07 是 (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86</span><br><span class="line">第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120</span><br><span class="line">第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120</span><br><span class="line">第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  visited_on,amount,round(amount<span class="operator">/</span><span class="number">7</span>,<span class="number">2</span>) average_amount</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> visited_on,ant,<span class="built_in">lag</span>(visited_on,<span class="number">6</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> visited_on) lg,</span><br><span class="line">            <span class="built_in">sum</span>(ant) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> visited_on <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">6</span> PRECEDING <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) amount</span><br><span class="line">    <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span>  visited_on  ,<span class="built_in">sum</span>(amount) ant</span><br><span class="line">        <span class="keyword">from</span> Customer</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> visited_on</span><br><span class="line">    )t1</span><br><span class="line">)t2</span><br><span class="line"><span class="keyword">where</span> lg <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h4 id="1322-广告效果"><a href="#1322-广告效果" class="headerlink" title="1322. 广告效果"></a><a href="https://leetcode-cn.com/problems/ads-performance/">1322. 广告效果</a></h4><p>难度简单8收藏分享切换为英文关注反馈</p><p>SQL架构</p><p>表: <code>Ads</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| ad_id         | int     |</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| action        | enum    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(ad_id, user_id) 是该表的主键</span><br><span class="line">该表的每一行包含一条广告的 ID(ad_id)，用户的 ID(user_id) 和用户对广告采取的行为 (action)</span><br><span class="line">action 列是一个枚举类型 (&#x27;Clicked&#x27;, &#x27;Viewed&#x27;, &#x27;Ignored&#x27;) 。</span><br></pre></td></tr></table></figure><p>一家公司正在运营这些广告并想计算每条广告的效果。</p><p>广告效果用点击通过率（Click-Through Rate：CTR）来衡量，公式如下:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/06/sql1.png" alt="img"></p><p>写一条SQL语句来查询每一条广告的 <code>ctr</code> ，</p><p> <code>ctr</code> 要保留两位小数。结果需要按 <code>ctr</code> <strong>降序</strong>、按 <code>ad_id</code> <strong>升序</strong> 进行排序。</p><p>查询结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Ads 表:</span><br><span class="line">+-------+---------+---------+</span><br><span class="line">| ad_id | user_id | action  |</span><br><span class="line">+-------+---------+---------+</span><br><span class="line">| 1     | 1       | Clicked |</span><br><span class="line">| 2     | 2       | Clicked |</span><br><span class="line">| 3     | 3       | Viewed  |</span><br><span class="line">| 5     | 5       | Ignored |</span><br><span class="line">| 1     | 7       | Ignored |</span><br><span class="line">| 2     | 7       | Viewed  |</span><br><span class="line">| 3     | 5       | Clicked |</span><br><span class="line">| 1     | 4       | Viewed  |</span><br><span class="line">| 2     | 11      | Viewed  |</span><br><span class="line">| 1     | 2       | Clicked |</span><br><span class="line">+-------+---------+---------+</span><br><span class="line">结果表:</span><br><span class="line">+-------+-------+</span><br><span class="line">| ad_id | ctr   |</span><br><span class="line">+-------+-------+</span><br><span class="line">| 1     | 66.67 |</span><br><span class="line">| 3     | 50.00 |</span><br><span class="line">| 2     | 33.33 |</span><br><span class="line">| 5     | 0.00  |</span><br><span class="line">+-------+-------+</span><br><span class="line">对于 ad_id = 1, ctr = (2/(2+1)) * 100 = 66.67</span><br><span class="line">对于 ad_id = 2, ctr = (1/(1+2)) * 100 = 33.33</span><br><span class="line">对于 ad_id = 3, ctr = (1/(1+1)) * 100 = 50.00</span><br><span class="line">对于 ad_id = 5, ctr = 0.00, 注意 ad_id = 5 没有被点击 (Clicked) 或查看 (Viewed) 过</span><br><span class="line">注意我们不关心 action 为 Ingnored 的广告</span><br><span class="line">结果按 ctr（降序），ad_id（升序）排序</span><br></pre></td></tr></table></figure><p>精简</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ad_id,</span><br><span class="line">    ROUND(IFNULL(<span class="built_in">SUM</span>(action <span class="operator">=</span> <span class="string">&#x27;Clicked&#x27;</span>) <span class="operator">/</span></span><br><span class="line">        (<span class="built_in">SUM</span>(action <span class="operator">=</span> <span class="string">&#x27;Clicked&#x27;</span>) <span class="operator">+</span> <span class="built_in">SUM</span>(action <span class="operator">=</span> <span class="string">&#x27;Viewed&#x27;</span>)) <span class="operator">*</span> <span class="number">100</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="keyword">AS</span> ctr</span><br><span class="line"><span class="keyword">FROM</span> Ads</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ad_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ctr <span class="keyword">DESC</span>, ad_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>笨方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.ad_id,ifnull(ctr,<span class="number">0</span>) ctr</span><br><span class="line"><span class="keyword">from</span> Ads a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> ad_id,round(<span class="built_in">sum</span>(if(action<span class="operator">=</span><span class="string">&#x27;Clicked&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">*</span><span class="number">100</span>,<span class="number">2</span>) ctr </span><br><span class="line">    <span class="keyword">from</span> Ads </span><br><span class="line">    <span class="keyword">where</span> action <span class="operator">!=</span><span class="string">&#x27;Ignored&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> ad_id</span><br><span class="line">)t1 </span><br><span class="line"><span class="keyword">on</span> a.ad_id<span class="operator">=</span> t1.ad_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ad_id,ctr</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ctr <span class="keyword">desc</span>,ad_id</span><br></pre></td></tr></table></figure><h4 id="1327-列出指定时间段内所有的下单产品"><a href="#1327-列出指定时间段内所有的下单产品" class="headerlink" title="1327. 列出指定时间段内所有的下单产品"></a><a href="https://leetcode-cn.com/problems/list-the-products-ordered-in-a-period/">1327. 列出指定时间段内所有的下单产品</a></h4><p>难度简单</p><p>SQL架构</p><p>表: <code>Products</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| product_id       | int     |</span><br><span class="line">| product_name     | varchar |</span><br><span class="line">| product_category | varchar |</span><br><span class="line">+------------------+---------+</span><br><span class="line">product_id 是该表主键。</span><br><span class="line">该表包含该公司产品的数据。</span><br></pre></td></tr></table></figure><p>表: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| unit          | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表无主键，可能包含重复行。</span><br><span class="line">product_id 是表单 Products 的外键。</span><br><span class="line">unit 是在日期 order_date 内下单产品的数目。</span><br></pre></td></tr></table></figure><p>写一个 SQL 语句，要求获取在 2020 年 2 月份下单的数量不少于 100 的产品的名字和数目。</p><p>返回结果表单的顺序无要求。</p><p>查询结果的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Products 表:</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line">| product_id  | product_name          | product_category |</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line">| 1           | Leetcode Solutions    | Book             |</span><br><span class="line">| 2           | Jewels of Stringology | Book             |</span><br><span class="line">| 3           | HP                    | Laptop           |</span><br><span class="line">| 4           | Lenovo                | Laptop           |</span><br><span class="line">| 5           | Leetcode Kit          | T-shirt          |</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line"></span><br><span class="line">Orders 表:</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| product_id   | order_date   | unit     |</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| 1            | 2020-02-05   | 60       |</span><br><span class="line">| 1            | 2020-02-10   | 70       |</span><br><span class="line">| 2            | 2020-01-18   | 30       |</span><br><span class="line">| 2            | 2020-02-11   | 80       |</span><br><span class="line">| 3            | 2020-02-17   | 2        |</span><br><span class="line">| 3            | 2020-02-24   | 3        |</span><br><span class="line">| 4            | 2020-03-01   | 20       |</span><br><span class="line">| 4            | 2020-03-04   | 30       |</span><br><span class="line">| 4            | 2020-03-04   | 60       |</span><br><span class="line">| 5            | 2020-02-25   | 50       |</span><br><span class="line">| 5            | 2020-02-27   | 50       |</span><br><span class="line">| 5            | 2020-03-01   | 50       |</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| product_name       | unit    |</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| Leetcode Solutions | 130     |</span><br><span class="line">| Leetcode Kit       | 100     |</span><br><span class="line">+--------------------+---------+</span><br><span class="line"></span><br><span class="line">2020 年 2 月份下单 product_id = 1 的产品的数目总和为 (60 + 70) = 130 。</span><br><span class="line">2020 年 2 月份下单 product_id = 2 的产品的数目总和为 80 。</span><br><span class="line">2020 年 2 月份下单 product_id = 3 的产品的数目总和为 (2 + 3) = 5 。</span><br><span class="line">2020 年 2 月份 product_id = 4 的产品并没有下单。</span><br><span class="line">2020 年 2 月份下单 product_id = 5 的产品的数目总和为 (50 + 50) = 100 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_name,<span class="built_in">sum</span>(unit) unit </span><br><span class="line"><span class="keyword">from</span> Orders o <span class="keyword">left</span> <span class="keyword">join</span> Products p</span><br><span class="line"><span class="keyword">on</span> o.product_id<span class="operator">=</span>p.product_id</span><br><span class="line"><span class="keyword">where</span> date_format(order_date,<span class="string">&#x27;%Y-%m&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2020-02&#x27;</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_name</span><br><span class="line"><span class="keyword">having</span> unit<span class="operator">&gt;=</span><span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="1336-每次访问的交易次数"><a href="#1336-每次访问的交易次数" class="headerlink" title="1336. 每次访问的交易次数"></a><a href="https://leetcode-cn.com/problems/number-of-transactions-per-visit/">1336. 每次访问的交易次数</a></h4><p>难度困难</p><p>SQL架构</p><p>表: <code>Visits</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| visit_date    | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(user_id, visit_date) 是该表的主键</span><br><span class="line">该表的每行表示 user_id 在 visit_date 访问了银行</span><br></pre></td></tr></table></figure><p>表: <code>Transactions</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| user_id          | int     |</span><br><span class="line">| transaction_date | date    |</span><br><span class="line">| amount           | int     |</span><br><span class="line">+------------------+---------+</span><br><span class="line">该表没有主键，所以可能有重复行</span><br><span class="line">该表的每一行表示 user_id 在 transaction_date 完成了一笔 amount 数额的交易</span><br><span class="line">可以保证用户 (user) 在 transaction_date 访问了银行 (也就是说 Visits 表包含 (user_id, transaction_date) 行)</span><br></pre></td></tr></table></figure><p>银行想要得到银行客户在一次访问时的交易次数和相应的在一次访问时该交易次数的客户数量的图表</p><p>写一条 SQL 查询多少客户访问了银行但没有进行任何交易，多少客户访问了银行进行了一次交易等等</p><p>结果包含两列：</p><ul><li><code>transactions_count：</code> 客户在一次访问中的交易次数</li><li><code>visits_count：</code> 在 <code>transactions_count</code> 交易次数下相应的一次访问时的客户数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactions_count` 的值从 `0` 到所有用户一次访问中的 `max(transactions_count)</span><br></pre></td></tr></table></figure><p>按 <code>transactions_count</code> 排序</p><p>下面是查询结果格式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Visits 表:</span><br><span class="line">+---------+------------+</span><br><span class="line">| user_id | visit_date |</span><br><span class="line">+---------+------------+</span><br><span class="line">| 1       | 2020-01-01 |</span><br><span class="line">| 2       | 2020-01-02 |</span><br><span class="line">| 12      | 2020-01-01 |</span><br><span class="line">| 19      | 2020-01-03 |</span><br><span class="line">| 1       | 2020-01-02 |</span><br><span class="line">| 2       | 2020-01-03 |</span><br><span class="line">| 1       | 2020-01-04 |</span><br><span class="line">| 7       | 2020-01-11 |</span><br><span class="line">| 9       | 2020-01-25 |</span><br><span class="line">| 8       | 2020-01-28 |</span><br><span class="line">+---------+------------+</span><br><span class="line">Transactions 表:</span><br><span class="line">+---------+------------------+--------+</span><br><span class="line">| user_id | transaction_date | amount |</span><br><span class="line">+---------+------------------+--------+</span><br><span class="line">| 1       | 2020-01-02       | 120    |</span><br><span class="line">| 2       | 2020-01-03       | 22     |</span><br><span class="line">| 7       | 2020-01-11       | 232    |</span><br><span class="line">| 1       | 2020-01-04       | 7      |</span><br><span class="line">| 9       | 2020-01-25       | 33     |</span><br><span class="line">| 9       | 2020-01-25       | 66     |</span><br><span class="line">| 8       | 2020-01-28       | 1      |</span><br><span class="line">| 9       | 2020-01-25       | 99     |</span><br><span class="line">+---------+------------------+--------+</span><br><span class="line">结果表:</span><br><span class="line">+--------------------+--------------+</span><br><span class="line">| transactions_count | visits_count |</span><br><span class="line">+--------------------+--------------+</span><br><span class="line">| 0                  | 4            |</span><br><span class="line">| 1                  | 5            |</span><br><span class="line">| 2                  | 0            |</span><br><span class="line">| 3                  | 1            |</span><br><span class="line">+--------------------+--------------+</span><br><span class="line">* 对于 transactions_count = 0, visits 中 (1, &quot;2020-01-01&quot;), (2, &quot;2020-01-02&quot;), (12, &quot;2020-01-01&quot;) 和 (19, &quot;2020-01-03&quot;) 没有进行交易，所以 visits_count = 4 。</span><br><span class="line">* 对于 transactions_count = 1, visits 中 (2, &quot;2020-01-03&quot;), (7, &quot;2020-01-11&quot;), (8, &quot;2020-01-28&quot;), (1, &quot;2020-01-02&quot;) 和 (1, &quot;2020-01-04&quot;) 进行了一次交易，所以 visits_count = 5 。</span><br><span class="line">* 对于 transactions_count = 2, 没有客户访问银行进行了两次交易，所以 visits_count = 0 。</span><br><span class="line">* 对于 transactions_count = 3, visits 中 (9, &quot;2020-01-25&quot;) 进行了三次交易，所以 visits_count = 1 。</span><br><span class="line">* 对于 transactions_count &gt;= 4, 没有客户访问银行进行了超过3次交易，所以我们停止在 transactions_count = 3 。</span><br><span class="line"></span><br><span class="line">如下是这个例子的图表：</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> t5.rnb <span class="keyword">AS</span> transactions_count, IFNULL(visits_count, <span class="number">0</span>) <span class="keyword">AS</span> visits_count</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> rnb</span><br><span class="line">        <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> () <span class="keyword">AS</span> rnb</span><br><span class="line">        <span class="keyword">FROM</span> Transactions</span><br><span class="line">    ) t5</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            cnt <span class="keyword">AS</span> transactions_count</span><br><span class="line">            ,<span class="built_in">COUNT</span>(user_id) <span class="keyword">AS</span> visits_count</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">SELECT</span> t1.user_id, <span class="built_in">COUNT</span>(t2.amount) <span class="keyword">AS</span> cnt</span><br><span class="line">            <span class="keyword">FROM</span> Visits t1</span><br><span class="line">            <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Transactions t2</span><br><span class="line">            <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t2.user_id <span class="keyword">AND</span> t1.visit_date <span class="operator">=</span> t2.transaction_date</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id, visit_date</span><br><span class="line">        ) t3</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> cnt</span><br><span class="line">    ) t4</span><br><span class="line">    <span class="keyword">ON</span> t5.rnb <span class="operator">=</span> t4.transactions_count</span><br><span class="line">) t6</span><br><span class="line"><span class="keyword">WHERE</span> transactions_count <span class="operator">&lt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(t2.amount) <span class="keyword">AS</span> cnt</span><br><span class="line">    <span class="keyword">FROM</span> Visits t1</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Transactions t2</span><br><span class="line">    <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t2.user_id <span class="keyword">AND</span> t1.visit_date <span class="operator">=</span> t2.transaction_date</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.user_id, visit_date</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span></span><br><span class="line">    LIMIT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>难点 从0自增序列，2交易的人数为0</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pcnt transactions_count,<span class="built_in">count</span>(<span class="operator">*</span>) visits_count</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> visit_date,</span><br><span class="line">        <span class="built_in">sum</span>(if(amount <span class="keyword">is</span>  <span class="keyword">null</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> transaction_date ) pcnt,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span>  visit_date ) tcnt</span><br><span class="line"><span class="keyword">from</span> Visits v <span class="keyword">left</span> <span class="keyword">join</span> Transactions t</span><br><span class="line"><span class="keyword">on</span> v.user_id<span class="operator">=</span> t.user_id <span class="keyword">and</span> v.visit_date<span class="operator">=</span>t.transaction_date</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> pcnt</span><br></pre></td></tr></table></figure><p>这个得出结果是[0, 4], [1, 5], [3, 3] 少了[2,0] 还没想到什么好办法能把[2，0]加进去。。。</p><h4 id="1341-电影评分"><a href="#1341-电影评分" class="headerlink" title="1341. 电影评分"></a><a href="https://leetcode-cn.com/problems/movie-rating/">1341. 电影评分</a></h4><p>难度中等</p><p>SQL架构</p><p>表：<code>Movies</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| movie_id      | int     |</span><br><span class="line">| title         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">movie_id 是这个表的主键。</span><br><span class="line">title 是电影的名字。</span><br></pre></td></tr></table></figure><p>表：<code>Users</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">user_id 是表的主键。</span><br></pre></td></tr></table></figure><p>表：<code>Movie_Rating</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| movie_id      | int     |</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| rating        | int     |</span><br><span class="line">| created_at    | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(movie_id, user_id) 是这个表的主键。</span><br><span class="line">这个表包含用户在其评论中对电影的评分 rating 。</span><br><span class="line">created_at 是用户的点评日期。 </span><br></pre></td></tr></table></figure><p>请你编写一组 SQL 查询：</p><ul><li><p>查找评论电影数量最多的用户名。</p><p>如果出现平局，返回字典序较小的用户名。</p></li><li><p>查找在</p><p>2020 年 2 月 平均评分最高</p><p>的电影名称。</p><p>如果出现平局，返回字典序较小的电影名称。</p></li></ul><p>查询分两行返回，查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Movies 表：</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| movie_id    |  title       |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| 1           | Avengers     |</span><br><span class="line">| 2           | Frozen 2     |</span><br><span class="line">| 3           | Joker        |</span><br><span class="line">+-------------+--------------+</span><br><span class="line"></span><br><span class="line">Users 表：</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| user_id     |  name        |</span><br><span class="line">+-------------+--------------+</span><br><span class="line">| 1           | Daniel       |</span><br><span class="line">| 2           | Monica       |</span><br><span class="line">| 3           | Maria        |</span><br><span class="line">| 4           | James        |</span><br><span class="line">+-------------+--------------+</span><br><span class="line"></span><br><span class="line">Movie_Rating 表：</span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line">| movie_id    | user_id      | rating       | created_at  |</span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line">| 1           | 1            | 3            | 2020-01-12  |</span><br><span class="line">| 1           | 2            | 4            | 2020-02-11  |</span><br><span class="line">| 1           | 3            | 2            | 2020-02-12  |</span><br><span class="line">| 1           | 4            | 1            | 2020-01-01  |</span><br><span class="line">| 2           | 1            | 5            | 2020-02-17  | </span><br><span class="line">| 2           | 2            | 2            | 2020-02-01  | </span><br><span class="line">| 2           | 3            | 2            | 2020-03-01  |</span><br><span class="line">| 3           | 1            | 3            | 2020-02-22  | </span><br><span class="line">| 3           | 2            | 4            | 2020-02-25  | </span><br><span class="line">+-------------+--------------+--------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+</span><br><span class="line">| results      |</span><br><span class="line">+--------------+</span><br><span class="line">| Daniel       |</span><br><span class="line">| Frozen 2     |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line">Daniel 和 Monica 都点评了 3 部电影（&quot;Avengers&quot;, &quot;Frozen 2&quot; 和 &quot;Joker&quot;） 但是 Daniel 字典序比较小。</span><br><span class="line">Frozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name results </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> m.user_id ,u.name </span><br><span class="line">    <span class="keyword">from</span> Movie_Rating m <span class="keyword">left</span> <span class="keyword">join</span> Users u </span><br><span class="line">    <span class="keyword">on</span> m.user_id <span class="operator">=</span> u.user_id</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">desc</span>,name</span><br><span class="line">    limit <span class="number">1</span></span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> title results</span><br><span class="line"><span class="keyword">from</span> Movie_Rating r <span class="keyword">left</span> <span class="keyword">join</span> Movies m</span><br><span class="line"><span class="keyword">on</span> r.movie_id <span class="operator">=</span>m.movie_id </span><br><span class="line"><span class="keyword">where</span> date_format(created_at,<span class="string">&#x27;%Y-%m&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2020-02&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> r.movie_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(rating) <span class="keyword">desc</span>,title </span><br><span class="line">limit <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="1350-院系无效的学生"><a href="#1350-院系无效的学生" class="headerlink" title="1350. 院系无效的学生"></a><a href="https://leetcode-cn.com/problems/students-with-invalid-departments/">1350. 院系无效的学生</a></h4><p>难度简单</p><p>SQL架构</p><p>院系表: <code>Departments</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表的主键</span><br><span class="line">该表包含一所大学每个院系的 id 信息</span><br></pre></td></tr></table></figure><p>学生表: <code>Students</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| department_id | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表的主键</span><br><span class="line">该表包含一所大学每个学生的 id 和他/她就读的院系信息</span><br></pre></td></tr></table></figure><p>写一条 SQL 语句以查询那些所在院系不存在的学生的 id 和姓名</p><p>可以以任何顺序返回结果</p><p>下面是返回结果格式的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Departments 表:</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| id   | name                     |</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| 1    | Electrical Engineering   |</span><br><span class="line">| 7    | Computer Engineering     |</span><br><span class="line">| 13   | Bussiness Administration |</span><br><span class="line">+------+--------------------------+</span><br><span class="line"></span><br><span class="line">Students 表:</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| id   | name     | department_id |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| 23   | Alice    | 1             |</span><br><span class="line">| 1    | Bob      | 7             |</span><br><span class="line">| 5    | Jennifer | 13            |</span><br><span class="line">| 2    | John     | 14            |</span><br><span class="line">| 4    | Jasmine  | 77            |</span><br><span class="line">| 3    | Steve    | 74            |</span><br><span class="line">| 6    | Luis     | 1             |</span><br><span class="line">| 8    | Jonathan | 7             |</span><br><span class="line">| 7    | Daiana   | 33            |</span><br><span class="line">| 11   | Madelynn | 1             |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line"></span><br><span class="line">结果表:</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | name     |</span><br><span class="line">+------+----------+</span><br><span class="line">| 2    | John     |</span><br><span class="line">| 7    | Daiana   |</span><br><span class="line">| 4    | Jasmine  |</span><br><span class="line">| 3    | Steve    |</span><br><span class="line">+------+----------+</span><br><span class="line"></span><br><span class="line">John, Daiana, Steve 和 Jasmine 所在的院系分别是 14, 33, 74 和 77， 其中 14, 33, 74 和 77 并不存在于院系表</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name  </span><br><span class="line"><span class="keyword">from</span> Students </span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">not</span> <span class="keyword">in</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> id </span><br><span class="line">    <span class="keyword">from</span> Departments</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="1355-活动参与者"><a href="#1355-活动参与者" class="headerlink" title="1355. 活动参与者"></a><a href="https://leetcode-cn.com/problems/activity-participants/">1355. 活动参与者</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Friends</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| activity      | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是朋友的 id 和该表的主键</span><br><span class="line">name 是朋友的名字</span><br><span class="line">activity 是朋友参加的活动的名字</span><br></pre></td></tr></table></figure><p>表: <code>Activities</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表的主键</span><br><span class="line">name 是活动的名字</span><br></pre></td></tr></table></figure><p>写一条 SQL 查询那些既没有最多，也没有最少参与者的活动的名字</p><p>可以以任何顺序返回结果，Activities 表的每项活动的参与者都来自 Friends 表</p><p>下面是查询结果格式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Friends 表:</span><br><span class="line">+------+--------------+---------------+</span><br><span class="line">| id   | name         | activity      |</span><br><span class="line">+------+--------------+---------------+</span><br><span class="line">| 1    | Jonathan D.  | Eating        |</span><br><span class="line">| 2    | Jade W.      | Singing       |</span><br><span class="line">| 3    | Victor J.    | Singing       |</span><br><span class="line">| 4    | Elvis Q.     | Eating        |</span><br><span class="line">| 5    | Daniel A.    | Eating        |</span><br><span class="line">| 6    | Bob B.       | Horse Riding  |</span><br><span class="line">+------+--------------+---------------+</span><br><span class="line"></span><br><span class="line">Activities 表:</span><br><span class="line">+------+--------------+</span><br><span class="line">| id   | name         |</span><br><span class="line">+------+--------------+</span><br><span class="line">| 1    | Eating       |</span><br><span class="line">| 2    | Singing      |</span><br><span class="line">| 3    | Horse Riding |</span><br><span class="line">+------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------+</span><br><span class="line">| activity     |</span><br><span class="line">+--------------+</span><br><span class="line">| Singing      |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line">Eating 活动有三个人参加, 是最多人参加的活动 (Jonathan D. , Elvis Q. and Daniel A.)</span><br><span class="line">Horse Riding 活动有一个人参加, 是最少人参加的活动 (Bob B.)</span><br><span class="line">Singing 活动有两个人参加 (Victor J. and Jade W.)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> activity</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> activity,</span><br><span class="line">    <span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> cnt) rk1,</span><br><span class="line">    <span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span>) rk2</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span>  activity  ,<span class="built_in">count</span>(<span class="operator">*</span>) cnt</span><br><span class="line">        <span class="keyword">from</span>  Friends</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span>  activity </span><br><span class="line">    )t1</span><br><span class="line">)t2</span><br><span class="line"><span class="keyword">where</span> rk1 <span class="operator">!=</span><span class="number">1</span> <span class="keyword">and</span> rk2 <span class="operator">!=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>不需要关联 Activities表，因为 至少有一人参加</p></blockquote><h4 id="1364-顾客的可信联系人数量"><a href="#1364-顾客的可信联系人数量" class="headerlink" title="1364. 顾客的可信联系人数量"></a><a href="https://leetcode-cn.com/problems/number-of-trusted-contacts-of-a-customer/">1364. 顾客的可信联系人数量</a></h4><p>难度中等</p><p>SQL架构</p><p>顾客表：<code>Customers</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| customer_name | varchar |</span><br><span class="line">| email         | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">customer_id 是这张表的主键。</span><br><span class="line">此表的每一行包含了某在线商店顾客的姓名和电子邮件。</span><br></pre></td></tr></table></figure><p>联系方式表：<code>Contacts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | id      |</span><br><span class="line">| contact_name  | varchar |</span><br><span class="line">| contact_email | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(user_id, contact_email) 是这张表的主键。</span><br><span class="line">此表的每一行表示编号为 user_id 的顾客的某位联系人的姓名和电子邮件。</span><br><span class="line">此表包含每位顾客的联系人信息，但顾客的联系人不一定存在于顾客表中。</span><br></pre></td></tr></table></figure><p>发票表：<code>Invoices</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| invoice_id   | int     |</span><br><span class="line">| price        | int     |</span><br><span class="line">| user_id      | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">invoice_id 是这张表的主键。</span><br><span class="line">此表的每一行分别表示编号为 user_id 的顾客拥有有一张编号为 invoice_id、价格为 price 的发票。</span><br></pre></td></tr></table></figure><p>为每张发票 <code>invoice_id</code> 编写一个SQL查询以查找以下内容：</p><ul><li><code>customer_name</code>：与发票相关的顾客名称。</li><li><code>price</code>：发票的价格。</li><li><code>contacts_cnt</code>：该顾客的联系人数量。</li><li><code>trusted_contacts_cnt</code>：可信联系人的数量：既是该顾客的联系人又是商店顾客的联系人数量（即：可信联系人的电子邮件存在于客户表中）。</li></ul><p>将查询的结果按照 <code>invoice_id</code> 排序。</p><p>查询结果的格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Customers table:</span><br><span class="line">+-------------+---------------+--------------------+</span><br><span class="line">| customer_id | customer_name | email              |</span><br><span class="line">+-------------+---------------+--------------------+</span><br><span class="line">| 1           | Alice         | alice@leetcode.com |</span><br><span class="line">| 2           | Bob           | bob@leetcode.com   |</span><br><span class="line">| 13          | John          | john@leetcode.com  |</span><br><span class="line">| 6           | Alex          | alex@leetcode.com  |</span><br><span class="line">+-------------+---------------+--------------------+</span><br><span class="line">Contacts table:</span><br><span class="line">+-------------+--------------+--------------------+</span><br><span class="line">| user_id     | contact_name | contact_email      |</span><br><span class="line">+-------------+--------------+--------------------+</span><br><span class="line">| 1           | Bob          | bob@leetcode.com   |</span><br><span class="line">| 1           | John         | john@leetcode.com  |</span><br><span class="line">| 1           | Jal          | jal@leetcode.com   |</span><br><span class="line">| 2           | Omar         | omar@leetcode.com  |</span><br><span class="line">| 2           | Meir         | meir@leetcode.com  |</span><br><span class="line">| 6           | Alice        | alice@leetcode.com |</span><br><span class="line">+-------------+--------------+--------------------+</span><br><span class="line">Invoices table:</span><br><span class="line">+------------+-------+---------+</span><br><span class="line">| invoice_id | price | user_id |</span><br><span class="line">+------------+-------+---------+</span><br><span class="line">| 77         | 100   | 1       |</span><br><span class="line">| 88         | 200   | 1       |</span><br><span class="line">| 99         | 300   | 2       |</span><br><span class="line">| 66         | 400   | 2       |</span><br><span class="line">| 55         | 500   | 13      |</span><br><span class="line">| 44         | 60    | 6       |</span><br><span class="line">+------------+-------+---------+</span><br><span class="line">Result table:</span><br><span class="line">+------------+---------------+-------+--------------+----------------------+</span><br><span class="line">| invoice_id | customer_name | price | contacts_cnt | trusted_contacts_cnt |</span><br><span class="line">+------------+---------------+-------+--------------+----------------------+</span><br><span class="line">| 44         | Alex          | 60    | 1            | 1                    |</span><br><span class="line">| 55         | John          | 500   | 0            | 0                    |</span><br><span class="line">| 66         | Bob           | 400   | 2            | 0                    |</span><br><span class="line">| 77         | Alice         | 100   | 3            | 2                    |</span><br><span class="line">| 88         | Alice         | 200   | 3            | 2                    |</span><br><span class="line">| 99         | Bob           | 300   | 2            | 0                    |</span><br><span class="line">+------------+---------------+-------+--------------+----------------------+</span><br><span class="line">Alice 有三位联系人，其中两位(Bob 和 John)是可信联系人。</span><br><span class="line">Bob 有两位联系人, 他们中的任何一位都不是可信联系人。</span><br><span class="line">Alex 只有一位联系人(Alice)，并是一位可信联系人。</span><br><span class="line">John 没有任何联系人。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> invoice_id ,customer_name,price,ifnull(cnt,<span class="number">0</span>) contacts_cnt,ifnull(bc,<span class="number">0</span>) trusted_contacts_cnt </span><br><span class="line"><span class="keyword">from</span> Invoices i</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span> user_id ,<span class="built_in">count</span>(<span class="operator">*</span>) cnt</span><br><span class="line"><span class="keyword">from</span> Contacts</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">on</span> i.user_id<span class="operator">=</span>t1.user_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">select</span>  user_id ,<span class="built_in">count</span>(<span class="operator">*</span>) bc</span><br><span class="line"><span class="keyword">from</span> Contacts</span><br><span class="line">    <span class="keyword">where</span> contact_name <span class="keyword">in</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> customer_name</span><br><span class="line">        <span class="keyword">from</span> Customers</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id </span><br><span class="line">)t2</span><br><span class="line"><span class="keyword">on</span> i.user_id <span class="operator">=</span> t2.user_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Customers c</span><br><span class="line"><span class="keyword">on</span> i.user_id<span class="operator">=</span> c.customer_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> invoice_id</span><br></pre></td></tr></table></figure><blockquote><p>就是麻烦点 各种join</p></blockquote><h4 id="1369-获取最近第二次的活动"><a href="#1369-获取最近第二次的活动" class="headerlink" title="1369. 获取最近第二次的活动"></a><a href="https://leetcode-cn.com/problems/get-the-second-most-recent-activity/">1369. 获取最近第二次的活动</a></h4><p>难度困难</p><p>SQL架构</p><p>表: <code>UserActivity</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| username      | varchar |</span><br><span class="line">| activity      | varchar |</span><br><span class="line">| startDate     | Date    |</span><br><span class="line">| endDate       | Date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表不包含主键</span><br><span class="line">该表包含每个用户在一段时间内进行的活动的信息</span><br><span class="line">名为 username 的用户在 startDate 到 endDate 日内有一次活动</span><br></pre></td></tr></table></figure><p>写一条SQL查询展示每一位用户 <strong>最近第二次</strong> 的活动</p><p>如果用户仅有一次活动，返回该活动</p><p>一个用户不能同时进行超过一项活动，以 <strong>任意</strong> 顺序返回结果</p><p>下面是查询结果格式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UserActivity 表:</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line">| username   | activity     | startDate   | endDate     |</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line">| Alice      | Travel       | 2020-02-12  | 2020-02-20  |</span><br><span class="line">| Alice      | Dancing      | 2020-02-21  | 2020-02-23  |</span><br><span class="line">| Alice      | Travel       | 2020-02-24  | 2020-02-28  |</span><br><span class="line">| Bob        | Travel       | 2020-02-11  | 2020-02-18  |</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line">| username   | activity     | startDate   | endDate     |</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line">| Alice      | Dancing      | 2020-02-21  | 2020-02-23  |</span><br><span class="line">| Bob        | Travel       | 2020-02-11  | 2020-02-18  |</span><br><span class="line">+------------+--------------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Alice 最近第二次的活动是从 2020-02-24 到 2020-02-28 的旅行, 在此之前的 2020-02-21 到 2020-02-23 她进行了舞蹈</span><br><span class="line">Bob 只有一条记录，我们就取这条记录</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, activity ,startDate,endDate </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> username, activity ,startDate,endDate ,</span><br><span class="line">    <span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> username <span class="keyword">order</span> <span class="keyword">by</span> startDate <span class="keyword">desc</span>) rk,</span><br><span class="line">    <span class="built_in">lag</span>( startDate ,<span class="number">1</span>,<span class="keyword">null</span>)<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> username <span class="keyword">order</span> <span class="keyword">by</span> startDate ) lg</span><br><span class="line"><span class="keyword">from</span> UserActivity</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">=</span><span class="number">2</span> <span class="keyword">or</span>  (rk <span class="operator">=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span>  lg <span class="keyword">is</span> <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><h4 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378. 使用唯一标识码替换员工ID"></a><a href="https://leetcode-cn.com/problems/replace-employee-id-with-the-unique-identifier/">1378. 使用唯一标识码替换员工ID</a></h4><p>难度简单</p><p>SQL架构</p><p><code>Employees</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是这张表的主键。</span><br><span class="line">这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。</span><br></pre></td></tr></table></figure><p><code>EmployeeUNI</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, unique_id) 是这张表的主键。</span><br><span class="line">这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。</span><br></pre></td></tr></table></figure><p>写一段SQL查询来展示每位用户的 <strong>唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p><p>你可以以 <strong>任意</strong> 顺序返回结果表。</p><p>查询结果的格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Employees table:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line"></span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> unique_id,e.name</span><br><span class="line"><span class="keyword">from</span> Employees  e <span class="keyword">left</span> <span class="keyword">join</span> EmployeeUNI u</span><br><span class="line"><span class="keyword">on</span> e.id <span class="operator">=</span> u.id</span><br></pre></td></tr></table></figure><h4 id="1384-按年度列出销售总额"><a href="#1384-按年度列出销售总额" class="headerlink" title="1384. 按年度列出销售总额"></a><a href="https://leetcode-cn.com/problems/total-sales-amount-by-year/">1384. 按年度列出销售总额</a></h4><p>难度困难</p><p>SQL架构</p><p> <code>Product</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| product_name  | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">product_id 是这张表的主键。</span><br><span class="line">product_name 是产品的名称。</span><br></pre></td></tr></table></figure><p><code>Sales</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------+</span><br><span class="line">| Column Name         | Type    |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">| product_id          | int     |</span><br><span class="line">| period_start        | varchar |</span><br><span class="line">| period_end          | date    |</span><br><span class="line">| average_daily_sales | int     |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">product_id 是这张表的主键。</span><br><span class="line">period_start 和 period_end 是该产品销售期的起始日期和结束日期，且这两个日期包含在销售期内。</span><br><span class="line">average_daily_sales 列存储销售期内该产品的日平均销售额。</span><br></pre></td></tr></table></figure><p>编写一段SQL查询每个产品每年的总销售额，并包含 product_id, product_name 以及 report_year 等信息。</p><p>销售年份的日期介于 2018 年到 2020 年之间。你返回的结果需要按 product_id 和 report_year <strong>排序</strong>。</p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Product table:</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 1          | LC Phone     |</span><br><span class="line">| 2          | LC T-Shirt   |</span><br><span class="line">| 3          | LC Keychain  |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Sales table:</span><br><span class="line">+------------+--------------+-------------+---------------------+</span><br><span class="line">| product_id | period_start | period_end  | average_daily_sales |</span><br><span class="line">+------------+--------------+-------------+---------------------+</span><br><span class="line">| 1          | 2019-01-25   | 2019-02-28  | 100                 |</span><br><span class="line">| 2          | 2018-12-01   | 2020-01-01  | 10                  |</span><br><span class="line">| 3          | 2019-12-01   | 2020-01-31  | 1                   |</span><br><span class="line">+------------+--------------+-------------+---------------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+--------------+-------------+--------------+</span><br><span class="line">| product_id | product_name | report_year | total_amount |</span><br><span class="line">+------------+--------------+-------------+--------------+</span><br><span class="line">| 1          | LC Phone     |    2019     | 3500         |</span><br><span class="line">| 2          | LC T-Shirt   |    2018     | 310          |</span><br><span class="line">| 2          | LC T-Shirt   |    2019     | 3650         |</span><br><span class="line">| 2          | LC T-Shirt   |    2020     | 10           |</span><br><span class="line">| 3          | LC Keychain  |    2019     | 31           |</span><br><span class="line">| 3          | LC Keychain  |    2020     | 31           |</span><br><span class="line">+------------+--------------+-------------+--------------+</span><br><span class="line">LC Phone 在 2019-01-25 至 2019-02-28 期间销售，该产品销售时间总计35天。销售总额 35*100 = 3500。</span><br><span class="line">LC T-shirt 在 2018-12-01 至 2020-01-01 期间销售，该产品在2018年、2019年、2020年的销售时间分别是31天、365天、1天，2018年、2019年、2020年的销售总额分别是31*10=310、365*10=3650、1*10=10。</span><br><span class="line">LC Keychain 在 2019-12-01 至 2020-01-31 期间销售，该产品在2019年、2020年的销售时间分别是：31天、31天，2019年、2020年的销售总额分别是31*1=31、31*1=31。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> <span class="keyword">select</span> Sales.product_id, product_name, <span class="string">&#x27;2018&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;report_year&#x27;</span>, if(period_start<span class="operator">&lt;</span><span class="string">&#x27;2019-01-01&#x27;</span>, (datediff(if(period_end<span class="operator">&lt;</span><span class="string">&#x27;2019-01-01&#x27;</span>, period_end, <span class="type">date</span>(<span class="string">&#x27;2018-12-31&#x27;</span>)), if(period_start<span class="operator">&gt;=</span><span class="string">&#x27;2018-01-01&#x27;</span>, period_start, <span class="type">date</span>(<span class="string">&#x27;2018-01-01&#x27;</span>)))<span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>average_daily_sales, <span class="number">0</span>) <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> Sales  </span><br><span class="line"><span class="keyword">join</span> Product <span class="keyword">on</span> Sales.product_id <span class="operator">=</span> Product.product_id </span><br><span class="line"><span class="keyword">having</span>  total_amount<span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">union</span>(</span><br><span class="line"><span class="keyword">select</span> Sales.product_id, product_name, <span class="string">&#x27;2019&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;report_year&#x27;</span>, if( period_start<span class="operator">&lt;</span><span class="string">&#x27;2020-01-01&#x27;</span>, (datediff(if(period_end<span class="operator">&lt;</span><span class="string">&#x27;2020-01-01&#x27;</span>, period_end, <span class="type">date</span>(<span class="string">&#x27;2019-12-31&#x27;</span>)), if(period_start<span class="operator">&gt;=</span><span class="string">&#x27;2019-01-01&#x27;</span>, period_start, <span class="type">date</span>(<span class="string">&#x27;2019-01-01&#x27;</span>)))<span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>average_daily_sales , <span class="number">0</span>) <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> Sales  </span><br><span class="line"><span class="keyword">join</span> Product <span class="keyword">on</span> (Sales.product_id <span class="operator">=</span> Product.product_id )</span><br><span class="line"><span class="keyword">having</span>  total_amount<span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">union</span>(</span><br><span class="line"><span class="keyword">select</span> Sales.product_id, product_name, <span class="string">&#x27;2020&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;report_year&#x27;</span>, (datediff(if(period_end<span class="operator">&lt;</span><span class="string">&#x27;2021-01-01&#x27;</span>, period_end, <span class="type">date</span>(<span class="string">&#x27;2020-12-31&#x27;</span>)), if(period_start<span class="operator">&gt;=</span><span class="string">&#x27;2020-01-01&#x27;</span>, period_start, <span class="type">date</span>(<span class="string">&#x27;2020-01-01&#x27;</span>)))<span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>average_daily_sales <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> Sales  </span><br><span class="line"><span class="keyword">join</span> Product  <span class="keyword">on</span> (Sales.product_id <span class="operator">=</span> Product.product_id)</span><br><span class="line"><span class="keyword">having</span> total_amount<span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> product_id, report_year</span><br></pre></td></tr></table></figure><blockquote><p>各个年份进行union,就是年份判断的时候麻烦些</p></blockquote><h4 id="1393-股票的资本损益"><a href="#1393-股票的资本损益" class="headerlink" title="1393. 股票的资本损益"></a><a href="https://leetcode-cn.com/problems/capital-gainloss/">1393. 股票的资本损益</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Stocks</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| stock_name    | varchar |</span><br><span class="line">| operation     | enum    |</span><br><span class="line">| operation_day | int     |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(stock_name, day) 是这张表的主键</span><br><span class="line">operation 列使用的是一种枚举类型，包括：(&#x27;Sell&#x27;,&#x27;Buy&#x27;)</span><br><span class="line">此表的每一行代表了名为 stock_name 的某支股票在 operation_day 这一天的操作价格。</span><br><span class="line">保证股票的每次&#x27;Sell&#x27;操作前，都有相应的&#x27;Buy&#x27;操作。</span><br></pre></td></tr></table></figure><p>编写一个SQL查询来报告每支股票的资本损益。</p><p>股票的资本损益是一次或多次买卖股票后的全部收益或损失。</p><p>以任意顺序返回结果即可。</p><p>SQL查询结果的格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stocks 表:</span><br><span class="line">+---------------+-----------+---------------+--------+</span><br><span class="line">| stock_name    | operation | operation_day | price  |</span><br><span class="line">+---------------+-----------+---------------+--------+</span><br><span class="line">| Leetcode      | Buy       | 1             | 1000   |</span><br><span class="line">| Corona Masks  | Buy       | 2             | 10     |</span><br><span class="line">| Leetcode      | Sell      | 5             | 9000   |</span><br><span class="line">| Handbags      | Buy       | 17            | 30000  |</span><br><span class="line">| Corona Masks  | Sell      | 3             | 1010   |</span><br><span class="line">| Corona Masks  | Buy       | 4             | 1000   |</span><br><span class="line">| Corona Masks  | Sell      | 5             | 500    |</span><br><span class="line">| Corona Masks  | Buy       | 6             | 1000   |</span><br><span class="line">| Handbags      | Sell      | 29            | 7000   |</span><br><span class="line">| Corona Masks  | Sell      | 10            | 10000  |</span><br><span class="line">+---------------+-----------+---------------+--------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+---------------+-------------------+</span><br><span class="line">| stock_name    | capital_gain_loss |</span><br><span class="line">+---------------+-------------------+</span><br><span class="line">| Corona Masks  | 9500              |</span><br><span class="line">| Leetcode      | 8000              |</span><br><span class="line">| Handbags      | -23000            |</span><br><span class="line">+---------------+-------------------+</span><br><span class="line">Leetcode 股票在第一天以1000美元的价格买入，在第五天以9000美元的价格卖出。资本收益=9000-1000=8000美元。</span><br><span class="line">Handbags 股票在第17天以30000美元的价格买入，在第29天以7000美元的价格卖出。资本损失=7000-30000=-23000美元。</span><br><span class="line">Corona Masks 股票在第1天以10美元的价格买入，在第3天以1010美元的价格卖出。在第4天以1000美元的价格再次购买，在第5天以500美元的价格出售。最后，它在第6天以1000美元的价格被买走，在第10天以10000美元的价格被卖掉。资本损益是每次（’Buy&#x27;-&gt;&#x27;Sell&#x27;）操作资本收益或损失的和=（1010-10）+（500-1000）+（10000-1000）=1000-500+9000=9500美元。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock_name,sell<span class="operator">-</span>buy capital_gain_loss</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> stock_name ,</span><br><span class="line">       <span class="built_in">sum</span>(if(operation<span class="operator">=</span><span class="string">&#x27;Buy&#x27;</span>, price,<span class="number">0</span>))<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> stock_name ) buy,</span><br><span class="line">       <span class="built_in">sum</span>(if(operation<span class="operator">=</span><span class="string">&#x27;Sell&#x27;</span>,price,<span class="number">0</span>))<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> stock_name) sell</span><br><span class="line"><span class="keyword">from</span> Stocks s</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stock_name,buy,sell</span><br></pre></td></tr></table></figure><h4 id="1398-购买了产品A和产品B却没有购买产品C的顾客"><a href="#1398-购买了产品A和产品B却没有购买产品C的顾客" class="headerlink" title="1398. 购买了产品A和产品B却没有购买产品C的顾客"></a><a href="https://leetcode-cn.com/problems/customers-who-bought-products-a-and-b-but-not-c/">1398. 购买了产品A和产品B却没有购买产品C的顾客</a></h4><p>难度中等</p><p>SQL架构</p><p> <code>Customers</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------+</span><br><span class="line">| Column Name         | Type    |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">| customer_id         | int     |</span><br><span class="line">| customer_name       | varchar |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">customer_id 是这张表的主键。</span><br><span class="line">customer_name 是顾客的名称。</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| product_name  | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">order_id 是这张表的主键。</span><br><span class="line">customer_id 是购买了名为 &quot;product_name&quot; 产品顾客的id。</span><br></pre></td></tr></table></figure><p>请你设计 SQL 查询来报告购买了产品 A 和产品 B 却没有购买产品 C 的顾客的 ID 和姓名（ <code>customer_id</code> 和 <code>customer_name</code> ），我们将基于此结果为他们推荐产品 C 。<br>您返回的查询结果需要按照 <code>customer_id</code> <strong>排序</strong>。</p><p>查询结果如下例所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Customers table:</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| customer_id | customer_name |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 1           | Daniel        |</span><br><span class="line">| 2           | Diana         |</span><br><span class="line">| 3           | Elizabeth     |</span><br><span class="line">| 4           | Jhon          |</span><br><span class="line">+-------------+---------------+</span><br><span class="line"></span><br><span class="line">Orders table:</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| order_id   | customer_id  | product_name  |</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| 10         |     1        |     A         |</span><br><span class="line">| 20         |     1        |     B         |</span><br><span class="line">| 30         |     1        |     D         |</span><br><span class="line">| 40         |     1        |     C         |</span><br><span class="line">| 50         |     2        |     A         |</span><br><span class="line">| 60         |     3        |     A         |</span><br><span class="line">| 70         |     3        |     B         |</span><br><span class="line">| 80         |     3        |     D         |</span><br><span class="line">| 90         |     4        |     C         |</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| customer_id | customer_name |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 3           | Elizabeth     |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">只有 customer_id 为 3 的顾客购买了产品 A 和产品 B ，却没有购买产品 C 。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  o.customer_id, customer_name </span><br><span class="line"><span class="keyword">from</span> Orders o <span class="keyword">left</span> <span class="keyword">join</span>  Customers c</span><br><span class="line"><span class="keyword">on</span> o.customer_id<span class="operator">=</span>c.customer_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(product_name <span class="operator">=</span><span class="string">&#x27;A&#x27;</span>)<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> <span class="built_in">sum</span>(product_name<span class="operator">=</span><span class="string">&#x27;B&#x27;</span>)<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> <span class="built_in">sum</span>(product_name<span class="operator">=</span><span class="string">&#x27;C&#x27;</span>)<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="1407-排名靠前的旅行者"><a href="#1407-排名靠前的旅行者" class="headerlink" title="1407. 排名靠前的旅行者"></a><a href="https://leetcode-cn.com/problems/top-travellers/">1407. 排名靠前的旅行者</a></h4><p>难度简单</p><p>SQL架构</p><p>表单: <code>Users</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表单主键.</span><br><span class="line">name 是用户名字.</span><br></pre></td></tr></table></figure><p>表单: <code>Rides</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| distance      | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表单主键.</span><br><span class="line">user_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance.</span><br></pre></td></tr></table></figure><p>写一段 SQL , 报告每个用户的旅行距离.</p><p>返回的结果表单, 以 <code>travelled_distance</code> 降序排列, 如果有两个或者更多的用户旅行了相同的距离, 那么再以 <code>name</code> 升序排列.</p><p>查询结果格式, 如下例所示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Users 表单:</span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | name      |</span><br><span class="line">+------+-----------+</span><br><span class="line">| 1    | Alice     |</span><br><span class="line">| 2    | Bob       |</span><br><span class="line">| 3    | Alex      |</span><br><span class="line">| 4    | Donald    |</span><br><span class="line">| 7    | Lee       |</span><br><span class="line">| 13   | Jonathan  |</span><br><span class="line">| 19   | Elvis     |</span><br><span class="line">+------+-----------+</span><br><span class="line"></span><br><span class="line">Rides 表单:</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | user_id  | distance |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| 1    | 1        | 120      |</span><br><span class="line">| 2    | 2        | 317      |</span><br><span class="line">| 3    | 3        | 222      |</span><br><span class="line">| 4    | 7        | 100      |</span><br><span class="line">| 5    | 13       | 312      |</span><br><span class="line">| 6    | 19       | 50       |</span><br><span class="line">| 7    | 7        | 120      |</span><br><span class="line">| 8    | 19       | 400      |</span><br><span class="line">| 9    | 7        | 230      |</span><br><span class="line">+------+----------+----------+</span><br><span class="line"></span><br><span class="line">Result 表单:</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| name     | travelled_distance |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| Elvis    | 450                |</span><br><span class="line">| Lee      | 450                |</span><br><span class="line">| Bob      | 317                |</span><br><span class="line">| Jonathan | 312                |</span><br><span class="line">| Alex     | 222                |</span><br><span class="line">| Alice    | 120                |</span><br><span class="line">| Donald   | 0                  |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">Elvis 和 Lee 旅行了 450 英里, Elvis 是排名靠前的旅行者, 因为他的名字在字母表上的排序比 Lee 更小.</span><br><span class="line">Bob, Jonathan, Alex 和 Alice 只有一次行程, 我们只按此次行程的全部距离对他们排序.</span><br><span class="line">Donald 没有任何行程, 他的旅行距离为 0.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">sum</span>(ifnull(distance,<span class="number">0</span>)) travelled_distance </span><br><span class="line"><span class="keyword">from</span> Users u <span class="keyword">left</span> <span class="keyword">join</span> Rides r</span><br><span class="line"><span class="keyword">on</span> u.id <span class="operator">=</span> r.user_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> travelled_distance  <span class="keyword">desc</span>, name </span><br></pre></td></tr></table></figure><h4 id="1412-查找成绩处于中游的学生"><a href="#1412-查找成绩处于中游的学生" class="headerlink" title="1412. 查找成绩处于中游的学生"></a><a href="https://leetcode-cn.com/problems/find-the-quiet-students-in-all-exams/">1412. 查找成绩处于中游的学生</a></h4><p>难度困难</p><p>SQL架构</p><p>表: <code>Student</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------+</span><br><span class="line">| Column Name         | Type    |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">| student_id          | int     |</span><br><span class="line">| student_name        | varchar |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">student_id 是该表主键.</span><br><span class="line">student_name 学生名字.</span><br></pre></td></tr></table></figure><p>表: <code>Exam</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| exam_id       | int     |</span><br><span class="line">| student_id    | int     |</span><br><span class="line">| score         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(exam_id, student_id) 是该表主键.</span><br><span class="line">学生 student_id 在测验 exam_id 中得分为 score.</span><br></pre></td></tr></table></figure><p>成绩处于中游的学生是指至少参加了一次测验, 且得分既不是最高分也不是最低分的学生。</p><p>写一个 SQL 语句，找出在所有测验中都处于中游的学生 <code>(student_id, student_name)</code>。</p><p>不要返回从来没有参加过测验的学生。返回结果表按照 <code>student_id</code> 排序。</p><p>查询结果格式如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Student 表：</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| student_id  | student_name  |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 1           | Daniel        |</span><br><span class="line">| 2           | Jade          |</span><br><span class="line">| 3           | Stella        |</span><br><span class="line">| 4           | Jonathan      |</span><br><span class="line">| 5           | Will          |</span><br><span class="line">+-------------+---------------+</span><br><span class="line"></span><br><span class="line">Exam 表：</span><br><span class="line">+------------+--------------+-----------+</span><br><span class="line">| exam_id    | student_id   | score     |</span><br><span class="line">+------------+--------------+-----------+</span><br><span class="line">| 10         |     1        |    70     |</span><br><span class="line">| 10         |     2        |    80     |</span><br><span class="line">| 10         |     3        |    90     |</span><br><span class="line">| 20         |     1        |    80     |</span><br><span class="line">| 30         |     1        |    70     |</span><br><span class="line">| 30         |     3        |    80     |</span><br><span class="line">| 30         |     4        |    90     |</span><br><span class="line">| 40         |     1        |    60     |</span><br><span class="line">| 40         |     2        |    70     |</span><br><span class="line">| 40         |     4        |    80     |</span><br><span class="line">+------------+--------------+-----------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| student_id  | student_name  |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 2           | Jade          |</span><br><span class="line">+-------------+---------------+</span><br><span class="line"></span><br><span class="line">对于测验 1: 学生 1 和 3 分别获得了最低分和最高分。</span><br><span class="line">对于测验 2: 学生 1 既获得了最高分, 也获得了最低分。</span><br><span class="line">对于测验 3 和 4: 学生 1 和 4 分别获得了最低分和最高分。</span><br><span class="line">学生 2 和 5 没有在任一场测验中获得了最高分或者最低分。</span><br><span class="line">因为学生 5 从来没有参加过任何测验, 所以他被排除于结果表。</span><br><span class="line">由此, 我们仅仅返回学生 2 的信息。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.student_id,student_name</span><br><span class="line"><span class="keyword">from</span> Exam e <span class="keyword">left</span> <span class="keyword">join</span> Student s</span><br><span class="line"><span class="keyword">on</span> e.student_id<span class="operator">=</span>s.student_id</span><br><span class="line"><span class="keyword">where</span> e.student_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> student_id</span><br><span class="line">    <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span> student_id,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> exam_id <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rkmax, <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> exam_id <span class="keyword">order</span> <span class="keyword">by</span> score ) rkmin</span><br><span class="line">        <span class="keyword">from</span> Exam </span><br><span class="line">    )t1</span><br><span class="line">    <span class="keyword">where</span> rkmax <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> rkmin <span class="operator">=</span><span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e.student_id,student_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.student_id </span><br></pre></td></tr></table></figure><h4 id="1421-净现值查询"><a href="#1421-净现值查询" class="headerlink" title="1421. 净现值查询"></a><a href="https://leetcode-cn.com/problems/npv-queries/">1421. 净现值查询</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>NPV</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| year          | int     |</span><br><span class="line">| npv           | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, year) 是该表主键.</span><br><span class="line">该表有每一笔存货的年份, id 和对应净现值的信息.</span><br></pre></td></tr></table></figure><p>表: <code>Queries</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| year          | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, year) 是该表主键.</span><br><span class="line">该表有每一次查询所对应存货的 id 和年份的信息.</span><br></pre></td></tr></table></figure><p>写一个 SQL, 找到 Queries 表中每一次查询的净现值.</p><p>结果表没有顺序要求.</p><p>查询结果的格式如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">NPV 表:</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| id   | year   | npv    |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| 1    | 2018   | 100    |</span><br><span class="line">| 7    | 2020   | 30     |</span><br><span class="line">| 13   | 2019   | 40     |</span><br><span class="line">| 1    | 2019   | 113    |</span><br><span class="line">| 2    | 2008   | 121    |</span><br><span class="line">| 3    | 2009   | 12     |</span><br><span class="line">| 11   | 2020   | 99     |</span><br><span class="line">| 7    | 2019   | 0      |</span><br><span class="line">+------+--------+--------+</span><br><span class="line"></span><br><span class="line">Queries 表:</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | year   |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1    | 2019   |</span><br><span class="line">| 2    | 2008   |</span><br><span class="line">| 3    | 2009   |</span><br><span class="line">| 7    | 2018   |</span><br><span class="line">| 7    | 2019   |</span><br><span class="line">| 7    | 2020   |</span><br><span class="line">| 13   | 2019   |</span><br><span class="line">+------+--------+</span><br><span class="line"></span><br><span class="line">结果表:</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| id   | year   | npv    |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| 1    | 2019   | 113    |</span><br><span class="line">| 2    | 2008   | 121    |</span><br><span class="line">| 3    | 2009   | 12     |</span><br><span class="line">| 7    | 2018   | 0      |</span><br><span class="line">| 7    | 2019   | 0      |</span><br><span class="line">| 7    | 2020   | 30     |</span><br><span class="line">| 13   | 2019   | 40     |</span><br><span class="line">+------+--------+--------+</span><br><span class="line"></span><br><span class="line">(7, 2018)的净现值不在 NPV 表中, 我们把它看作是 0.</span><br><span class="line">所有其它查询的净现值都能在 NPV 表中找到.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> q.id,q.year,ifnull(npv,<span class="number">0</span>) npv</span><br><span class="line"><span class="keyword">from</span> Queries q <span class="keyword">left</span> <span class="keyword">join</span> NPV n</span><br><span class="line"><span class="keyword">on</span> q.id <span class="operator">=</span> n.id <span class="keyword">and</span> q.year <span class="operator">=</span> n.year</span><br></pre></td></tr></table></figure><blockquote><p>npv 净现值概念 了解下</p></blockquote><h4 id="1435-制作会话柱状图"><a href="#1435-制作会话柱状图" class="headerlink" title="1435. 制作会话柱状图"></a><a href="https://leetcode-cn.com/problems/create-a-session-bar-chart/">1435. 制作会话柱状图</a></h4><p>难度简单</p><p>SQL架构</p><p>表：<code>Sessions</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------+</span><br><span class="line">| Column Name         | Type    |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">| session_id          | int     |</span><br><span class="line">| duration            | int     |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">session_id 是该表主键</span><br><span class="line">duration 是用户访问应用的时间, 以秒为单位</span><br></pre></td></tr></table></figure><p>你想知道用户在你的 app 上的访问时长情况。因此决定统计访问时长区间分别为 “[0-5&gt;”, “[5-10&gt;”, “[10-15&gt;” 和 “15 or more” （单位：分钟）的会话数量，并以此绘制柱状图。</p><p>写一个SQL查询来报告（访问时长区间，会话总数）。结果可用任何顺序呈现。</p><p><strong>下方为查询的输出格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sessions 表：</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| session_id  | duration      |</span><br><span class="line">+-------------+---------------+</span><br><span class="line">| 1           | 30            |</span><br><span class="line">| 2           | 199           |</span><br><span class="line">| 3           | 299           |</span><br><span class="line">| 4           | 580           |</span><br><span class="line">| 5           | 1000          |</span><br><span class="line">+-------------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| bin          | total        |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| [0-5&gt;        | 3            |</span><br><span class="line">| [5-10&gt;       | 1            |</span><br><span class="line">| [10-15&gt;      | 0            |</span><br><span class="line">| 15 or more   | 1            |</span><br><span class="line">+--------------+--------------+</span><br><span class="line"></span><br><span class="line">对于 session_id 1，2 和 3 ，它们的访问时间大于等于 0 分钟且小于 5 分钟。</span><br><span class="line">对于 session_id 4，它的访问时间大于等于 5 分钟且小于 10 分钟。</span><br><span class="line">没有会话的访问时间大于等于 10 分钟且小于 15 分钟。</span><br><span class="line">对于 session_id 5, 它的访问时间大于等于 15 分钟。</span><br></pre></td></tr></table></figure><p>Union</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;[0-5&gt;&#x27;</span> <span class="keyword">as</span> bin, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> Sessions <span class="keyword">where</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">and</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&lt;</span><span class="number">5</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;[5-10&gt;&#x27;</span> <span class="keyword">as</span> bin, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> Sessions <span class="keyword">where</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&gt;=</span><span class="number">5</span> <span class="keyword">and</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&lt;</span><span class="number">10</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;[10-15&gt;&#x27;</span> <span class="keyword">as</span> bin, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> Sessions <span class="keyword">where</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&lt;</span><span class="number">15</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;15 or more&#x27;</span><span class="keyword">as</span> bin, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total <span class="keyword">from</span> Sessions <span class="keyword">where</span> duration<span class="operator">/</span><span class="number">60</span><span class="operator">&gt;=</span><span class="number">15</span></span><br></pre></td></tr></table></figure><p>还有很多其他解法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.bin, <span class="built_in">count</span>(b.bin) <span class="keyword">as</span> total</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="string">&#x27;[0-5&gt;&#x27;</span> <span class="keyword">as</span> bin <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;[5-10&gt;&#x27;</span> <span class="keyword">as</span> bin <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;[10-15&gt;&#x27;</span> <span class="keyword">as</span> bin <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;15 or more&#x27;</span> <span class="keyword">as</span> bin </span><br><span class="line">)a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> duration <span class="operator">&lt;</span> <span class="number">300</span> <span class="keyword">then</span> <span class="string">&#x27;[0-5&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> duration <span class="operator">&gt;=</span> <span class="number">300</span> <span class="keyword">and</span> duration <span class="operator">&lt;</span> <span class="number">600</span> <span class="keyword">then</span> <span class="string">&#x27;[5-10&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">when</span> duration <span class="operator">&gt;=</span> <span class="number">600</span> <span class="keyword">and</span> duration <span class="operator">&lt;</span> <span class="number">900</span> <span class="keyword">then</span> <span class="string">&#x27;[10-15&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="string">&#x27;15 or more&#x27;</span></span><br><span class="line">        <span class="keyword">end</span> bin</span><br><span class="line">    <span class="keyword">from</span> Sessions </span><br><span class="line">)b</span><br><span class="line"><span class="keyword">on</span> a.bin <span class="operator">=</span> b.bin</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.bin</span><br></pre></td></tr></table></figure><h4 id="1440-计算布尔表达式的值"><a href="#1440-计算布尔表达式的值" class="headerlink" title="1440. 计算布尔表达式的值"></a><a href="https://leetcode-cn.com/problems/evaluate-boolean-expression/">1440. 计算布尔表达式的值</a></h4><p>难度中等</p><p>SQL架构</p><p>表 <code>Variables</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| name          | varchar |</span><br><span class="line">| value         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">name 是该表主键.</span><br><span class="line">该表包含了存储的变量及其对应的值.</span><br></pre></td></tr></table></figure><p>表 <code>Expressions</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| left_operand  | varchar |</span><br><span class="line">| operator      | enum    |</span><br><span class="line">| right_operand | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(left_operand, operator, right_operand) 是该表主键.</span><br><span class="line">该表包含了需要计算的布尔表达式.</span><br><span class="line">operator 是枚举类型, 取值于(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;=&#x27;)</span><br><span class="line">left_operand 和 right_operand 的值保证存在于 Variables 表单中.</span><br></pre></td></tr></table></figure><p>写一个 SQL 查询, 以计算表 <code>Expressions</code> 中的布尔表达式.</p><p>返回的结果表没有顺序要求.</p><p>查询结果格式如下例所示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Variables 表:</span><br><span class="line">+------+-------+</span><br><span class="line">| name | value |</span><br><span class="line">+------+-------+</span><br><span class="line">| x    | 66    |</span><br><span class="line">| y    | 77    |</span><br><span class="line">+------+-------+</span><br><span class="line"></span><br><span class="line">Expressions 表:</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line">| left_operand | operator | right_operand |</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line">| x            | &gt;        | y             |</span><br><span class="line">| x            | &lt;        | y             |</span><br><span class="line">| x            | =        | y             |</span><br><span class="line">| y            | &gt;        | x             |</span><br><span class="line">| y            | &lt;        | x             |</span><br><span class="line">| x            | =        | x             |</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">| left_operand | operator | right_operand | value |</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">| x            | &gt;        | y             | false |</span><br><span class="line">| x            | &lt;        | y             | true  |</span><br><span class="line">| x            | =        | y             | false |</span><br><span class="line">| y            | &gt;        | x             | true  |</span><br><span class="line">| y            | &lt;        | x             | false |</span><br><span class="line">| x            | =        | x             | true  |</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">如上所示, 你需要通过使用 Variables 表来找到 Expressions 表中的每一个布尔表达式的值.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.left_operand,e.operator,e.right_operand,</span><br><span class="line"><span class="keyword">case</span> e.operator</span><br><span class="line">    <span class="keyword">when</span> <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">then</span> if(v1.value<span class="operator">&gt;</span>v2.value,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">    <span class="keyword">when</span> <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">then</span> if(v1.value<span class="operator">&lt;</span>v2.value,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>  if(v1.value<span class="operator">=</span>v2.value,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">from</span> Expressions e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Variables v1 <span class="keyword">on</span> v1.name <span class="operator">=</span> e.left_operand </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Variables v2 <span class="keyword">on</span> v2.name <span class="operator">=</span> e.right_operand</span><br></pre></td></tr></table></figure><h4 id="1445-苹果和桔子"><a href="#1445-苹果和桔子" class="headerlink" title="1445. 苹果和桔子"></a><a href="https://leetcode-cn.com/problems/apples-oranges/">1445. 苹果和桔子</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| sale_date     | date    |</span><br><span class="line">| fruit         | enum    | </span><br><span class="line">| sold_num      | int     | </span><br><span class="line">+---------------+---------+</span><br><span class="line">(sale_date,fruit) 是该表主键.</span><br><span class="line">该表包含了每一天中&quot;苹果&quot; 和 &quot;桔子&quot;的销售情况.</span><br></pre></td></tr></table></figure><p>写一个 SQL 查询, 报告每一天 <strong>苹果</strong> 和 <strong>桔子</strong> 销售的数目的差异.</p><p>返回的结果表, 按照格式为 (‘YYYY-MM-DD’) 的 <code>sale_date</code> 排序.</p><p>查询结果表如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sales 表:</span><br><span class="line">+------------+------------+-------------+</span><br><span class="line">| sale_date  | fruit      | sold_num    |</span><br><span class="line">+------------+------------+-------------+</span><br><span class="line">| 2020-05-01 | apples     | 10          |</span><br><span class="line">| 2020-05-01 | oranges    | 8           |</span><br><span class="line">| 2020-05-02 | apples     | 15          |</span><br><span class="line">| 2020-05-02 | oranges    | 15          |</span><br><span class="line">| 2020-05-03 | apples     | 20          |</span><br><span class="line">| 2020-05-03 | oranges    | 0           |</span><br><span class="line">| 2020-05-04 | apples     | 15          |</span><br><span class="line">| 2020-05-04 | oranges    | 16          |</span><br><span class="line">+------------+------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+------------+--------------+</span><br><span class="line">| sale_date  | diff         |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 2020-05-01 | 2            |</span><br><span class="line">| 2020-05-02 | 0            |</span><br><span class="line">| 2020-05-03 | 20           |</span><br><span class="line">| 2020-05-04 | -1           |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">在 2020-05-01, 卖了 10 个苹果 和 8 个桔子 (差异为 10 - 8 = 2).</span><br><span class="line">在 2020-05-02, 卖了 15 个苹果 和 15 个桔子 (差异为 15 - 15 = 0).</span><br><span class="line">在 2020-05-03, 卖了 20 个苹果 和 0 个桔子 (差异为 20 - 0 = 20).</span><br><span class="line">在 2020-05-04, 卖了 15 个苹果 和 16 个桔子 (差异为 15 - 16 = -1).</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  sale_date,sold_num<span class="operator">-</span>ld diff</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> sale_date,sold_num , fruit ,<span class="built_in">lead</span>(sold_num ,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span>  sale_date ) ld</span><br><span class="line"><span class="keyword">from</span> Sales</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> fruit<span class="operator">=</span><span class="string">&#x27;apples&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1454-活跃用户"><a href="#1454-活跃用户" class="headerlink" title="1454.  活跃用户"></a><a href="https://leetcode-cn.com/problems/active-users/">1454.  活跃用户</a></h4><p>难度中等</p><p>SQL架构</p><p>表 <code>Accounts</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表主键.</span><br><span class="line">该表包含账户 id 和账户的用户名.</span><br></pre></td></tr></table></figure><p>表 <code>Logins</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| login_date    | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表无主键, 可能包含重复项.</span><br><span class="line">该表包含登录用户的账户 id 和登录日期. 用户也许一天内登录多次.</span><br></pre></td></tr></table></figure><p>写一个 SQL 查询, 找到活跃用户的 id 和 name.</p><p>活跃用户是指那些至少连续 5 天登录账户的用户.</p><p>返回的结果表按照 id 排序.</p><p>结果表格式如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Accounts 表:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Winston  |</span><br><span class="line">| 7  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line"></span><br><span class="line">Logins 表:</span><br><span class="line">+----+------------+</span><br><span class="line">| id | login_date |</span><br><span class="line">+----+------------+</span><br><span class="line">| 7  | 2020-05-30 |</span><br><span class="line">| 1  | 2020-05-30 |</span><br><span class="line">| 7  | 2020-05-31 |</span><br><span class="line">| 7  | 2020-06-01 |</span><br><span class="line">| 7  | 2020-06-02 |</span><br><span class="line">| 7  | 2020-06-02 |</span><br><span class="line">| 7  | 2020-06-03 |</span><br><span class="line">| 1  | 2020-06-07 |</span><br><span class="line">| 7  | 2020-06-10 |</span><br><span class="line">+----+------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 7  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line">id = 1 的用户 Winston 仅仅在不同的 2 天内登录了 2 次, 所以, Winston 不是活跃用户.</span><br><span class="line">id = 7 的用户 Jonathon 在不同的 6 天内登录了 7 次, , 6 天中有 5 天是连续的, 所以, Jonathan 是活跃用户.</span><br></pre></td></tr></table></figure><p><strong>后续问题:</strong><br>如果活跃用户是那些至少连续 <code>n</code> 天登录账户的用户, 你能否写出通用的解决方案?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t3.id,name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> id</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> id,login_date,<span class="built_in">lead</span>(login_date,<span class="number">4</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> login_date) ld</span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span> id,login_date </span><br><span class="line">            <span class="keyword">from</span> Logins</span><br><span class="line">            <span class="keyword">group</span> <span class="keyword">by</span> id,login_date</span><br><span class="line">        )t1</span><br><span class="line">    )t2</span><br><span class="line">    <span class="keyword">where</span> datediff(ld,login_date)<span class="operator">=</span><span class="number">4</span></span><br><span class="line">)t3</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Accounts a</span><br><span class="line"><span class="keyword">on</span> t3.id <span class="operator">=</span> a.id</span><br></pre></td></tr></table></figure><blockquote><p>注意用户当天重复登入</p></blockquote><h4 id="1459-矩形面积"><a href="#1459-矩形面积" class="headerlink" title="1459. 矩形面积"></a><a href="https://leetcode-cn.com/problems/rectangles-area/">1459. 矩形面积</a></h4><p>难度中等</p><p>SQL架构</p><p>表: <code>Points</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| x_value       | int     |</span><br><span class="line">| y_value       | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表主键.</span><br><span class="line">每个点都表示为二维空间 (x_value, y_value).</span><br></pre></td></tr></table></figure><p>写一个 SQL 语句, 报告由表中任意两点可以形成的所有可能的矩形. </p><p>结果表中的每一行包含三列 (p1, p2, area) 如下:</p><ul><li><strong>p1</strong> 和 <strong>p2</strong> 是矩形两个对角的 id 且 p1 &lt; p2.</li><li>矩形的面积由列 <strong>area</strong> 表示. </li></ul><p>请按照面积大小降序排列，如果面积相同的话, 则按照 p1 和 p2 升序对结果表排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Points 表:</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line">| id       | x_value     | y_value     |</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line">| 1        | 2           | 8           |</span><br><span class="line">| 2        | 4           | 7           |</span><br><span class="line">| 3        | 2           | 10          |</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line">| p1       | p2          | area        |</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line">| 2        | 3           | 6           |</span><br><span class="line">| 1        | 2           | 2           |</span><br><span class="line">+----------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">p1 应该小于 p2 并且面积大于 0.</span><br><span class="line">p1 = 1 且 p2 = 2 时, 面积等于 |2-4| * |8-7| = 2.</span><br><span class="line">p1 = 2 且 p2 = 3 时, 面积等于 |4-2| * |7-10| = 6.</span><br><span class="line">p1 = 1 且 p2 = 3 时, 是不可能为矩形的, 因为面积等于 0.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.id P1,b.id P2,<span class="built_in">abs</span>(a.x_value<span class="operator">-</span>b.x_value)<span class="operator">*</span><span class="built_in">abs</span>(a.y_value<span class="operator">-</span>b.y_value) <span class="keyword">as</span> area</span><br><span class="line"><span class="keyword">from</span> Points a,Points b</span><br><span class="line"><span class="keyword">where</span> a.id<span class="operator">&lt;</span>b.id <span class="keyword">and</span> a.x_value <span class="operator">!=</span> b.x_value <span class="keyword">and</span> a.y_value <span class="operator">!=</span> b.y_value</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> area <span class="keyword">desc</span>,P1 ,P2 </span><br></pre></td></tr></table></figure><h4 id="1468-计算税后工资"><a href="#1468-计算税后工资" class="headerlink" title="1468. 计算税后工资"></a><a href="https://leetcode-cn.com/problems/calculate-salaries/">1468. 计算税后工资</a></h4><p>难度中等</p><p>SQL架构</p><p><code>Salaries</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| company_id    | int     |</span><br><span class="line">| employee_id   | int     |</span><br><span class="line">| employee_name | varchar |</span><br><span class="line">| salary        | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(company_id, employee_id) 是这个表的主键</span><br><span class="line">这个表包括员工的company id, id, name 和 salary </span><br></pre></td></tr></table></figure><p>写一条查询 SQL 来查找每个员工的税后工资</p><p>每个公司的税率计算依照以下规则</p><ul><li>如果这个公司员工最高工资不到 1000 ，税率为 0%</li><li>如果这个公司员工最高工资在 1000 到 10000 之间，税率为 24%</li><li>如果这个公司员工最高工资大于 10000 ，税率为 49%</li></ul><p>按任意顺序返回结果，税后工资结果取整</p><p>结果表格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Salaries 表：</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line">| company_id | employee_id | employee_name | salary |</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line">| 1          | 1           | Tony          | 2000   |</span><br><span class="line">| 1          | 2           | Pronub        | 21300  |</span><br><span class="line">| 1          | 3           | Tyrrox        | 10800  |</span><br><span class="line">| 2          | 1           | Pam           | 300    |</span><br><span class="line">| 2          | 7           | Bassem        | 450    |</span><br><span class="line">| 2          | 9           | Hermione      | 700    |</span><br><span class="line">| 3          | 7           | Bocaben       | 100    |</span><br><span class="line">| 3          | 2           | Ognjen        | 2200   |</span><br><span class="line">| 3          | 13          | Nyancat       | 3300   |</span><br><span class="line">| 3          | 15          | Morninngcat   | 1866   |</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line">| company_id | employee_id | employee_name | salary |</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line">| 1          | 1           | Tony          | 1020   |</span><br><span class="line">| 1          | 2           | Pronub        | 10863  |</span><br><span class="line">| 1          | 3           | Tyrrox        | 5508   |</span><br><span class="line">| 2          | 1           | Pam           | 300    |</span><br><span class="line">| 2          | 7           | Bassem        | 450    |</span><br><span class="line">| 2          | 9           | Hermione      | 700    |</span><br><span class="line">| 3          | 7           | Bocaben       | 76     |</span><br><span class="line">| 3          | 2           | Ognjen        | 1672   |</span><br><span class="line">| 3          | 13          | Nyancat       | 2508   |</span><br><span class="line">| 3          | 15          | Morninngcat   | 5911   |</span><br><span class="line">+------------+-------------+---------------+--------+</span><br><span class="line">对于公司 1 ，最高工资是 21300 ，其每个员工的税率为 49%</span><br><span class="line">对于公司 2 ，最高工资是 700 ，其每个员工税率为 0%</span><br><span class="line">对于公司 3 ，最高工资是 7777 ，其每个员工税率是 24%</span><br><span class="line">税后工资计算 = 工资 - ( 税率 / 100）*工资</span><br><span class="line">对于上述案例，Morninngcat 的税后工资 = 7777 - 7777 * ( 24 / 100) = 7777 - 1866.48 = 5910.52 ，取整为 5911</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> company_id,employee_id , employee_name,</span><br><span class="line">round(<span class="keyword">case</span> <span class="keyword">when</span> maxsalary<span class="operator">&lt;</span><span class="number">1000</span> <span class="keyword">then</span> salary</span><br><span class="line">       <span class="keyword">when</span> maxsalary<span class="operator">&lt;</span><span class="number">10000</span> <span class="keyword">then</span> salary<span class="operator">*</span>(<span class="number">1</span><span class="number">-0.24</span>)</span><br><span class="line">       <span class="keyword">else</span> salary<span class="operator">*</span>(<span class="number">1</span><span class="number">-0.49</span>) <span class="keyword">end</span> ,<span class="number">0</span>)salary</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">max</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> company_id ) maxsalary</span><br><span class="line">    <span class="keyword">from</span> Salaries </span><br><span class="line">)t1</span><br></pre></td></tr></table></figure><h4 id="1479-周内每天的销售情况"><a href="#1479-周内每天的销售情况" class="headerlink" title="1479. 周内每天的销售情况"></a><a href="https://leetcode-cn.com/problems/sales-by-day-of-the-week/">1479. 周内每天的销售情况</a></h4><p>难度困难</p><p>SQL架构</p><p>表：<code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| order_date    | date    | </span><br><span class="line">| item_id       | varchar |</span><br><span class="line">| quantity      | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(order_id, item_id) 是该表主键</span><br><span class="line">该表包含了订单信息</span><br><span class="line">order_date 是id为 item_id 的商品被id为 customer_id 的消费者订购的日期.</span><br></pre></td></tr></table></figure><p>表：<code>Items</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------+</span><br><span class="line">| Column Name         | Type    |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">| item_id             | varchar |</span><br><span class="line">| item_name           | varchar |</span><br><span class="line">| item_category       | varchar |</span><br><span class="line">+---------------------+---------+</span><br><span class="line">item_id 是该表主键</span><br><span class="line">item_name 是商品的名字</span><br><span class="line">item_category 是商品的类别</span><br></pre></td></tr></table></figure><p>你是企业主，想要获得分类商品和周内每天的销售报告。</p><p>写一个SQL语句，报告 <strong>周内每天</strong> 每个商品类别下订购了多少单位。</p><p>返回结果表单 <strong>按商品类别排序</strong> 。</p><p>查询结果格式如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Orders 表：</span><br><span class="line">+------------+--------------+-------------+--------------+-------------+</span><br><span class="line">| order_id   | customer_id  | order_date  | item_id      | quantity    |</span><br><span class="line">+------------+--------------+-------------+--------------+-------------+</span><br><span class="line">| 1          | 1            | 2020-06-01  | 1            | 10          |</span><br><span class="line">| 2          | 1            | 2020-06-08  | 2            | 10          |</span><br><span class="line">| 3          | 2            | 2020-06-02  | 1            | 5           |</span><br><span class="line">| 4          | 3            | 2020-06-03  | 3            | 5           |</span><br><span class="line">| 5          | 4            | 2020-06-04  | 4            | 1           |</span><br><span class="line">| 6          | 4            | 2020-06-05  | 5            | 5           |</span><br><span class="line">| 7          | 5            | 2020-06-05  | 1            | 10          |</span><br><span class="line">| 8          | 5            | 2020-06-14  | 4            | 5           |</span><br><span class="line">| 9          | 5            | 2020-06-21  | 3            | 5           |</span><br><span class="line">+------------+--------------+-------------+--------------+-------------+</span><br><span class="line"></span><br><span class="line">Items 表：</span><br><span class="line">+------------+----------------+---------------+</span><br><span class="line">| item_id    | item_name      | item_category |</span><br><span class="line">+------------+----------------+---------------+</span><br><span class="line">| 1          | LC Alg. Book   | Book          |</span><br><span class="line">| 2          | LC DB. Book    | Book          |</span><br><span class="line">| 3          | LC SmarthPhone | Phone         |</span><br><span class="line">| 4          | LC Phone 2020  | Phone         |</span><br><span class="line">| 5          | LC SmartGlass  | Glasses       |</span><br><span class="line">| 6          | LC T-Shirt XL  | T-Shirt       |</span><br><span class="line">+------------+----------------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span><br><span class="line">| Category   | Monday    | Tuesday   | Wednesday | Thursday  | Friday    | Saturday  | Sunday    |</span><br><span class="line">+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span><br><span class="line">| Book       | 20        | 5         | 0         | 0         | 10        | 0         | 0         |</span><br><span class="line">| Glasses    | 0         | 0         | 0         | 0         | 5         | 0         | 0         |</span><br><span class="line">| Phone      | 0         | 0         | 5         | 1         | 0         | 0         | 10        |</span><br><span class="line">| T-Shirt    | 0         | 0         | 0         | 0         | 0         | 0         | 0         |</span><br><span class="line">+------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span><br><span class="line">在周一(2020-06-01, 2020-06-08)，Book分类(ids: 1, 2)下，总共销售了20个单位(10 + 10)</span><br><span class="line">在周二(2020-06-02)，Book分类(ids: 1, 2)下，总共销售了5个单位</span><br><span class="line">在周三(2020-06-03)，Phone分类(ids: 3, 4)下，总共销售了5个单位</span><br><span class="line">在周四(2020-06-04)，Phone分类(ids: 3, 4)下，总共销售了1个单位</span><br><span class="line">在周五(2020-06-05)，Book分类(ids: 1, 2)下，总共销售了10个单位，Glasses分类(ids: 5)下，总共销售了5个单位</span><br><span class="line">在周六, 没有商品销售</span><br><span class="line">在周天(2020-06-14, 2020-06-21)，Phone分类(ids: 3, 4)下，总共销售了10个单位(5 + 5)</span><br><span class="line">没有销售 T-Shirt 类别的商品</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> item_category <span class="keyword">as</span> category, </span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">2</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Monday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">3</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Tuesday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">4</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Wednesday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">5</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Thursday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">6</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Friday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">7</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Saturday,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> num <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span> quantity <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> Sunday</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> item_category, quantity,dayofweek(order_date) <span class="keyword">as</span> num <span class="keyword">from</span> </span><br><span class="line">items i <span class="keyword">left</span> <span class="keyword">join</span> orders o </span><br><span class="line"><span class="keyword">on</span> i.item_id<span class="operator">=</span>o.item_id) t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> item_category</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> item_category</span><br></pre></td></tr></table></figure><h4 id="1485-按日期分组销售产品"><a href="#1485-按日期分组销售产品" class="headerlink" title="1485. 按日期分组销售产品"></a><a href="https://leetcode-cn.com/problems/group-sold-products-by-the-date/">1485. 按日期分组销售产品</a></h4><p>难度简单</p><p>SQL架构</p><p>表 <code>Activities</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| sell_date   | date    |</span><br><span class="line">| product     | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">此表没有主键，它可能包含重复项。</span><br><span class="line">此表的每一行都包含产品名称和在市场上销售的日期。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。<br>每个日期的销售产品名称应按词典序排列。<br>返回按 <code>sell_date</code> 排序的结果表。</p><p>查询结果格式如下例所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Activities 表：</span><br><span class="line">+------------+-------------+</span><br><span class="line">| sell_date  | product     |</span><br><span class="line">+------------+-------------+</span><br><span class="line">| 2020-05-30 | Headphone   |</span><br><span class="line">| 2020-06-01 | Pencil      |</span><br><span class="line">| 2020-06-02 | Mask        |</span><br><span class="line">| 2020-05-30 | Basketball  |</span><br><span class="line">| 2020-06-01 | Bible       |</span><br><span class="line">| 2020-06-02 | Mask        |</span><br><span class="line">| 2020-05-30 | T-Shirt     |</span><br><span class="line">+------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">| sell_date  | num_sold | products                     |</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |</span><br><span class="line">| 2020-06-01 | 2        | Bible,Pencil                 |</span><br><span class="line">| 2020-06-02 | 1        | Mask                         |</span><br><span class="line">+------------+----------+------------------------------+</span><br><span class="line">对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 &#x27;,&#x27; 分隔。</span><br><span class="line">对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。</span><br><span class="line">对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sell_date, <span class="built_in">count</span>(<span class="keyword">distinct</span> product) num_sold, </span><br><span class="line">    group_concat(<span class="keyword">distinct</span> product <span class="keyword">order</span> <span class="keyword">by</span> product) products</span><br><span class="line"><span class="keyword">from</span> Activities</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sell_date</span><br></pre></td></tr></table></figure><blockquote><p>行转列</p></blockquote><h4 id="1495-上月播放的儿童适宜电影"><a href="#1495-上月播放的儿童适宜电影" class="headerlink" title="1495. 上月播放的儿童适宜电影"></a><a href="https://leetcode-cn.com/problems/friendly-movies-streamed-last-month/">1495. 上月播放的儿童适宜电影</a></h4><p>难度简单</p><p>SQL架构</p><p>表: <code>TVProgram</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| program_date  | date    |</span><br><span class="line">| content_id    | int     |</span><br><span class="line">| channel       | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(program_date, content_id) 是该表主键.</span><br><span class="line">该表包含电视上的节目信息.</span><br><span class="line">content_id 是电视一些频道上的节目的 id.</span><br></pre></td></tr></table></figure><p>表: <code>Content</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| content_id       | varchar |</span><br><span class="line">| title            | varchar |</span><br><span class="line">| Kids_content     | enum    |</span><br><span class="line">| content_type     | varchar |</span><br><span class="line">+------------------+---------+</span><br><span class="line">content_id 是该表主键.</span><br><span class="line">Kids_content 是枚举类型, 取值为(&#x27;Y&#x27;, &#x27;N&#x27;), 其中: </span><br><span class="line">&#x27;Y&#x27; 表示儿童适宜内容, 而&#x27;N&#x27;表示儿童不宜内容.</span><br><span class="line">content_type 表示内容的类型, 比如电影, 电视剧等.</span><br></pre></td></tr></table></figure><p>写一个 SQL 语句, 报告在 2020 年 6 月份播放的儿童适宜电影的去重电影名.</p><p>返回的结果表单没有顺序要求.</p><p>查询结果的格式如下例所示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">TVProgram 表:</span><br><span class="line">+--------------------+--------------+-------------+</span><br><span class="line">| program_date       | content_id   | channel     |</span><br><span class="line">+--------------------+--------------+-------------+</span><br><span class="line">| 2020-06-10 08:00   | 1            | LC-Channel  |</span><br><span class="line">| 2020-05-11 12:00   | 2            | LC-Channel  |</span><br><span class="line">| 2020-05-12 12:00   | 3            | LC-Channel  |</span><br><span class="line">| 2020-05-13 14:00   | 4            | Disney Ch   |</span><br><span class="line">| 2020-06-18 14:00   | 4            | Disney Ch   |</span><br><span class="line">| 2020-07-15 16:00   | 5            | Disney Ch   |</span><br><span class="line">+--------------------+--------------+-------------+</span><br><span class="line"></span><br><span class="line">Content 表:</span><br><span class="line">+------------+----------------+---------------+---------------+</span><br><span class="line">| content_id | title          | Kids_content  | content_type  |</span><br><span class="line">+------------+----------------+---------------+---------------+</span><br><span class="line">| 1          | Leetcode Movie | N             | Movies        |</span><br><span class="line">| 2          | Alg. for Kids  | Y             | Series        |</span><br><span class="line">| 3          | Database Sols  | N             | Series        |</span><br><span class="line">| 4          | Aladdin        | Y             | Movies        |</span><br><span class="line">| 5          | Cinderella     | Y             | Movies        |</span><br><span class="line">+------------+----------------+---------------+---------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------+</span><br><span class="line">| title        |</span><br><span class="line">+--------------+</span><br><span class="line">| Aladdin      |</span><br><span class="line">+--------------+</span><br><span class="line">&quot;Leetcode Movie&quot; 是儿童不宜的电影.</span><br><span class="line">&quot;Alg. for Kids&quot; 不是电影.</span><br><span class="line">&quot;Database Sols&quot; 不是电影</span><br><span class="line">&quot;Alladin&quot; 是电影, 儿童适宜, 并且在 2020 年 6 月份播放.</span><br><span class="line">&quot;Cinderella&quot; 不在 2020 年 6 月份播放.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> title   </span><br><span class="line"><span class="keyword">from</span> TVProgram t <span class="keyword">left</span> <span class="keyword">join</span> Content c</span><br><span class="line"><span class="keyword">on</span> t.content_id  <span class="operator">=</span> c.content_id </span><br><span class="line"><span class="keyword">where</span>  Kids_content <span class="operator">=</span><span class="string">&#x27;Y&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> date_format(program_date ,<span class="string">&#x27;%Y-%m&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2020-06&#x27;</span></span><br><span class="line"><span class="keyword">and</span> content_type<span class="operator">=</span><span class="string">&#x27;Movies&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>LEFT()函数参见：<a href="https://www.begtut.com/sql/func-mysql-left.html">https://www.begtut.com/sql/func-mysql-left.html</a><br>REGEXP语法参见：<br><a href="https://www.cnblogs.com/timssd/p/5882742.html">https://www.cnblogs.com/timssd/p/5882742.html</a><br><a href="https://www.cnblogs.com/zhaopanpan/p/10133224.html">https://www.cnblogs.com/zhaopanpan/p/10133224.html</a><br>DATE_FORMAT()函数参见：<a href="https://www.w3school.com.cn/sql/func_date_format.asp">https://www.w3school.com.cn/sql/func_date_format.asp</a><br>EXTRACT()函数参见：<a href="https://www.runoob.com/sql/func-extract.html">https://www.runoob.com/sql/func-extract.html</a><br>DATEDIFF()函数参见：<a href="https://www.runoob.com/sql/func-datediff-mysql.html">https://www.runoob.com/sql/func-datediff-mysql.html</a><br>YEAR()函数参见：<a href="https://blog.csdn.net/moakun/article/details/82528829">https://blog.csdn.net/moakun/article/details/82528829</a><br>MONTH()函数参见：<a href="https://www.yiibai.com/mysql/month.html">https://www.yiibai.com/mysql/month.html</a></p></blockquote><h4 id="1501-可以放心投资的国家"><a href="#1501-可以放心投资的国家" class="headerlink" title="1501. 可以放心投资的国家"></a><a href="https://leetcode-cn.com/problems/countries-you-can-safely-invest-in/">1501. 可以放心投资的国家</a></h4><p>难度中等</p><p>SQL架构</p><p>表 <code>Person</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| id             | int     |</span><br><span class="line">| name           | varchar |</span><br><span class="line">| phone_number   | varchar |</span><br><span class="line">+----------------+---------+</span><br><span class="line">id 是该表主键.</span><br><span class="line">该表每一行包含一个人的名字和电话号码.</span><br><span class="line">电话号码的格式是:&#x27;xxx-yyyyyyy&#x27;, 其中xxx是国家码(3个字符), yyyyyyy是电话号码(7个字符), x和y都表示数字. 同时, 国家码和电话号码都可以包含前导0.</span><br></pre></td></tr></table></figure><p>表 <code>Country</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------------+---------+</span><br><span class="line">| Column Name    | Type    |</span><br><span class="line">+----------------+---------+</span><br><span class="line">| name           | varchar |</span><br><span class="line">| country_code   | varchar |</span><br><span class="line">+----------------+---------+</span><br><span class="line">country_code是该表主键.</span><br><span class="line">该表每一行包含国家名和国家码. country_code的格式是&#x27;xxx&#x27;, x是数字.</span><br></pre></td></tr></table></figure><p>表 <code>Calls</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| caller_id   | int  |</span><br><span class="line">| callee_id   | int  |</span><br><span class="line">| duration    | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">该表无主键, 可能包含重复行.</span><br><span class="line">每一行包含呼叫方id, 被呼叫方id和以分钟为单位的通话时长. caller_id != callee_id</span><br></pre></td></tr></table></figure><p>一家电信公司想要投资新的国家. 该公司想要投资的国家是: 该国的平均通话时长要严格地大于全球平均通话时长.</p><p>写一段 SQL, 找到所有该公司可以投资的国家.</p><p>返回的结果表没有顺序要求.</p><p>查询的结果格式如下例所示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Person 表:</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | name     | phone_number |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| 3  | Jonathan | 051-1234567  |</span><br><span class="line">| 12 | Elvis    | 051-7654321  |</span><br><span class="line">| 1  | Moncef   | 212-1234567  |</span><br><span class="line">| 2  | Maroua   | 212-6523651  |</span><br><span class="line">| 7  | Meir     | 972-1234567  |</span><br><span class="line">| 9  | Rachel   | 972-0011100  |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line"></span><br><span class="line">Country 表:</span><br><span class="line">+----------+--------------+</span><br><span class="line">| name     | country_code |</span><br><span class="line">+----------+--------------+</span><br><span class="line">| Peru     | 051          |</span><br><span class="line">| Israel   | 972          |</span><br><span class="line">| Morocco  | 212          |</span><br><span class="line">| Germany  | 049          |</span><br><span class="line">| Ethiopia | 251          |</span><br><span class="line">+----------+--------------+</span><br><span class="line"></span><br><span class="line">Calls 表:</span><br><span class="line">+-----------+-----------+----------+</span><br><span class="line">| caller_id | callee_id | duration |</span><br><span class="line">+-----------+-----------+----------+</span><br><span class="line">| 1         | 9         | 33       |</span><br><span class="line">| 2         | 9         | 4        |</span><br><span class="line">| 1         | 2         | 59       |</span><br><span class="line">| 3         | 12        | 102      |</span><br><span class="line">| 3         | 12        | 330      |</span><br><span class="line">| 12        | 3         | 5        |</span><br><span class="line">| 7         | 9         | 13       |</span><br><span class="line">| 7         | 1         | 3        |</span><br><span class="line">| 9         | 7         | 1        |</span><br><span class="line">| 1         | 7         | 7        |</span><br><span class="line">+-----------+-----------+----------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----------+</span><br><span class="line">| country  |</span><br><span class="line">+----------+</span><br><span class="line">| Peru     |</span><br><span class="line">+----------+</span><br><span class="line">国家Peru的平均通话时长是 (102 + 102 + 330 + 330 + 5 + 5) / 6 = 145.666667</span><br><span class="line">国家Israel的平均通话时长是 (33 + 4 + 13 + 13 + 3 + 1 + 1 + 7) / 8 = 9.37500</span><br><span class="line">国家Morocco的平均通话时长是 (33 + 4 + 59 + 59 + 3 + 7) / 6 = 27.5000 </span><br><span class="line">全球平均通话时长 = (2 * (33 + 3 + 59 + 102 + 330 + 5 + 13 + 3 + 1 + 7)) / 20 = 55.70000</span><br><span class="line">所以, Peru是唯一的平均通话时长大于全球平均通话时长的国家, 也是唯一的推荐投资的国家.</span><br></pre></td></tr></table></figure><p>笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.name <span class="keyword">as</span> country </span><br><span class="line"><span class="keyword">from</span> Calls c1,Person p,Country c2</span><br><span class="line"><span class="keyword">where</span> (p.id<span class="operator">=</span>c1.caller_id <span class="keyword">or</span> p.id<span class="operator">=</span>c1.callee_id) <span class="keyword">and</span> c2.country_code<span class="operator">=</span><span class="keyword">left</span>(p.phone_number,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> c2.name </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(duration)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="built_in">avg</span>(duration) <span class="keyword">from</span> Calls)</span><br></pre></td></tr></table></figure><p>思路更清晰</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> people_country <span class="keyword">as</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> id, c.name country</span><br><span class="line">    <span class="keyword">from</span> Person p <span class="keyword">left</span> <span class="keyword">join</span> Country c</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">left</span>(p.phone_number,<span class="number">3</span>) <span class="operator">=</span> c.country_code</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> country</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> country, <span class="built_in">avg</span>(duration) avgtime</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> caller_id id, duration</span><br><span class="line">        <span class="keyword">from</span> Calls</span><br><span class="line">        <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">        <span class="keyword">select</span> callee_id, duration</span><br><span class="line">        <span class="keyword">from</span> Calls</span><br><span class="line">    ) t <span class="keyword">left</span> <span class="keyword">join</span> people_country</span><br><span class="line">    <span class="keyword">using</span>(id)</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> country</span><br><span class="line">) temp</span><br><span class="line"><span class="keyword">where</span> avgtime <span class="operator">&gt;</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">avg</span>(duration) avgtime</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span> caller_id, duration</span><br><span class="line">            <span class="keyword">from</span> Calls</span><br><span class="line">            <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">            <span class="keyword">select</span> callee_id, duration</span><br><span class="line">            <span class="keyword">from</span> Calls</span><br><span class="line">        ) t</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="1511-消费者下单频率"><a href="#1511-消费者下单频率" class="headerlink" title="1511. 消费者下单频率"></a><a href="https://leetcode-cn.com/problems/customer-order-frequency/">1511. 消费者下单频率</a></h4><p>难度简单</p><p>SQL架构</p><p>表: <code>Customers</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| country       | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">customer_id 是该表主键.</span><br><span class="line">该表包含公司消费者的信息.</span><br></pre></td></tr></table></figure><p>表: <code>Product</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| description   | varchar |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">product_id 是该表主键.</span><br><span class="line">该表包含公司产品的信息.</span><br><span class="line">price 是本产品的花销.</span><br></pre></td></tr></table></figure><p>表: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| quantity      | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">order_id 是该表主键.</span><br><span class="line">该表包含消费者下单的信息.</span><br><span class="line">customer_id 是买了数量为&quot;quantity&quot;, id为&quot;product_id&quot;产品的消费者的 id.</span><br><span class="line">Order_date 是订单发货的日期, 格式为(&#x27;YYYY-MM-DD&#x27;).</span><br></pre></td></tr></table></figure><p>写一个 SQL 语句, 报告消费者的 id 和名字, 其中消费者在 2020 年 6 月和 7 月, 每月至少花费了$100.</p><p>结果表无顺序要求.</p><p>查询结果格式如下例所示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Customers</span><br><span class="line">+--------------+-----------+-------------+</span><br><span class="line">| customer_id  | name      | country     |</span><br><span class="line">+--------------+-----------+-------------+</span><br><span class="line">| 1            | Winston   | USA         |</span><br><span class="line">| 2            | Jonathan  | Peru        |</span><br><span class="line">| 3            | Moustafa  | Egypt       |</span><br><span class="line">+--------------+-----------+-------------+</span><br><span class="line"></span><br><span class="line">Product</span><br><span class="line">+--------------+-------------+-------------+</span><br><span class="line">| product_id   | description | price       |</span><br><span class="line">+--------------+-------------+-------------+</span><br><span class="line">| 10           | LC Phone    | 300         |</span><br><span class="line">| 20           | LC T-Shirt  | 10          |</span><br><span class="line">| 30           | LC Book     | 45          |</span><br><span class="line">| 40           | LC Keychain | 2           |</span><br><span class="line">+--------------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Orders</span><br><span class="line">+--------------+-------------+-------------+-------------+-----------+</span><br><span class="line">| order_id     | customer_id | product_id  | order_date  | quantity  |</span><br><span class="line">+--------------+-------------+-------------+-------------+-----------+</span><br><span class="line">| 1            | 1           | 10          | 2020-06-10  | 1         |</span><br><span class="line">| 2            | 1           | 20          | 2020-07-01  | 1         |</span><br><span class="line">| 3            | 1           | 30          | 2020-07-08  | 2         |</span><br><span class="line">| 4            | 2           | 10          | 2020-06-15  | 2         |</span><br><span class="line">| 5            | 2           | 40          | 2020-07-01  | 10        |</span><br><span class="line">| 6            | 3           | 20          | 2020-06-24  | 2         |</span><br><span class="line">| 7            | 3           | 30          | 2020-06-25  | 2         |</span><br><span class="line">| 9            | 3           | 30          | 2020-05-08  | 3         |</span><br><span class="line">+--------------+-------------+-------------+-------------+-----------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------+------------+</span><br><span class="line">| customer_id  | name       |  </span><br><span class="line">+--------------+------------+</span><br><span class="line">| 1            | Winston    |</span><br><span class="line">+--------------+------------+ </span><br><span class="line">Winston 在2020年6月花费了$300(300 * 1), 在7月花费了$100(10 * 1 + 45 * 2).</span><br><span class="line">Jonathan 在2020年6月花费了$600(300 * 2), 在7月花费了$20(2 * 10).</span><br><span class="line">Moustafa 在2020年6月花费了$110 (10 * 2 + 45 * 2), 在7月花费了$0.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customer_id,name</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> customer_id <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> customer_id</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> customer_id, <span class="keyword">month</span>(order_date) <span class="keyword">as</span> <span class="keyword">month</span> , <span class="built_in">sum</span>(quantity<span class="operator">*</span>price) <span class="keyword">as</span> total</span><br><span class="line">        <span class="keyword">from</span> Orders o <span class="keyword">left</span> <span class="keyword">join</span> Product p <span class="keyword">on</span> o.product_id <span class="operator">=</span> p.product_id</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">month</span>(order_date) <span class="operator">=</span> <span class="number">6</span> <span class="keyword">or</span> <span class="keyword">month</span>(order_date)<span class="operator">=</span><span class="number">7</span></span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> customer_id,<span class="keyword">month</span>(order_date)</span><br><span class="line">        ) <span class="keyword">as</span> t1</span><br><span class="line">    <span class="keyword">where</span> total <span class="operator">&gt;=</span><span class="number">100</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="1517-Find-Users-With-Valid-E-Mails"><a href="#1517-Find-Users-With-Valid-E-Mails" class="headerlink" title="1517. Find Users With Valid E-Mails"></a><a href="https://leetcode-cn.com/problems/find-users-with-valid-e-mails/">1517. Find Users With Valid E-Mails</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Users</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| mail          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">user_id is the primary key for this table.</span><br><span class="line">This table contains information of the users signed up in a website. Some e-mails are invalid.</span><br></pre></td></tr></table></figure><p>Write an SQL query to find the users who have <strong>valid emails</strong>.</p><p>A valid e-mail has a prefix name and a domain where: </p><ul><li><strong>The prefix name</strong> is a string that may contain letters (upper or lower case), digits, underscore <code>&#39;_&#39;</code>, period <code>&#39;.&#39;</code> and/or dash <code>&#39;-&#39;</code>. The prefix name <strong>must</strong> start with a letter.</li><li><strong>The domain</strong> is <code>&#39;@leetcode.com&#39;</code>.</li></ul><p>Return the result table in any order.</p><p>The query result format is in the following example.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Users</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| user_id | name      | mail                    |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| 1       | Winston   | winston@leetcode.com    |</span><br><span class="line">| 2       | Jonathan  | jonathanisgreat         |</span><br><span class="line">| 3       | Annabelle | bella-@leetcode.com     |</span><br><span class="line">| 4       | Sally     | sally.come@leetcode.com |</span><br><span class="line">| 5       | Marwan    | quarz#2020@leetcode.com |</span><br><span class="line">| 6       | David     | david69@gmail.com       |</span><br><span class="line">| 7       | Shapiro   | .shapo@leetcode.com     |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| user_id | name      | mail                    |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">| 1       | Winston   | winston@leetcode.com    |</span><br><span class="line">| 3       | Annabelle | bella-@leetcode.com     |</span><br><span class="line">| 4       | Sally     | sally.come@leetcode.com |</span><br><span class="line">+---------+-----------+-------------------------+</span><br><span class="line">The mail of user 2 doesn&#x27;t have a domain.</span><br><span class="line">The mail of user 5 has # sign which is not allowed.</span><br><span class="line">The mail of user 6 doesn&#x27;t have leetcode domain.</span><br><span class="line">The mail of user 7 starts with a period.</span><br></pre></td></tr></table></figure><p>考察正则表达式的使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Users</span><br><span class="line"><span class="keyword">WHERE</span> mail REGEXP <span class="string">&#x27;^[a-zA-Z]+[\\w_\\.\\-]*@leetcode.com$&#x27;</span>   </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Users</span><br><span class="line"><span class="keyword">where</span> mail regexp <span class="string">&#x27;^[a-zA-Z]+[a-zA-Z0-9_\\./\\-]&#123;0,&#125;@leetcode.com$&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure><blockquote><p>坑点：<br>1、前缀可能是一个字母，比如“<a href="mailto:&#x4a;&#x40;&#x6c;&#x65;&#x65;&#x74;&#x63;&#111;&#100;&#x65;&#46;&#99;&#111;&#x6d;">&#x4a;&#x40;&#x6c;&#x65;&#x65;&#x74;&#x63;&#111;&#100;&#x65;&#46;&#99;&#111;&#x6d;</a>”，所以匹配非首字母外的前缀字符数量要用{0,}或*，不能用+。<br>2、题意要求：underscore ‘’, period ‘.’ and/or dash ‘-‘，/没加单引号，不留神可能写漏/。<br>3、后缀可能是“@leetcodeecom”，所以要对“.”加转义符号。<br>4、后缀可能是“@LEETCODE.COM”，默认是不区分大小写匹配，所以要加上“BINARY”区分大小写。<br>语法：<br>1、<a href="https://www.cnblogs.com/timssd/p/5882742.html">https://www.cnblogs.com/timssd/p/5882742.html</a><br>2、<a href="https://www.cnblogs.com/zhaopanpan/p/10133224.html">https://www.cnblogs.com/zhaopanpan/p/10133224.html</a><br>3、”双反斜杠+w”表示字母、数字、下划线，相对”a-zA-Z0-9”的写法更简洁。</p></blockquote><h4 id="1527-Patients-With-a-Condition"><a href="#1527-Patients-With-a-Condition" class="headerlink" title="1527. Patients With a Condition"></a><a href="https://leetcode-cn.com/problems/patients-with-a-condition/">1527. Patients With a Condition</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Patients</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| patient_id   | int     |</span><br><span class="line">| patient_name | varchar |</span><br><span class="line">| conditions   | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">patient_id is the primary key for this table.</span><br><span class="line">&#x27;conditions&#x27; contains 0 or more code separated by spaces. </span><br><span class="line">This table contains information of the patients in the hospital.</span><br></pre></td></tr></table></figure><p>Write an SQL query to report the patient_id, patient_name all conditions of patients who have Type I Diabetes. Type I Diabetes always starts with <code>DIAB1</code> prefix</p><p>Return the result table in any order.</p><p>The query result format is in the following example.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Patients</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">| patient_id | patient_name | conditions   |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">| 1          | Daniel       | YFEV COUGH   |</span><br><span class="line">| 2          | Alice        |              |</span><br><span class="line">| 3          | Bob          | DIAB100 MYOP |</span><br><span class="line">| 4          | George       | ACNE DIAB100 |</span><br><span class="line">| 5          | Alain        | DIAB201      |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">| patient_id | patient_name | conditions   |</span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">| 3          | Bob          | DIAB100 MYOP |</span><br><span class="line">| 4          | George       | ACNE DIAB100 | </span><br><span class="line">+------------+--------------+--------------+</span><br><span class="line">Bob and George both have a condition that starts with DIAB1.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  patient_id , patient_name ,conditions </span><br><span class="line"><span class="keyword">from</span> Patients</span><br><span class="line"><span class="keyword">where</span> conditions <span class="keyword">like</span> <span class="string">&#x27;%DIAB1%&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1532-The-Most-Recent-Three-Orders"><a href="#1532-The-Most-Recent-Three-Orders" class="headerlink" title="1532. The Most Recent Three Orders"></a><a href="https://leetcode-cn.com/problems/the-most-recent-three-orders/">1532. The Most Recent Three Orders</a></h4><p>难度中等</p><p>SQL架构</p><p>Table: <code>Customers</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">customer_id is the primary key for this table.</span><br><span class="line">This table contains information about customers.</span><br></pre></td></tr></table></figure><p>Table: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| cost          | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">order_id is the primary key for this table.</span><br><span class="line">This table contains information about the orders made by customer_id.</span><br><span class="line">Each customer has one order per day.</span><br></pre></td></tr></table></figure><p>Write an SQL query to find the most recent 3 orders of each user. If a user ordered less than 3 orders return all of their orders.</p><p>Return the result table sorted by <code>customer_name</code> in <strong>ascending</strong> order and in case of a tie by the <code>customer_id</code> in <strong>ascending</strong> order. If there still a tie, order them by the <code>order_date</code> in <strong>descending</strong> order.</p><p>The query result format is in the following example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Customers</span><br><span class="line">+-------------+-----------+</span><br><span class="line">| customer_id | name      |</span><br><span class="line">+-------------+-----------+</span><br><span class="line">| 1           | Winston   |</span><br><span class="line">| 2           | Jonathan  |</span><br><span class="line">| 3           | Annabelle |</span><br><span class="line">| 4           | Marwan    |</span><br><span class="line">| 5           | Khaled    |</span><br><span class="line">+-------------+-----------+</span><br><span class="line"></span><br><span class="line">Orders</span><br><span class="line">+----------+------------+-------------+------+</span><br><span class="line">| order_id | order_date | customer_id | cost |</span><br><span class="line">+----------+------------+-------------+------+</span><br><span class="line">| 1        | 2020-07-31 | 1           | 30   |</span><br><span class="line">| 2        | 2020-07-30 | 2           | 40   |</span><br><span class="line">| 3        | 2020-07-31 | 3           | 70   |</span><br><span class="line">| 4        | 2020-07-29 | 4           | 100  |</span><br><span class="line">| 5        | 2020-06-10 | 1           | 1010 |</span><br><span class="line">| 6        | 2020-08-01 | 2           | 102  |</span><br><span class="line">| 7        | 2020-08-01 | 3           | 111  |</span><br><span class="line">| 8        | 2020-08-03 | 1           | 99   |</span><br><span class="line">| 9        | 2020-08-07 | 2           | 32   |</span><br><span class="line">| 10       | 2020-07-15 | 1           | 2    |</span><br><span class="line">+----------+------------+-------------+------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+---------------+-------------+----------+------------+</span><br><span class="line">| customer_name | customer_id | order_id | order_date |</span><br><span class="line">+---------------+-------------+----------+------------+</span><br><span class="line">| Annabelle     | 3           | 7        | 2020-08-01 |</span><br><span class="line">| Annabelle     | 3           | 3        | 2020-07-31 |</span><br><span class="line">| Jonathan      | 2           | 9        | 2020-08-07 |</span><br><span class="line">| Jonathan      | 2           | 6        | 2020-08-01 |</span><br><span class="line">| Jonathan      | 2           | 2        | 2020-07-30 |</span><br><span class="line">| Marwan        | 4           | 4        | 2020-07-29 |</span><br><span class="line">| Winston       | 1           | 8        | 2020-08-03 |</span><br><span class="line">| Winston       | 1           | 1        | 2020-07-31 |</span><br><span class="line">| Winston       | 1           | 10       | 2020-07-15 |</span><br><span class="line">+---------------+-------------+----------+------------+</span><br><span class="line">Winston has 4 orders, we discard the order of &quot;2020-06-10&quot; because it is the oldest order.</span><br><span class="line">Annabelle has only 2 orders, we return them.</span><br><span class="line">Jonathan has exactly 3 orders.</span><br><span class="line">Marwan ordered only one time.</span><br><span class="line">We sort the result table by customer_name in ascending order, by customer_id in ascending order and by order_date in descending order in case of a tie.</span><br></pre></td></tr></table></figure><p><strong>Follow-up:</strong><br>Can you write a general solution for the most recent <code>n</code> orders?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name customer_name ,customer_id,order_id,order_date</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span>  name ,o.customer_id,order_id,order_date ,<span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> o.customer_id <span class="keyword">order</span> <span class="keyword">by</span> order_date <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Orders o <span class="keyword">left</span> <span class="keyword">join</span> Customers c</span><br><span class="line"><span class="keyword">on</span> o.customer_id<span class="operator">=</span>c.customer_id</span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">&lt;=</span><span class="number">3</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> customer_name ,customer_id,order_date <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h4 id="1543-Fix-Product-Name-Format"><a href="#1543-Fix-Product-Name-Format" class="headerlink" title="1543. Fix Product Name Format"></a><a href="https://leetcode-cn.com/problems/fix-product-name-format/">1543. Fix Product Name Format</a></h4><p>难度简单</p><p>SQL架构</p><p>Table: <code>Sales</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| sale_id      | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">| sale_date    | date    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">sale_id is the primary key for this table.</span><br><span class="line">Each row of this table contains the product name and the date it was sold.</span><br></pre></td></tr></table></figure><p>Since table Sales was filled manually in the year 2000, <code>product_name</code> may contain leading and/or trailing white spaces, also they are case-insensitive.</p><p>Write an SQL query to report</p><ul><li><code>product_name</code> in lowercase without leading or trailing white spaces.</li><li><code>sale_date</code> in the format <code>(&#39;YYYY-MM&#39;)</code> </li><li><code>total</code> the number of times the product was sold in this month.</li></ul><p>Return the result table ordered by <code>product_name</code> in <strong>ascending order</strong>, in case of a tie order it by <code>sale_date</code> in <strong>ascending order</strong>.</p><p>The query result format is in the following example.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sales</span><br><span class="line">+------------+------------------+--------------+</span><br><span class="line">| sale_id    | product_name     | sale_date    |</span><br><span class="line">+------------+------------------+--------------+</span><br><span class="line">| 1          |      LCPHONE     | 2000-01-16   |</span><br><span class="line">| 2          |    LCPhone       | 2000-01-17   |</span><br><span class="line">| 3          |     LcPhOnE      | 2000-02-18   |</span><br><span class="line">| 4          |      LCKeyCHAiN  | 2000-02-19   |</span><br><span class="line">| 5          |   LCKeyChain     | 2000-02-28   |</span><br><span class="line">| 6          | Matryoshka       | 2000-03-31   | </span><br><span class="line">+------------+------------------+--------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| product_name | sale_date    | total    |</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| lcphone      | 2000-01      | 2        |</span><br><span class="line">| lckeychain   | 2000-02      | 2        | </span><br><span class="line">| lcphone      | 2000-02      | 1        | </span><br><span class="line">| matryoshka   | 2000-03      | 1        | </span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line"></span><br><span class="line">In January, 2 LcPhones were sold, please note that the product names are not case sensitive and may contain spaces.</span><br><span class="line">In Februery, 2 LCKeychains and 1 LCPhone were sold.</span><br><span class="line">In March, 1 matryoshka was sold.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="built_in">lower</span>(product_name)) <span class="keyword">as</span> product_name, </span><br><span class="line">        date_format(sale_date,<span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">as</span> sale_date,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> total </span><br><span class="line"><span class="keyword">from</span> Sales </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">trim</span>(<span class="built_in">lower</span>(product_name)), date_format(sale_date,<span class="string">&#x27;%Y-%m&#x27;</span>) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> product_name <span class="keyword">asc</span>, sale_date <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><blockquote><p>注意大小写、空格 </p></blockquote><h4 id="1549-The-Most-Recent-Orders-for-Each-Product"><a href="#1549-The-Most-Recent-Orders-for-Each-Product" class="headerlink" title="1549. The Most Recent Orders for Each Product"></a><a href="https://leetcode-cn.com/problems/the-most-recent-orders-for-each-product/">1549. The Most Recent Orders for Each Product</a></h4><p>难度中等</p><p>SQL架构</p><p>Table: <code>Customers</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">customer_id is the primary key for this table.</span><br><span class="line">This table contains information about the customers.</span><br></pre></td></tr></table></figure><p>Table: <code>Orders</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| order_id      | int     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| customer_id   | int     |</span><br><span class="line">| product_id    | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">order_id is the primary key for this table.</span><br><span class="line">This table contains information about the orders made by customer_id.</span><br><span class="line">There will be no product ordered by the same user more than once in one day.</span><br></pre></td></tr></table></figure><p>Table: <code>Products</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| product_name  | varchar |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">product_id is the primary key for this table.</span><br><span class="line">This table contains information about the Products.</span><br></pre></td></tr></table></figure><p>Write an SQL query to find the most recent order(s) of each product.</p><p>Return the result table sorted by <code>product_name</code> in <strong>ascending</strong> order and in case of a tie by the <code>product_id</code> in <strong>ascending</strong> order. If there still a tie, order them by the <code>order_id</code> in <strong>ascending</strong> order.</p><p>The query result format is in the following example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Customers</span><br><span class="line">+-------------+-----------+</span><br><span class="line">| customer_id | name      |</span><br><span class="line">+-------------+-----------+</span><br><span class="line">| 1           | Winston   |</span><br><span class="line">| 2           | Jonathan  |</span><br><span class="line">| 3           | Annabelle |</span><br><span class="line">| 4           | Marwan    |</span><br><span class="line">| 5           | Khaled    |</span><br><span class="line">+-------------+-----------+</span><br><span class="line"></span><br><span class="line">Orders</span><br><span class="line">+----------+------------+-------------+------------+</span><br><span class="line">| order_id | order_date | customer_id | product_id |</span><br><span class="line">+----------+------------+-------------+------------+</span><br><span class="line">| 1        | 2020-07-31 | 1           | 1          |</span><br><span class="line">| 2        | 2020-07-30 | 2           | 2          |</span><br><span class="line">| 3        | 2020-08-29 | 3           | 3          |</span><br><span class="line">| 4        | 2020-07-29 | 4           | 1          |</span><br><span class="line">| 5        | 2020-06-10 | 1           | 2          |</span><br><span class="line">| 6        | 2020-08-01 | 2           | 1          |</span><br><span class="line">| 7        | 2020-08-01 | 3           | 1          |</span><br><span class="line">| 8        | 2020-08-03 | 1           | 2          |</span><br><span class="line">| 9        | 2020-08-07 | 2           | 3          |</span><br><span class="line">| 10       | 2020-07-15 | 1           | 2          |</span><br><span class="line">+----------+------------+-------------+------------+</span><br><span class="line"></span><br><span class="line">Products</span><br><span class="line">+------------+--------------+-------+</span><br><span class="line">| product_id | product_name | price |</span><br><span class="line">+------------+--------------+-------+</span><br><span class="line">| 1          | keyboard     | 120   |</span><br><span class="line">| 2          | mouse        | 80    |</span><br><span class="line">| 3          | screen       | 600   |</span><br><span class="line">| 4          | hard disk    | 450   |</span><br><span class="line">+------------+--------------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+--------------+------------+----------+------------+</span><br><span class="line">| product_name | product_id | order_id | order_date |</span><br><span class="line">+--------------+------------+----------+------------+</span><br><span class="line">| keyboard     | 1          | 6        | 2020-08-01 |</span><br><span class="line">| keyboard     | 1          | 7        | 2020-08-01 |</span><br><span class="line">| mouse        | 2          | 8        | 2020-08-03 |</span><br><span class="line">| screen       | 3          | 3        | 2020-08-29 |</span><br><span class="line">+--------------+------------+----------+------------+</span><br><span class="line">keyboard&#x27;s most recent order is in 2020-08-01, it was ordered two times this day.</span><br><span class="line">mouse&#x27;s most recent order is in 2020-08-03, it was ordered only once this day.</span><br><span class="line">screen&#x27;s most recent order is in 2020-08-29, it was ordered only once this day.</span><br><span class="line">The hard disk was never ordered and we don&#x27;t include it in the result table.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_name,product_id,order_id,order_date</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> product_name ,o.product_id ,order_id,order_date ,</span><br><span class="line">    <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> o.product_id <span class="keyword">order</span> <span class="keyword">by</span> order_date <span class="keyword">desc</span>) rk</span><br><span class="line"><span class="keyword">from</span> Orders o <span class="keyword">left</span> <span class="keyword">join</span> Products p</span><br><span class="line"><span class="keyword">on</span> o.product_id <span class="operator">=</span>p.product_id </span><br><span class="line">)t1</span><br><span class="line"><span class="keyword">where</span> rk <span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> product_name,product_id,order_id</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode数据库题目集合--123题</summary>
    
    
    
    <category term="SQL" scheme="https://www.buildworld.cn/categories/SQL/"/>
    
    
    <category term="LeetCode" scheme="https://www.buildworld.cn/tags/LeetCode/"/>
    
    <category term="笔试题" scheme="https://www.buildworld.cn/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>BigData-数据仓库学习</title>
    <link href="https://www.buildworld.cn/2021/01/07/BigData-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.buildworld.cn/2021/01/07/BigData-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-07T11:35:36.000Z</published>
    <updated>2021-04-09T02:14:48.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、相关技术"><a href="#一、相关技术" class="headerlink" title="一、相关技术"></a>一、相关技术</h3><h4 id="1、技术选型"><a href="#1、技术选型" class="headerlink" title="1、技术选型"></a>1、技术选型</h4><p><img src="https://file.buildworld.cn/img/20201224104550.png"></p><h4 id="2、系统数据流程设计"><a href="#2、系统数据流程设计" class="headerlink" title="2、系统数据流程设计"></a>2、系统数据流程设计</h4><p><img src="https://file.buildworld.cn/img/20201224142101.png"></p><h3 id="二、数仓分层"><a href="#二、数仓分层" class="headerlink" title="二、数仓分层"></a>二、数仓分层</h3><h4 id="1、数据仓库分层"><a href="#1、数据仓库分层" class="headerlink" title="1、数据仓库分层"></a>1、数据仓库分层</h4><p><img src="https://file.buildworld.cn/img/20210107104843.png"></p><h4 id="2、范式理论"><a href="#2、范式理论" class="headerlink" title="2、范式理论"></a>2、范式理论</h4><blockquote><ul><li>第一范式：属性不可分割性。</li><li>第二范式：不能存在“部分函数依赖”</li><li>第三范式：不能存在传递函数依赖。</li></ul></blockquote><h4 id="3、关系建模和维度建模"><a href="#3、关系建模和维度建模" class="headerlink" title="3、关系建模和维度建模"></a>3、关系建模和维度建模</h4><blockquote><ul><li><p><strong>联机事务处理OLTP（on-line transaction processing）</strong></p><p>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</p></li><li><p><strong>联机分析处理OLAP（On-Line Analytical Processing）</strong></p><p>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p><p>二者对比</p><table><thead><tr><th align="center">对比属性</th><th>OLTP</th><th>OLAP</th></tr></thead><tbody><tr><td align="center">读特性</td><td>每次查询只返回少量记录</td><td>对大量记录进行汇总</td></tr><tr><td align="center">写特性</td><td>随机、低延时写入用户的输入</td><td>批量导入</td></tr><tr><td align="center">使用场景</td><td>用户，Java EE项目</td><td>内部分析师，为决策提供支持</td></tr><tr><td align="center">数据表征</td><td>最新数据状态</td><td>随时间变化的历史状态</td></tr><tr><td align="center">数据规模</td><td>GB</td><td>TB到PB</td></tr></tbody></table></li></ul></blockquote><h5 id="3-1-关系建模"><a href="#3-1-关系建模" class="headerlink" title="3.1 关系建模"></a>3.1 关系建模</h5><blockquote><p><strong>关系模型</strong>如图所示，严格遵循第三范式（3NF），从图中可以看出，较为松散、零碎，物理表数量多，而数据冗余程度低。由于数据分布于众多的表中，这些数据可以更为灵活地被应用，功能性较强。关系模型主要应用与OLTP系统中，为了保证数据的一致性以及避免冗余，所以大部分业务系统的表都是遵循第三范式的。</p><p><img src="https://file.buildworld.cn/img/20210107161933.png"></p></blockquote><h5 id="3-2维度建模"><a href="#3-2维度建模" class="headerlink" title="3.2维度建模"></a>3.2维度建模</h5><blockquote><p><strong>维度模型</strong>如图所示，主要应用于OLAP系统中，通常以某一个事实表为中心进行表的组织，主要面向业务，特征是可能存在数据的冗余，但是能方便的得到数据。</p><p><img src="https://file.buildworld.cn/img/20210107162057.png"></p></blockquote><p><strong>关系模型虽然冗余少，但是在大规模数据，跨表分析统计查询过程中，会造成多表关联，这会大大降低执行效率。所以通常我们采用维度模型建模，把相关各种表整理成两种：事实表和维度表两种。</strong></p><h4 id="4、维度表和事实表"><a href="#4、维度表和事实表" class="headerlink" title="4、维度表和事实表"></a>4、维度表和事实表</h4><h5 id="4-1维度表"><a href="#4-1维度表" class="headerlink" title="4.1维度表"></a>4.1维度表</h5><blockquote><p><strong>维度表</strong>：一般是对事实的描述信息。每一张维表对应现实世界中的一个对象或者概念。   例如：用户、商品、日期、地区等。</p><ul><li> 维表的范围很宽（具有多个属性、列比较多）</li><li> 跟事实表相比，行数相对较小：通常&lt; 10万条</li><li> 内容相对固定：编码表</li></ul></blockquote><h5 id="4-2事实表"><a href="#4-2事实表" class="headerlink" title="4.2事实表"></a>4.2事实表</h5><blockquote><p><strong>事实表中</strong>每行数据代表一个业务事件（下单、支付、退款、评价等）。“事实”这个术语表示的是业务事件的<strong>度量值（可统计次数、个数、金额等）</strong>，</p><ul><li> 非常的大</li><li> 内容相对的窄：列数较少（主要是外键id和度量值）</li><li> 经常发生变化，每天会新增加很多。</li></ul></blockquote><blockquote><p><strong>1）事务型事实表</strong></p><p>以<strong>每个事务或事件为单位</strong>，例如一个销售订单记录，一笔支付记录等，作为事实表里的一行数据。一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。</p><p><strong>2）周期型快照事实表</strong></p><p>周期型快照事实表中<strong>不会保留所有数据，只保留固定时间间隔的数据</strong>，例如每天或者每月的销售额，或每月的账户余额等。</p><p>例如购物车，有加减商品，随时都有可能变化，但是我们更关心每天结束时这里面有多少商品，方便我们后期统计分析。</p><p><strong>3）累积型快照事实表</strong></p><p><strong>累计快照事实表用于跟踪业务事实的变化。</strong>例如，数据仓库中可能需要累积或者存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。</p></blockquote><h4 id="5、维度模型分类"><a href="#5、维度模型分类" class="headerlink" title="5、维度模型分类"></a>5、维度模型分类</h4><h5 id="5-1、星型模型"><a href="#5-1、星型模型" class="headerlink" title="5.1、星型模型"></a>5.1、星型模型</h5><blockquote><p>雪花模型与星型模型的区别主要在于维度的层级，标准的星型模型维度只有一层，而雪花模型可能会涉及多级<img src="https://file.buildworld.cn/img/20210107202646.png"></p></blockquote><h5 id="5-2、雪花模型"><a href="#5-2、雪花模型" class="headerlink" title="5.2、雪花模型"></a>5.2、雪花模型</h5><p><img src="https://file.buildworld.cn/img/20210107204147.png"></p><h5 id="5-3、星座模型"><a href="#5-3、星座模型" class="headerlink" title="5.3、星座模型"></a>5.3、星座模型</h5><blockquote><p>星座模型与前两种情况的区别是事实表的数量，星座模型是基于多个事实表的。</p></blockquote><p><img src="https://file.buildworld.cn/img/20210107210328.png"></p><h4 id="6、数据仓库建模"><a href="#6、数据仓库建模" class="headerlink" title="6、数据仓库建模"></a>6、数据仓库建模</h4><h5 id="6-1、ODS层"><a href="#6-1、ODS层" class="headerlink" title="6.1、ODS层"></a>6.1、ODS层</h5><blockquote><ul><li>用户行为数据</li><li>业务数据</li></ul></blockquote><h5 id="6-2、DWD层"><a href="#6-2、DWD层" class="headerlink" title="6.2、DWD层"></a>6.2、DWD层</h5><blockquote><p>DWD层需要构建维度模型，一般采用星型模型。见上面图</p><p><strong>维度建模一般按照以下四个步骤：</strong></p><p><code>选择业务过程→声明粒度→确认维度→确认事实</code></p><p><strong>（1）选择业务过程</strong></p><p>在业务系统中，挑选我们感兴趣的业务线，比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。</p><p>如果是中小公司，尽量把所有业务过程都选择。</p><p>如果是大公司（1000多张表），选择和需求相关的业务线。</p><p><strong>（2）声明粒度</strong></p><p>数据粒度指数据仓库的数据中保存数据的细化程度或综合程度的级别。</p><p>声明粒度意味着精确定义事实表中的一行数据表示什么，应该尽可能选择<strong>最小粒度</strong>，以此来应各种各样的需求。</p><p><strong>典型的粒度声明如下：</strong></p><p>订单事实表中一行数据表示的是一个订单中的一个商品项。</p><p>支付事实表中一行数据表示的是一个支付记录。</p><p><strong>（3）确定维度</strong></p><p>维度的主要作用是描述业务是事实，主要表示的是“谁，何处，何时”等信息。</p><p>确定维度的原则是：后续需求中是否要分析相关维度的指标。例如，需要统计，什么时间下的订单多，哪个地区下的订单多，哪个用户下的订单多。需要确定的维度就包括：时间维度、地区维度、用户维度。</p><p><strong>（4）确定事实</strong></p><p>此处的“事实”一词，指的是业务中的度量值（次数、个数、件数、金额，可以进行累加），例如订单金额、下单次数等。</p><p>在DWD层，以<strong>业务过程</strong>为建模驱动，基于每个具体业务过程的特点，构建<strong>最细粒度</strong>的明细层事实表。事实表可做适当的宽表化处理。</p></blockquote><h5 id="6-3-DWS和DWT层"><a href="#6-3-DWS和DWT层" class="headerlink" title="6.3 DWS和DWT层"></a>6.3 DWS和DWT层</h5><blockquote><p><code>DWS和DWT层的区别</code>：DWS层存放的所有主题对象当天的汇总行为，例如每个地区当天的下单次数，下单金额等，DWT层存放的是所有主题对象的累积行为，例如每个地区最近７天（15天、30天、60天）的下单次数、下单金额等。</p></blockquote><h5 id="6-4-ADS层"><a href="#6-4-ADS层" class="headerlink" title="6.4 ADS层"></a>6.4 ADS层</h5><h3 id="三、流批一体架构"><a href="#三、流批一体架构" class="headerlink" title="三、流批一体架构"></a>三、流批一体架构</h3><h4 id="1、传统数仓架构（Lambda）"><a href="#1、传统数仓架构（Lambda）" class="headerlink" title="1、传统数仓架构（Lambda）"></a>1、传统数仓架构（Lambda）</h4><p><img src="https://file.buildworld.cn/img/20210115195432.png"></p><blockquote><p>传统的Lambda架构分为：</p><ul><li>业务层</li><li>存储层</li><li>计算层</li><li>服务层</li><li>应用层</li></ul></blockquote><p>传统的架构很灵活，流和批之间没有相互耦合，但是也会<strong>带来的问题</strong>：</p><ul><li><strong>效率层面</strong>：流批底层数据模型不一致，导致应用层需要做大量的拼接逻辑（同比、环比、二次加工等），搭建效率低，且容易出错。</li><li><strong>成本层面</strong>：流批存储系统隔离（面向不同写入场景），提供的数据服务不一致，维护成本高。同时，手工创建数据同步任务，增加了开发成本和存储成本。</li><li><strong>质量与资源层面</strong>：首先，一个业务逻辑，两个引擎两套代码，SQL 逻辑不能复用，数据一致性和质量难以保障。其次，不同平台和引擎间切换，开发体验割裂，容易出现变更遗漏。并且，批处理&amp;流处理集群无法做到错峰，资源利用率较低。</li></ul><h4 id="2、流批一体架构（Kappa-Lambda）"><a href="#2、流批一体架构（Kappa-Lambda）" class="headerlink" title="2、流批一体架构（Kappa+Lambda）"></a>2、流批一体架构（Kappa+Lambda）</h4><p><strong>本质上是在流的场景中寻找批场景</strong></p><p><img src="https://file.buildworld.cn/img/20210115200803.png"></p><ul><li><strong>流批逻辑层</strong>：这是最重要的部分之一。业务层和存储层仍然不变，在此之上构建一个流批逻辑层来进行流存储和批存储的映射。有了这个逻辑层，就可以基于 Flink 引擎面向统一的逻辑层做业务逻辑表达，并且输出是统一的。</li><li><strong>计算层</strong>：做流批统一处理。首先，一套代码，两种计算模式，逻辑统一，灵活切换，可以实现研发效率大幅提升。其次，流批计算资源混部，资源利用率提升。</li><li><strong>服务层</strong>：做流批统一存储，无需手工同步，无重复存储。</li><li><strong>应用层</strong>：进行产品组装，流批存储透明化，查询逻辑完全一致，应用端接入成本大幅降低，点查 / OLAP 分析统一支持。</li></ul>]]></content>
    
    
    <summary type="html">数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Data WareHouse" scheme="https://www.buildworld.cn/tags/Data-WareHouse/"/>
    
  </entry>
  
  <entry>
    <title>算法学习记录</title>
    <link href="https://www.buildworld.cn/2020/11/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.buildworld.cn/2020/11/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-04T01:20:49.000Z</published>
    <updated>2021-04-09T02:15:11.754Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><h4 id="1、常见的数据结构"><a href="#1、常见的数据结构" class="headerlink" title="1、常见的数据结构"></a>1、常见的数据结构</h4><blockquote><p><code>「队列」</code>、<code>「栈」</code>这两种数据结构既可以使⽤链表也可以使⽤数组实现。⽤数组实现，就要处理扩容缩容的问题；⽤链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</p><p><code>「图」</code>的两种表⽰⽅法，邻接表就是链表，邻接矩阵就是⼆维数组。邻接矩阵判断连通性迅速，并可以进⾏矩阵运算解决⼀些问题，但是如果图⽐较稀疏的话很耗费空间。邻接表⽐较节省空间，但是很多操作的效率上肯定⽐不过邻接矩阵。</p><p><code>「散列表」</code>就是通过散列函数把键映射到⼀个⼤数组⾥。⽽且对于解决散列冲突的⽅法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p><p><code>「树」</code>，⽤数组实现就是「堆」，因为「堆」是⼀个完全⼆叉树，⽤数组存储不需要节点指针，操作也⽐较简单；⽤链表实现就是很常⻅的那种「树」，因为不⼀定是完全⼆叉树，所以不适合⽤数组存储。为此，在这种链表「树」结构之上，⼜衍⽣出各种巧妙的设计，⽐如⼆叉搜索树、AVL树、红⿊树、区间树、B 树等等，以应对不同的问题。</p></blockquote><h4 id="2、常见的算法框架"><a href="#2、常见的算法框架" class="headerlink" title="2、常见的算法框架"></a>2、常见的算法框架</h4><blockquote><p>数组遍历框架，典型的线性迭代结构：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>链表遍历框架，兼具迭代和递归结构：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (ListNode p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="comment">// 迭代访问 p.val</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 递归访问 head.val</span></span><br><span class="line">     traverse(head.next)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>⼆叉树遍历框架，典型的⾮线性递归遍历结构：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本的⼆叉树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root.left)</span><br><span class="line">        traverse(root.right)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><h4 id="1、斐波那契数列的算法优化"><a href="#1、斐波那契数列的算法优化" class="headerlink" title="1、斐波那契数列的算法优化"></a>1、斐波那契数列的算法优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列(备忘录)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] meno = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(meno, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] meno, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (meno[n] != <span class="number">0</span>) <span class="keyword">return</span> meno[n];</span><br><span class="line"></span><br><span class="line">    meno[n] = helper(meno, n - <span class="number">1</span>) + helper(meno, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> meno[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契数列(dp表)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//斐波那契数列(空间复杂度降为1)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、回溯算法"><a href="#三、回溯算法" class="headerlink" title="三、回溯算法"></a>三、回溯算法</h3><p><strong>纯暴力穷举算法，复杂度很高</strong></p><h4 id="回溯算法的框架："><a href="#回溯算法的框架：" class="headerlink" title="回溯算法的框架："></a>回溯算法的框架：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function">def <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> 满⾜结束条件:</span></span><br><span class="line"><span class="function">result.<span class="title">add</span><span class="params">(路径)</span></span></span><br><span class="line"><span class="function">return</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">做选择</span></span><br><span class="line"><span class="function"><span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span></span><br><span class="line"><span class="function">撤销选择</span></span><br></pre></td></tr></table></figure><h4 id="1、全排列算法"><a href="#1、全排列算法" class="headerlink" title="1、全排列算法"></a>1、全排列算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 全排列代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-11-04 08:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuanPaiLie</span> </span>&#123;</span><br><span class="line">    <span class="comment">//路径集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结果：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = permute(nums);</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  路径：记录在 track 中</span></span><br><span class="line"><span class="comment">     *  选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">     *  结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 需要排列的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> track 存放的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到底了，跳出此方法</span></span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            backtrack(nums, track);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、BFS算法"><a href="#四、BFS算法" class="headerlink" title="四、BFS算法"></a>四、BFS算法</h3><p><strong>图的搜索算法分为BDF（广度优先搜索）和（深度优先搜索）</strong></p><h4 id="BFS框架"><a href="#BFS框架" class="headerlink" title="BFS框架"></a>BFS框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核⼼数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免⾛回头路</span></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加⼊队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这⾥判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">            <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加⼊队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                q.offer(x);</span><br><span class="line">                visited.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这⾥ */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></h4><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS的时间复杂度比BFS高，但是DFS的空间复杂度比BFS低。</p><p>DFS在最坏的情况下空间复杂度为O(logN)，而BFS最坏情况下的空间复杂度为O(N)。</p></blockquote><h3 id="五、二分搜索"><a href="#五、二分搜索" class="headerlink" title="五、二分搜索"></a>五、二分搜索</h3><h4 id="零、⼆分查找框架"><a href="#零、⼆分查找框架" class="headerlink" title="零、⼆分查找框架"></a>零、⼆分查找框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">        <span class="keyword">while</span> (...)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><blockquote><p>题目地址： <a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">编程=数据结构+算法</summary>
    
    
    
    <category term="算法" scheme="https://www.buildworld.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://www.buildworld.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数据结构" scheme="https://www.buildworld.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>BigData--分布式流数据流引擎Apache Flink</title>
    <link href="https://www.buildworld.cn/2020/09/11/BigData-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BC%95%E6%93%8EApache-Flink/"/>
    <id>https://www.buildworld.cn/2020/09/11/BigData-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BC%95%E6%93%8EApache-Flink/</id>
    <published>2020-09-11T02:59:30.000Z</published>
    <updated>2021-04-09T02:15:45.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://flink.apache.org/img/flink-header-logo.svg"></p><p><a href="https://flink.apache.org/">官网：https://flink.apache.org/</a></p><h3 id="一、Flink的重要特点"><a href="#一、Flink的重要特点" class="headerlink" title="一、Flink的重要特点"></a>一、Flink的重要特点</h3><h4 id="1）事件驱动型（Event-driven）"><a href="#1）事件驱动型（Event-driven）" class="headerlink" title="1）事件驱动型（Event-driven）"></a>1）事件驱动型（Event-driven）</h4><blockquote><ul><li><code>事件驱动的应用程序</code>是一个有状态的应用程序，它从一个或多个事件流接收事件，并通过触发计算、状态更新或外部操作对传入事件作出反应。</li><li><code>事件驱动应用程序</code>是传统应用程序设计的一种发展，它具有分离的计算和数据存储层。在这种体系结构中，应用程序从远程事务数据库读取数据并将其持久化。</li><li>相反，<code>事件驱动应用程序</code>基于有状态流处理应用程序。在这个设计中，数据和计算被放在同一个位置，从而产生本地（内存或磁盘）数据访问。容错是通过定期将检查点写入远程持久存储来实现的。下图描述了传统应用程序体系结构与事件驱动应用程序之间的区别。</li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20200911125128.png"></p><p><strong>kafka作为消息队列就是一种典型的事件驱动型应用。</strong></p><h4 id="2）-流、批（stream，micro-batching）"><a href="#2）-流、批（stream，micro-batching）" class="headerlink" title="2） 流、批（stream，micro-batching）"></a>2） 流、批（stream，micro-batching）</h4><blockquote><p><code>Spark</code>中，一切都是批次组成的，离线数据是一个大批次，实时数据是一个个无限的小批次组成的。</p><p><code>Flink</code>中，一切都是由流组成的，离线数据是有界限的流，实时数据是一个没有界限的流，这就是所谓的有界流和无界流。</p></blockquote><h4 id="3）分层API"><a href="#3）分层API" class="headerlink" title="3）分层API"></a>3）分层API</h4><p><img src="https://file.buildworld.cn/img/20200911155213.png"></p><blockquote><p>越顶层越抽象，最高层级的抽象是SQL。</p><p>越底层越具体</p></blockquote><h3 id="二、Flink使用（word-count）"><a href="#二、Flink使用（word-count）" class="headerlink" title="二、Flink使用（word count）"></a>二、Flink使用（word count）</h3><h4 id="1、设置pom文件"><a href="#1、设置pom文件" class="headerlink" title="1、设置pom文件"></a>1、设置pom文件</h4><blockquote><p>注意下面的依赖设置，使用的是scala 2.12.x版本，Flink版本为1.10.1</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.buildworld.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>FlinkTrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-scala --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、编写scala代码"><a href="#2、编写scala代码" class="headerlink" title="2、编写scala代码"></a>2、编写scala代码</h4><h5 id="1）批处理-wordcount"><a href="#1）批处理-wordcount" class="headerlink" title="1）批处理 wordcount"></a>1）批处理 wordcount</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.flink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala.&#123;<span class="type">DataSet</span>, <span class="type">ExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理的word count</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个批处理的执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">ExecutionEnvironment</span> = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> inputPath = <span class="string">&quot;D:\\Java\\project\\Scala\\FlinkTrain\\src\\main\\resources\\hello.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataSet: <span class="type">DataSet</span>[<span class="type">String</span>] = env.readTextFile(inputPath)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行转换处理统计，先分词，再按照word进行分组，最后进行聚合统计</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultDataSet: <span class="type">DataSet</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataSet</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_, <span class="number">1</span>))</span><br><span class="line">      .groupBy(<span class="number">0</span>) <span class="comment">//以第一个元素为key进行分组</span></span><br><span class="line">      .sum(<span class="number">1</span>) <span class="comment">//对所有数据的第二个元素求和</span></span><br><span class="line"></span><br><span class="line">    resultDataSet.print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）流处理wordcount"><a href="#2）流处理wordcount" class="headerlink" title="2）流处理wordcount"></a>2）流处理wordcount</h5><p><strong>超级简单，比sparkstreaming的流式处理简单多了！！！</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流处理的word count</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountByStream</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个批处理的执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置并行度</span></span><br><span class="line">    env.setParallelism(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从端口中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> dataSet: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;192.168.162.102&quot;</span>, <span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行转换处理统计，先分词，再按照word进行分组，最后进行聚合统计</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultDataSet = dataSet</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .filter(_.nonEmpty)</span><br><span class="line">      .map((_, <span class="number">1</span>))</span><br><span class="line">      .keyBy(<span class="number">0</span>) <span class="comment">//以第一个元素为key进行分组</span></span><br><span class="line">      .sum(<span class="number">1</span>) <span class="comment">//对所有数据的第二个元素求和</span></span><br><span class="line"></span><br><span class="line">    resultDataSet.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动任务执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.<span class="type">ParameterTool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以冲启动参数里面读取指定的参数</span></span><br><span class="line"><span class="keyword">val</span> parameterTool: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"><span class="keyword">val</span> host: <span class="type">String</span> = parameterTool.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> port: <span class="type">Int</span> = parameterTool.getInt(<span class="string">&quot;port&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="三、Flink-运行架构"><a href="#三、Flink-运行架构" class="headerlink" title="三、Flink 运行架构"></a>三、Flink 运行架构</h3><h4 id="1、Flink运行时组件"><a href="#1、Flink运行时组件" class="headerlink" title="1、Flink运行时组件"></a>1、Flink运行时组件</h4><p><img src="https://file.buildworld.cn/img/20200914200131.png"></p><blockquote><ul><li><p><strong>作业管理器（JobManager）</strong><br>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager 所控制执行。JobManager 会先接收到要执行的应用程序，这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的 JAR 包。JobManager 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的<br>TaskManager 上。而在运行过程中，JobManager 会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</p></li><li><p><strong>资源管理器（ResourceManager）</strong><br>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger 插槽是 Flink 中<br>定义的处理资源单元。Flink 为不同的环境和资源管理工具提供了不同资源管理器，比如<br>YARN、Mesos、K8s，以及 standalone 部署。当 JobManager 申请插槽资源时，ResourceManager会将有空闲插槽的 TaskManager 分配给 JobManager。如果 ResourceManager 没有足够的插槽来满足 JobManager 的请求，它还可以向资源提供平台发起会话，以提供启动 TaskManager进程的容器。另外，ResourceManager 还负责终止空闲的 TaskManager，释放计算资源。</p></li><li><p><strong>任务管理器（TaskManager）</strong></p><p>Flink 中的工作进程。通常在 Flink 中会有多个 TaskManager 运行，每一个 TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了 TaskManager 能够执行的任务数量。<br>启动之后，TaskManager 会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager 就会将一个或者多个插槽提供给 JobManager 调用。JobManager 就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个 TaskManager 可以跟其它运行同一应用程<br>序的 TaskManager 交换数据。</p></li><li><p><strong>分发器（Dispatcher）</strong></p><p>可以跨作业运行，它为应用提交提供了 REST 接口。当一个应用被提交执行时，分发器<br>就会启动并将应用移交给一个 JobManager。由于是 REST 接口，所以 Dispatcher 可以作为集<br>群的一个 HTTP 接入点，这样就能够不受防火墙阻挡。Dispatcher 也会启动一个 Web UI，用<br>来方便地展示和监控作业执行的信息。Dispatcher 在架构中可能并不是必需的，这取决于应<br>用提交运行的方式。</p></li></ul></blockquote><h4 id="2、任务提交流程"><a href="#2、任务提交流程" class="headerlink" title="2、任务提交流程"></a>2、任务提交流程</h4><p><img src="https://file.buildworld.cn/img/20200914205020.png"></p><h4 id="3、任务调度原理"><a href="#3、任务调度原理" class="headerlink" title="3、任务调度原理"></a>3、任务调度原理</h4><p>Task Slot  是静态的概念，是指 TaskManager  具有的并发执行能力，可以通过参数 taskmanager.numberOfTaskSlots 进行配置；而 并行度 parallelism  是动态概念 ，即 即 TaskManager  运行程序时实际使用的并发能力，可以通过参数 parallelism.default进行配置。</p><h3 id="四、Flink流处理API"><a href="#四、Flink流处理API" class="headerlink" title="四、Flink流处理API"></a>四、Flink流处理API</h3><h4 id="1、三种不同方式读取数据"><a href="#1、三种不同方式读取数据" class="headerlink" title="1、三种不同方式读取数据"></a>1、三种不同方式读取数据</h4><p>bin/kafka-topics.sh  –zookeeper localhost:2181 –list</p><p>bin/kafka-topics.sh  –zookeeper localhost:2181 –create –replication-factor 3 –partitions 1 –topic sensor</p><p>bin/kafka-console-producer.sh –broker-list 10.81.1.56:9092 –topic sensor</p><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –from-beginning –topic sensor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor_1, 1547718199, 35.8</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer011</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义样例类，温度传感器</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //1、从集合中读取数据</span></span><br><span class="line"><span class="comment">//    val data = List(</span></span><br><span class="line"><span class="comment">//      SensorReading(&quot;sensor_1&quot;, 1547718199, 35.8),</span></span><br><span class="line"><span class="comment">//      SensorReading(&quot;sensor_6&quot;, 1547718201, 15.4),</span></span><br><span class="line"><span class="comment">//      SensorReading(&quot;sensor_7&quot;, 1547718202, 6.7),</span></span><br><span class="line"><span class="comment">//      SensorReading(&quot;sensor_10&quot;, 1547718205, 38.1)</span></span><br><span class="line"><span class="comment">//    )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    val stream1: DataStream[SensorReading] = env.fromCollection(data)</span></span><br><span class="line"><span class="comment">//    stream1.print()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //2、从文件中读取数据</span></span><br><span class="line"><span class="comment">//    val stream2 = env.readTextFile(&quot;YOUR_FILE_PATH&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从kafka中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream3: <span class="type">DataStream</span>[<span class="type">String</span>] = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value: <span class="type">DataStream</span>[<span class="type">String</span>] = stream3.flatMap(_.split(<span class="string">&quot;,&quot;</span>)).filter(_.nonEmpty)</span><br><span class="line"></span><br><span class="line">    value.print()</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、自定义-Source"><a href="#2、自定义-Source" class="headerlink" title="2、自定义 Source"></a>2、自定义 Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySensorSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flag: 表示数据源是否还在正常运行</span></span><br><span class="line">  <span class="keyword">var</span> running: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(sourceContext: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定义一个随机数发生器</span></span><br><span class="line">    <span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成一组传感器的初始温度</span></span><br><span class="line">    <span class="keyword">var</span> curTemp = <span class="number">1.</span>to(<span class="number">10</span>).map(</span><br><span class="line">      i =&gt; (<span class="string">&quot;sensor_&quot;</span> + i, <span class="number">65</span> + rand.nextGaussian() * <span class="number">20</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">      <span class="comment">//更新温度值</span></span><br><span class="line">      curTemp = curTemp.map(</span><br><span class="line">        t =&gt; (t._1, t._2 + rand.nextGaussian())</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取当前的时间戳</span></span><br><span class="line">      <span class="keyword">val</span> curTime: <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">      curTemp.foreach(</span><br><span class="line">        t =&gt; sourceContext.collect(<span class="type">SensorReading</span>(t._1, curTime, t._2))</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      num+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">5</span>)&#123;</span><br><span class="line">        cancel()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用自定义Source"><a href="#使用自定义Source" class="headerlink" title="使用自定义Source"></a>使用自定义Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream4: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MySensorSource</span>())</span><br><span class="line">stream4.print()</span><br></pre></td></tr></table></figure><h4 id="3、Transform转换算子"><a href="#3、Transform转换算子" class="headerlink" title="3、Transform转换算子"></a>3、Transform转换算子</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><h5 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h5><h5 id="滚动聚合算子（Rolling-Aggregation）"><a href="#滚动聚合算子（Rolling-Aggregation）" class="headerlink" title="滚动聚合算子（Rolling Aggregation）"></a>滚动聚合算子（Rolling Aggregation）</h5><blockquote><p>这些算子可以针对 KeyedStream 的每一个支流做聚合。</p><p>sum()<br>min()<br>max()<br>minBy()<br>maxBy()</p></blockquote><h5 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h5><blockquote><p><code>KeyedStream</code> → → <code>DataStream</code>：一个分组数据流的聚合操作，合并当前的元素和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是只返回最后一次聚合的最终结果。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultStream = dataStream</span><br><span class="line">  .keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">  .reduce((curState, newData) =&gt;</span><br><span class="line">    <span class="type">SensorReading</span>(curState.id, newData.timestamp, curState.temperature.min(newData.temperature))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h5 id="Split-和-和-Select"><a href="#Split-和-和-Select" class="headerlink" title="Split 和 和 Select"></a>Split 和 和 Select</h5><p><img src="https://file.buildworld.cn/img/20201011165829.png" alt="DataStream → → SplitStream：根据某些特征把一个 DataStream 拆分成两个或者多个 DataStream。"></p><p><img src="https://file.buildworld.cn/img/20201011165909.png" alt="SplitStream →DataStream：从一个 SplitStream 中获取一个或者多个DataStream。"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultStream = dataStream</span><br><span class="line">  .keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">  .reduce((curState, newData) =&gt;</span><br><span class="line">    <span class="type">SensorReading</span>(curState.id, newData.timestamp, curState.temperature.min(newData.temperature))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据过滤，按照指定条件将数据分开来</span></span><br><span class="line"><span class="keyword">val</span> splitStream = resultStream.split(data =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.temperature &gt; <span class="number">30</span>)</span><br><span class="line">    <span class="type">Seq</span>(<span class="string">&quot;high&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="type">Seq</span>(<span class="string">&quot;low&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> high = splitStream.select(<span class="string">&quot;high&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> low = splitStream.select(<span class="string">&quot;low&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> all = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="Connect和CoMap"><a href="#Connect和CoMap" class="headerlink" title="Connect和CoMap"></a>Connect和CoMap</h5><p><img src="https://file.buildworld.cn/img/20201012100125.png"></p><p><img src="https://file.buildworld.cn/img/20201012100146.png"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warning: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = high.map(sensorData =&gt; (sensorData.id, sensorData.temperature))</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataStream,DataStream → → ConnectedStreams：连接两个保持他们类型的数据流，两个数据流被 Connect 之后，只是被放在了一个同一个流中，内部依然保持各自的数据和形式不发生任何变化，两个流相互独立。</span></span><br><span class="line"><span class="keyword">val</span> connected: <span class="type">ConnectedStreams</span>[(<span class="type">String</span>, <span class="type">Double</span>), <span class="type">SensorReading</span>] = warning.connect(low)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectedStreams → DataStream：作用于 ConnectedStreams 上，功能与 map和 flatMap 一样，对 ConnectedStreams 中的每一个 Stream 分别进行 map 和 flatMap处理。</span></span><br><span class="line"><span class="keyword">val</span> coMap: <span class="type">DataStream</span>[<span class="type">Product</span>] = connected.map(</span><br><span class="line">  warningData =&gt; (warningData._1, warningData._2, <span class="string">&quot;WARNING&quot;</span>),</span><br><span class="line">  lowData =&gt; (lowData.id, lowData.temperature, <span class="string">&quot;SAFE&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">coMap.print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">10</span>&gt; (sensor_7,<span class="number">6.7</span>,<span class="type">SAFE</span>)</span><br><span class="line"><span class="number">8</span>&gt; (sensor_6,<span class="number">15.4</span>,<span class="type">SAFE</span>)</span><br><span class="line"><span class="number">6</span>&gt; (sensor_10,<span class="number">38.1</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br><span class="line"><span class="number">7</span>&gt; (sensor_1,<span class="number">30.8</span>,<span class="type">WARNING</span>)</span><br></pre></td></tr></table></figure><h5 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h5><p><img src="https://file.buildworld.cn/img/20201012101514.png"></p><blockquote><ul><li>Union 之前两个流的类型必须是一样，Connect 可以不一样，在之后的 coMap中再去调整成为一样的。</li><li>Connect 只能操作两个流，Union 可以操作多个。</li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unionStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = high.union(low)</span><br><span class="line">unionStream.print(<span class="string">&quot;union:::&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="4、支持的数据类型"><a href="#4、支持的数据类型" class="headerlink" title="4、支持的数据类型"></a>4、支持的数据类型</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">val</span> numbers: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.fromElements(<span class="number">1</span>L, <span class="number">2</span>L, <span class="number">3</span>L, <span class="number">4</span>L)</span><br><span class="line"><span class="keyword">val</span> res: <span class="type">DataStream</span>[<span class="type">Long</span>] = numbers.map(n =&gt; n + <span class="number">1</span>)</span><br><span class="line">res.print(<span class="string">&quot;相加：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">val</span> persons1: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = env.fromElements(</span><br><span class="line">  (<span class="string">&quot;michong&quot;</span>, <span class="number">25</span>),</span><br><span class="line">  (<span class="string">&quot;lili&quot;</span>, <span class="number">15</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//元组数据过滤</span></span><br><span class="line"><span class="keyword">val</span> res1: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = persons1.filter(p =&gt; p._2 &gt; <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala样例类</span></span><br><span class="line"><span class="keyword">val</span> persons2: <span class="type">DataStream</span>[<span class="type">Person</span>] = env.fromElements(</span><br><span class="line">  <span class="type">Person</span>(<span class="string">&quot;MiChong&quot;</span>, <span class="number">25</span>),</span><br><span class="line">  <span class="type">Person</span>(<span class="string">&quot;Lili&quot;</span>, <span class="number">15</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> res2: <span class="type">DataStream</span>[<span class="type">Person</span>] = persons2.filter(</span><br><span class="line">  p =&gt; p.age &gt; <span class="number">18</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">res2.print(<span class="string">&quot;成年人： &quot;</span>)</span><br><span class="line">env.execute()</span><br></pre></td></tr></table></figure><h4 id="5、实现-UDF-函数——更细粒度的控制流"><a href="#5、实现-UDF-函数——更细粒度的控制流" class="headerlink" title="5、实现 UDF 函数——更细粒度的控制流"></a>5、实现 UDF 函数——更细粒度的控制流</h4><h6 id="函数类（Function-Classes）"><a href="#函数类（Function-Classes）" class="headerlink" title="函数类（Function Classes）"></a>函数类（Function Classes）</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> res2: <span class="type">DataStream</span>[<span class="type">Person</span>] = persons2.filter(<span class="keyword">new</span> <span class="type">MyFilter</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">FilterFunction</span>[<span class="type">Person</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">Person</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    p.age &gt; <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="富函数（Rich-Functions）"><a href="#富函数（Rich-Functions）" class="headerlink" title="富函数（Rich Functions）"></a>富函数（Rich Functions）</h6><blockquote><p>“富函数”是 DataStream API 提供的一个函数类的接口，所有 Flink 函数类都有其 Rich 版本。它与常规函数的不同在于，可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能。</p><p><strong>生命周期</strong></p><ul><li><code>open()</code>方法是 rich function 的初始化方法，当一个算子例如 map 或者 filter被调用之前 open()会被调用。</li><li><code>close()</code>方法是生命周期中的最后一个调用的方法，做一些清理工作。</li><li><code>getRuntimeContext()</code>方法提供了函数的 RuntimeContext 的一些信息，例如函数执行的并行度，任务的名字，以及 state 状态</li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>[<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">Int</span>)] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> subTaskIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    subTaskIndex = getRuntimeContext.getIndexOfThisSubtask</span><br><span class="line">    <span class="comment">//做一些初始化工作，建立HDFS的连接</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(in: <span class="type">Int</span>, collector: <span class="type">Collector</span>[(<span class="type">Int</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (in % <span class="number">2</span> == subTaskIndex) &#123;</span><br><span class="line">      collector.collect((subTaskIndex, in))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 以下做一些清理工作，断开HDFS的连接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sink"><a href="#6、Sink" class="headerlink" title="6、Sink"></a>6、Sink</h4><blockquote><p>Flink的对外输出操作</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.&#123;<span class="type">FlinkKafkaConsumer011</span>, <span class="type">FlinkKafkaProducer011</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义样例类，温度传感器</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从kafka中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.12.42.174:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    <span class="comment">//    properties.setProperty(&quot;auto.offset.reset&quot;, &quot;latest&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream3: <span class="type">DataStream</span>[<span class="type">String</span>] = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将从kafka获取的数据处理</span></span><br><span class="line">    <span class="keyword">val</span> outputStream: <span class="type">DataStream</span>[<span class="type">String</span>] = stream3.map(</span><br><span class="line">      data =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">SensorReading</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, arr(<span class="number">2</span>).toDouble).toString</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将处处之后的数据重新发送到kafka中</span></span><br><span class="line">    outputStream.addSink(<span class="keyword">new</span> <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>](<span class="string">&quot;10.12.42.174:9092&quot;</span>, <span class="string">&quot;sensor_res&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>()))</span><br><span class="line">    outputStream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="JDBC自定义sink"><a href="#JDBC自定义sink" class="headerlink" title="JDBC自定义sink"></a>JDBC自定义sink</h6><blockquote><p>数据从Kafka获取，然后进行dataStream转换，最后将结果保存在mysql中</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.&#123;<span class="type">RichSinkFunction</span>, <span class="type">SinkFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.&#123;<span class="type">FlinkKafkaConsumer011</span>, <span class="type">FlinkKafkaProducer011</span>&#125;</span><br><span class="line"><span class="comment">// 定义样例类，温度传感器</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从kafka中读取数据</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.12.42.174:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    <span class="comment">//    properties.setProperty(&quot;auto.offset.reset&quot;, &quot;latest&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream3: <span class="type">DataStream</span>[<span class="type">String</span>] = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将从kafka获取的数据处理</span></span><br><span class="line">    <span class="keyword">val</span> outputStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = stream3.map(</span><br><span class="line">      data =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">SensorReading</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, arr(<span class="number">2</span>).toDouble)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将处处之后的数据重新发送到kafka中</span></span><br><span class="line">    <span class="comment">//    outputStream.addSink(new FlinkKafkaProducer011[String](&quot;10.12.42.174:9092&quot;, &quot;sensor_res&quot;, new SimpleStringSchema()))</span></span><br><span class="line">    <span class="comment">//    outputStream.print()</span></span><br><span class="line"></span><br><span class="line">    outputStream.addSink(<span class="keyword">new</span> <span class="type">MyJdbcSink</span>())</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义关于Sink的JDBC连接处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcSink</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化自定义参数</span></span><br><span class="line">  <span class="keyword">var</span> conn: <span class="type">Connection</span> = _</span><br><span class="line">  <span class="keyword">var</span> insertStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line">  <span class="keyword">var</span> updateStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建数据库连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    conn = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://10.12.42.174/flink&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">    insertStmt = conn.prepareStatement(<span class="string">&quot;insert into sensor_temp(id,temp) values (?,?)&quot;</span>)</span><br><span class="line">    updateStmt = conn.prepareStatement(<span class="string">&quot;update sensor_temp set temp =? where id = ? &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">SensorReading</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>[_]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先执行更新程序，查到就更新</span></span><br><span class="line">    updateStmt.setDouble(<span class="number">1</span>, value.temperature)</span><br><span class="line">    updateStmt.setString(<span class="number">2</span>, value.id)</span><br><span class="line">    updateStmt.execute()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有更新的内容就插入</span></span><br><span class="line">    <span class="keyword">if</span> (updateStmt.getUpdateCount == <span class="number">0</span>) &#123;</span><br><span class="line">      insertStmt.setString(<span class="number">1</span>, value.id)</span><br><span class="line">      insertStmt.setDouble(<span class="number">2</span>, value.temperature)</span><br><span class="line">      insertStmt.execute()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    insertStmt.close()</span><br><span class="line">    updateStmt.close()</span><br><span class="line">    conn.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Flink中的Window"><a href="#五、Flink中的Window" class="headerlink" title="五、Flink中的Window"></a>五、Flink中的Window</h3><blockquote><p>Window是一种<strong>切割无限数据</strong>为<strong>有限块</strong>进行处理的手段。</p></blockquote><h4 id="1、Window类型"><a href="#1、Window类型" class="headerlink" title="1、Window类型"></a>1、Window类型</h4><ul><li>CountWindow:按照指定的数据条数生成一个window，和时间没有关系</li><li>TimeWindow:按照时间生成window</li></ul><h4 id="2、窗口实现原理的不同分成三类"><a href="#2、窗口实现原理的不同分成三类" class="headerlink" title="2、窗口实现原理的不同分成三类"></a>2、窗口实现原理的不同分成三类</h4><h5 id="1）滚动窗口（Tumbling-Windows"><a href="#1）滚动窗口（Tumbling-Windows" class="headerlink" title="1）滚动窗口（Tumbling Windows)"></a>1）滚动窗口（Tumbling Windows)</h5><blockquote><p>将数据依据<code>固定的窗口长度</code>对数据进行<code>切片</code>。</p><p><strong>特点：时间对齐，窗口长度固定，没有重叠。</strong></p></blockquote><h5 id="2）滑动窗口（Sliding-Windows）"><a href="#2）滑动窗口（Sliding-Windows）" class="headerlink" title="2）滑动窗口（Sliding Windows）"></a>2）滑动窗口（Sliding Windows）</h5><blockquote><p>滑动窗口由<code>固定的窗口长度</code>和<code>滑动间隔</code>组成。</p><p><strong>特点：时间对齐，窗口长度固定，可以有重叠</strong></p></blockquote><h5 id="3）会话窗口（Session-Windows"><a href="#3）会话窗口（Session-Windows" class="headerlink" title="3）会话窗口（Session Windows)"></a>3）会话窗口（Session Windows)</h5><blockquote><p>由一系列事件组合一个指定时间长度的 <code>timeout</code> 间隙组成，类似于 web 应用的session，也就是一段时间没有接收到新数据就会生成新的窗口。</p><p><strong>特点：时间无对齐。</strong></p><p><img src="https://file.buildworld.cn/img/20201013095706.png"></p></blockquote><h4 id="3、Window-API"><a href="#3、Window-API" class="headerlink" title="3、Window API"></a>3、Window API</h4><h5 id="TimeWindow"><a href="#TimeWindow" class="headerlink" title="TimeWindow"></a>TimeWindow</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将从kafka获取的数据处理</span></span><br><span class="line"><span class="keyword">val</span> outputStream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = stream3.map(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="type">SensorReading</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, arr(<span class="number">2</span>).toDouble)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">outputStream</span><br><span class="line">  .map(data =&gt; (data.id, data.temperature))</span><br><span class="line">  .keyBy(_._1) <span class="comment">//安装二元组的第一个元素（id）分组</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>)) <span class="comment">// 一个参数就是滚动窗口，两个参数就是滑动窗口</span></span><br><span class="line">  .window(<span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">15</span>),<span class="type">Time</span>.seconds(<span class="number">5</span>)))  <span class="comment">// 会话窗口</span></span><br><span class="line">  .reduce((curRes, newData) =&gt; (curRes._1, curRes._2.min(newData._2), newData._3))</span><br></pre></td></tr></table></figure><h5 id="CountWindow"><a href="#CountWindow" class="headerlink" title="CountWindow"></a>CountWindow</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outputStream</span><br><span class="line">  .map(data =&gt; (data.id, data.temperature))</span><br><span class="line">  .keyBy(_._1) <span class="comment">//安装二元组的第一个元素（id）分组</span></span><br><span class="line">  .countWindow(<span class="number">5</span>) <span class="comment">// 一个参数就是滚动窗口，两个参数就是滑动窗口</span></span><br><span class="line">  .reduce((curRes, newData) =&gt; (curRes._1, curRes._2.min(newData._2), newData._3))</span><br></pre></td></tr></table></figure><h4 id="4、window-function"><a href="#4、window-function" class="headerlink" title="4、window function"></a>4、window function</h4><blockquote><ul><li><strong>增量聚合函数（incremental aggregation functions）</strong><br>每条数据到来就进行计算，保持一个简单的状态。典型的增量聚合函数有ReduceFunction, AggregateFunction。</li><li><strong>全窗口函数（full window functions）</strong><br>先把窗口所有数据收集起来，等到计算的时候会遍历所有数据。ProcessWindowFunction 就是一个全窗口函数。</li></ul></blockquote><h3 id="六、时间语义与-Wartermark"><a href="#六、时间语义与-Wartermark" class="headerlink" title="六、时间语义与 Wartermark"></a>六、时间语义与 Wartermark</h3><p><strong>在 Flink  的流式处理中，绝大部分的业务都会使用 <code>eventTime</code></strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建执行环境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">// 从调用时刻开始给 env 创建的每一个 stream 追加时间特征</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure><h4 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h4><ul><li>Watermark 是一种衡量 Event Time 进展的机制。</li><li><strong>Watermark  是用于处理乱序事件的</strong>，而正确的处理乱序事件，通常用Watermark 机制结合 window 来实现。</li><li>数据流中的 Watermark 用于表示 timestamp 小于 Watermark 的数据，都已经到达了，因此，window 的执行也是由 Watermark 触发的。</li><li>Watermark 可以理解成一个延迟触发机制，我们可以设置 Watermark 的延时时长 t，每次系统会校验已经到达的数据中最大的 maxEventTime，然后认定 eventTime小于 maxEventTime - t 的所有数据都已经到达，如果有窗口的停止时间等于maxEventTime – t，那么这个窗口被触发执行。</li></ul><h3 id="七、ProcessFunction-API（底层-API）"><a href="#七、ProcessFunction-API（底层-API）" class="headerlink" title="七、ProcessFunction API（底层 API）"></a>七、ProcessFunction API（底层 API）</h3><blockquote><p>Process Function 用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window 函数和转换算子无法实现)。</p><p>Flink 提供了 8 个 Process Function：<br>•  ProcessFunction<br>•  KeyedProcessFunction<br>•  CoProcessFunction<br>•  ProcessJoinFunction<br>•  BroadcastProcessFunction<br>•  KeyedBroadcastProcessFunction<br>•  ProcessWindowFunction<br>•  ProcessAllWindowFunction</p></blockquote><h4 id="TimerService-和-定时器（Timers）案例"><a href="#TimerService-和-定时器（Timers）案例" class="headerlink" title="TimerService 和 定时器（Timers）案例"></a>TimerService 和 定时器（Timers）案例</h4><blockquote><p>监控温度传感器的温度值，如果温度值在 10 秒钟之内(processing time)连续上升，则报警</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.buildworld.flink.processfunc.bean.SensorReading;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-07 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction_App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//socket 文本流</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为SensorReading类型</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试keyedProcessFunction，先分组再定义</span></span><br><span class="line">        dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .process(<span class="keyword">new</span> TempConsIncreWarning(<span class="number">10</span>))</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义处理函数，检测一段时间内的温度连续上升，输出报警</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TempConsIncreWarning</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Tuple</span>, <span class="title">SensorReading</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义私有属性，当前统计的时间间隔</span></span><br><span class="line">        <span class="keyword">private</span> Integer interval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义状态，保存上一次的温度值，定时器时间戳</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Double&gt; lastTempState;</span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Long&gt; timerTsState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TempConsIncreWarning</span><span class="params">(Integer interval)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            lastTempState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Double&gt;(<span class="string">&quot;last-temp&quot;</span>, Double.class, Double.MIN_VALUE));</span><br><span class="line">            timerTsState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;time-ts&quot;</span>, Long.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(SensorReading sensorReading, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出状态</span></span><br><span class="line">            Double lastTemp = lastTempState.value();</span><br><span class="line">            Long timerTs = timerTsState.value();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新温度状态</span></span><br><span class="line">            lastTempState.update(sensorReading.getTemperature());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果温度上升并且没有定时器的时候，注册10秒之后的定时器，开始等待</span></span><br><span class="line">            <span class="keyword">if</span> (sensorReading.getTemperature() &gt; lastTemp &amp;&amp; timerTs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//计算出定时器的时间戳</span></span><br><span class="line">                Long ts = context.timerService().currentProcessingTime() + interval * <span class="number">1000L</span>;</span><br><span class="line">                context.timerService().registerProcessingTimeTimer(ts);</span><br><span class="line">                timerTsState.update(ts);</span><br><span class="line">                System.out.println(<span class="string">&quot;温度上升&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果温度下降，删除定时器</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sensorReading.getTemperature() &lt; lastTemp &amp;&amp; timerTs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.timerService().deleteProcessingTimeTimer(timerTs);</span><br><span class="line">                timerTsState.clear();</span><br><span class="line">                System.out.println(<span class="string">&quot;温度下降&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            out.collect(<span class="string">&quot;传感器：&quot;</span> + ctx.getCurrentKey().getField(<span class="number">0</span>) + <span class="string">&quot;温度值连续&quot;</span> + interval + <span class="string">&quot;秒上升&quot;</span> + <span class="string">&quot;,当前温度为：&quot;</span> + lastTempState.value());</span><br><span class="line">            timerTsState.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            lastTempState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="侧输出流（SideOutput）"><a href="#侧输出流（SideOutput）" class="headerlink" title="侧输出流（SideOutput）"></a>侧输出流（SideOutput）</h4><blockquote><p>案例：用来监控传感器温度值，将温度值低于 30 度的数据输出到 side output。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction_SideOutputCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//socket 文本流</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为SensorReading类型</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> OutputTag&lt;SensorReading&gt; lowTempTag = <span class="keyword">new</span> OutputTag&lt;SensorReading&gt;(<span class="string">&quot;lowTemp&quot;</span>) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试keyedProcessFunction，自定义侧输出流实现分流操作</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; highTempStream = dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .process(<span class="keyword">new</span> ProcessFunction&lt;SensorReading, SensorReading&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(SensorReading sensorReading, Context context, Collector&lt;SensorReading&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (sensorReading.getTemperature() &lt; <span class="number">30</span>) &#123;</span><br><span class="line">                            context.output(lowTempTag, sensorReading);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            collector.collect(sensorReading);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;SensorReading&gt; lowTempStream = highTempStream.getSideOutput(lowTempTag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别输出</span></span><br><span class="line">        highTempStream.print(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        lowTempStream.print(<span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、状态编程和容错机制"><a href="#八、状态编程和容错机制" class="headerlink" title="八、状态编程和容错机制"></a>八、状态编程和容错机制</h3><blockquote><p>流式计算分为<code>有状态</code>和<code>无状态</code>两种情况。无状态的计算观察每个独立事件，并根据最后一个事件输出结果（<strong>无状态流处理</strong>每次只转换一条输入记录，并且仅根据最新的输入记录输出结果）。有状态的计算则会基于多个事件输出结果（<strong>有状态流处理</strong>维护所有已处理记录的状态值，并根据每条新输入的记录更新状态，因此输出记录(灰条)反映的是综合考虑多个事件之后的结果。）。</p></blockquote><h4 id="1、Flink检查点算法–检查点分界线（Checkpoint-Barrier）"><a href="#1、Flink检查点算法–检查点分界线（Checkpoint-Barrier）" class="headerlink" title="1、Flink检查点算法–检查点分界线（Checkpoint Barrier）"></a>1、Flink检查点算法–检查点分界线（Checkpoint Barrier）</h4><blockquote><ul><li>Flink 的检查点算法用到了一种称为分界线（barrier）的特殊数据形式，用来把一条流上数据按照不同的检查点分开。</li><li>分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</li></ul></blockquote><h4 id="2、保存点（Savepoints）"><a href="#2、保存点（Savepoints）" class="headerlink" title="2、保存点（Savepoints）"></a>2、保存点（Savepoints）</h4><blockquote><ul><li>Flink 还提供了可以自定义的镜像保存功能，就是<code>保存点（savepoints）</code></li><li>原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点</li><li>Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作</li><li>保存点是一个强大的功能。除了故障恢复外，保存点可以用于：有计划的手动备份，更新应用程序，版本迁移，暂停和重启应用，等等</li></ul></blockquote><h4 id="3、容错机制配置项"><a href="#3、容错机制配置项" class="headerlink" title="3、容错机制配置项"></a>3、容错机制配置项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、检查点配置</span></span><br><span class="line">env.enableCheckpointing(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//高级选项</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000L</span>);</span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">2</span>);</span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">100L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、重启策略配置</span></span><br><span class="line"><span class="comment">// 固定延迟重启</span></span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(<span class="number">3</span>, <span class="number">10000L</span>));</span><br><span class="line"><span class="comment">//失败率重启</span></span><br><span class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(<span class="number">3</span>, Time.minutes(<span class="number">10</span>),Time.minutes(<span class="number">1</span>)));</span><br></pre></td></tr></table></figure><h4 id="4、状态一致性分类"><a href="#4、状态一致性分类" class="headerlink" title="4、状态一致性分类"></a>4、状态一致性分类</h4><blockquote><p>Flink 的一个重大价值在于， 它既保证了 <code>exactly-once</code> ，也具有<code>低延迟</code>和<code>高吞吐力</code>的处理能力。</p></blockquote><p><img src="https://file.buildworld.cn/img/20201208182144.png"></p><h4 id="5、Flink和kafka实现端到端的-exactly-once-语义"><a href="#5、Flink和kafka实现端到端的-exactly-once-语义" class="headerlink" title="5、Flink和kafka实现端到端的 exactly-once  语义"></a>5、Flink和kafka实现端到端的 exactly-once  语义</h4><p><img src="https://file.buildworld.cn/img/20201209123608.png"></p><h3 id="九、Table-API和Flink-SQL"><a href="#九、Table-API和Flink-SQL" class="headerlink" title="九、Table API和Flink SQL"></a>九、Table API和Flink SQL</h3><h4 id="1、引入pom依赖"><a href="#1、引入pom依赖" class="headerlink" title="1、引入pom依赖"></a>1、引入pom依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!--阿里巴巴贡献出来的Blink--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、简单的例子"><a href="#2、简单的例子" class="headerlink" title="2、简单的例子"></a>2、简单的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、读取数据</span></span><br><span class="line">DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;D:\\Java\\project\\Flink_Java\\src\\main\\resources\\sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、转化成pojo</span></span><br><span class="line">DataStream&lt;SensorReading&gt; dataStream = inputStream.map(</span><br><span class="line">        line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、创建表环境</span></span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、基于流创建一张表</span></span><br><span class="line">Table dataTable = tableEnv.fromDataStream(dataStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、调用table API进行转化操作</span></span><br><span class="line">Table resTable = dataTable.select(<span class="string">&quot;id,temperature&quot;</span>)</span><br><span class="line">        .where(<span class="string">&quot; id = &#x27;sensor_1&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、执行SQL</span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataTable);</span><br><span class="line">String sql = <span class="string">&quot;select id,temperature from sensor where id = &#x27;sensor_1&#x27;&quot;</span>;</span><br><span class="line">Table resultSqlTable = tableEnv.sqlQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7、打印出查询结果</span></span><br><span class="line">tableEnv.toAppendStream(resTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">tableEnv.toAppendStream(resultSqlTable, Row.class).print(<span class="string">&quot;resultSql&quot;</span>);</span><br><span class="line"></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h4 id="3、新老版本的流、批处理方法"><a href="#3、新老版本的流、批处理方法" class="headerlink" title="3、新老版本的流、批处理方法"></a>3、新老版本的流、批处理方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1 基于老版本planner的流处理</span></span><br><span class="line">EnvironmentSettings oldStreamSettings = EnvironmentSettings</span><br><span class="line">        .newInstance()</span><br><span class="line">        .useOldPlanner()</span><br><span class="line">        .inStreamingMode()</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">StreamTableEnvironment oldStreamTableEnv = StreamTableEnvironment.create(env, oldStreamSettings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 基于老版本planner的批处理</span></span><br><span class="line">ExecutionEnvironment batchEnv = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">BatchTableEnvironment oldBatchTableEnv = BatchTableEnvironment.create(batchEnv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.3 基于Blink的流处理</span></span><br><span class="line">EnvironmentSettings blinkStreamSettings = EnvironmentSettings</span><br><span class="line">        .newInstance()</span><br><span class="line">        .useBlinkPlanner()</span><br><span class="line">        .inStreamingMode()</span><br><span class="line">        .build();</span><br><span class="line">StreamTableEnvironment blinkStreamTableEnv = StreamTableEnvironment.create(env, blinkStreamSettings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.4 基于Blink的批处理</span></span><br><span class="line">EnvironmentSettings blinkBatchSettings = EnvironmentSettings</span><br><span class="line">        .newInstance()</span><br><span class="line">        .useBlinkPlanner()</span><br><span class="line">        .inBatchMode()</span><br><span class="line">        .build();</span><br><span class="line">TableEnvironment blinkBatchTableEnv = TableEnvironment.create(blinkBatchSettings);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h4 id="4、连接外部系统创建一张表"><a href="#4、连接外部系统创建一张表" class="headerlink" title="4、连接外部系统创建一张表"></a>4、连接外部系统创建一张表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、表的创建：连接外部系统，读取数据</span></span><br><span class="line"><span class="comment">// 2.1 读取文件</span></span><br><span class="line">String filePath = <span class="string">&quot;D:\\Java\\project\\Flink_Java\\src\\main\\resources\\sensor.txt&quot;</span>;</span><br><span class="line">tableEnv.connect(<span class="keyword">new</span> FileSystem().path(filePath))</span><br><span class="line">.withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">.withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">        .field(<span class="string">&quot;timestamp&quot;</span>,DataTypes.BIGINT())</span><br><span class="line">        .field(<span class="string">&quot;temp&quot;</span>,DataTypes.DOUBLE())</span><br><span class="line">).createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">Table inputTable = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line">inputTable.printSchema();</span><br><span class="line">tableEnv.toAppendStream(inputTable, Row.class).print();</span><br><span class="line"></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h4 id="5、查询转换"><a href="#5、查询转换" class="headerlink" title="5、查询转换"></a>5、查询转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="number">3</span> 查询转换</span><br><span class="line"><span class="comment">// 3.1 Table API</span></span><br><span class="line"><span class="comment">// 简单转换</span></span><br><span class="line">Table resultTable = inputTable.select(<span class="string">&quot;id,temperature&quot;</span>)</span><br><span class="line">        .filter(<span class="string">&quot;id = &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">// 聚合统计</span></span><br><span class="line">Table aggTable = inputTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        .select(<span class="string">&quot;id,id.count as count,temperature.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 SQL</span></span><br><span class="line">Table sqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id,temperature from inputTable where id = &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line">Table sqlQuery = tableEnv.sqlQuery(<span class="string">&quot;select id,count(id) as cnt,avg(temperature) as avgTemp from inputTable group by id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出</span></span><br><span class="line">tableEnv.toAppendStream(resultTable,Row.class).print(<span class="string">&quot;resultTable&quot;</span>);</span><br><span class="line">tableEnv.toRetractStream(aggTable,Row.class).print(<span class="string">&quot;aggTable&quot;</span>);</span><br><span class="line">tableEnv.toAppendStream(sqlTable,Row.class).print(<span class="string">&quot;sqlTable&quot;</span>);</span><br><span class="line">tableEnv.toRetractStream(sqlQuery,Row.class).print(<span class="string">&quot;sqlQuery&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4、输出到文件</span></span><br><span class="line"><span class="comment">// 连接外部文件注册输出表</span></span><br><span class="line">String outputFilePath = <span class="string">&quot;D:\\Java\\project\\Flink_Java\\src\\main\\resources\\output_sensor.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"> tableEnv.connect(<span class="keyword">new</span> FileSystem().path(outputFilePath))</span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line"><span class="comment">//                        .field(&quot;cnt&quot;,DataTypes.BIGINT())</span></span><br><span class="line">                        .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE()))</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">Table outputTable = tableEnv.from(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line">resultTable.insertInto(<span class="string">&quot;outputTable&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6、Table-amp-amp-Kafka"><a href="#6、Table-amp-amp-Kafka" class="headerlink" title="6、Table&amp;&amp;Kafka"></a>6、Table&amp;&amp;Kafka</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1、创建环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、连接kafka，读取数据</span></span><br><span class="line">        tableEnv.connect(<span class="keyword">new</span> Kafka()</span><br><span class="line">                .version(<span class="string">&quot;0.11&quot;</span>)</span><br><span class="line">                .topic(<span class="string">&quot;sensor&quot;</span>)</span><br><span class="line">                .property(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;10.12.42.174:2181&quot;</span>)</span><br><span class="line">                .property(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.12.42.174:9092&quot;</span>))</span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE()))</span><br><span class="line">        .createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、查询转换</span></span><br><span class="line">        <span class="comment">// 简单转换</span></span><br><span class="line">        Table sensorTable = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line">        Table resultTable = sensorTable.select(<span class="string">&quot;id,temp&quot;</span>)</span><br><span class="line">                .filter(<span class="string">&quot;id = &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line">        <span class="comment">// 聚合统计</span></span><br><span class="line">        Table aggTable = sensorTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id,id.count as count,temp.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、输出到文件</span></span><br><span class="line">        <span class="comment">// 连接外部文件注册输出表</span></span><br><span class="line"></span><br><span class="line">        tableEnv.connect(<span class="keyword">new</span> Kafka()</span><br><span class="line">                .version(<span class="string">&quot;0.11&quot;</span>)</span><br><span class="line">                .topic(<span class="string">&quot;flink&quot;</span>)</span><br><span class="line">                .property(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;10.12.42.174:2181&quot;</span>)</span><br><span class="line">                .property(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.12.42.174:9092&quot;</span>))</span><br><span class="line">                .withFormat(<span class="keyword">new</span> Csv())</span><br><span class="line">                .withSchema(<span class="keyword">new</span> Schema()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line"><span class="comment">//                        .field(&quot;timestamp&quot;, DataTypes.BIGINT())</span></span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE()))</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、写入到kafka中</span></span><br><span class="line">        resultTable.insertInto(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br></pre></td></tr></table></figure><h4 id="7、更新模式"><a href="#7、更新模式" class="headerlink" title="7、更新模式"></a>7、更新模式</h4><blockquote><ul><li>对于流式查询，需要声明如何在表和外部连接器之间执行转换</li><li>与外部系统交换的消息类型，由更新模式（Update Mode）指定</li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20201209210053.png"></p><h4 id="8、输出到MySQL"><a href="#8、输出到MySQL" class="headerlink" title="8、输出到MySQL"></a>8、输出到MySQL</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-jdbc_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4、连接MySQL</span></span><br><span class="line">String sinkDDL = <span class="string">&quot;create table jdbcOutputTable (&quot;</span> +</span><br><span class="line">        <span class="string">&quot; id varchar(20) not null, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; avgTemp double not null &quot;</span> +</span><br><span class="line">        <span class="string">&quot;) with (&quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.type&#x27; = &#x27;jdbc&#x27;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.url&#x27; = &#x27;jdbc:mysql://localhost:3306/flink&#x27;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.table&#x27; = &#x27;sensor_count&#x27;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.driver&#x27; = &#x27;com.mysql.jdbc.Driver&#x27;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.username&#x27; = &#x27;root&#x27;, &quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;connector.password&#x27; = &#x27;root&#x27; )&quot;</span>;</span><br><span class="line">tableEnv.sqlUpdate(sinkDDL);</span><br><span class="line">aggTable.insertInto(<span class="string">&quot;jdbcOutputTable&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="9、动态表和持续查询"><a href="#9、动态表和持续查询" class="headerlink" title="9、动态表和持续查询"></a>9、动态表和持续查询</h4><p><img src="https://file.buildworld.cn/img/20201211151959.png"></p><blockquote><ul><li>流被转换为动态表</li><li>对动态表计算连续查询，生成新的动态表</li><li>生成的动态表被转换回流</li></ul></blockquote><h4 id="10、Group-Windows"><a href="#10、Group-Windows" class="headerlink" title="10、Group Windows"></a>10、Group Windows</h4><blockquote><p>滚动窗口（Tumbling windows）– 滚动窗口要用 <code>Tumble</code> 类来定义</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tumbling Event-time Window</span></span><br><span class="line">.window(Tumble.over(<span class="string">&quot;10.minutes&quot;</span>).on(<span class="string">&quot;rowtime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"><span class="comment">// Tumbling Processing-time Window</span></span><br><span class="line">.window( Tumble.over(<span class="string">&quot; 10.minutes &quot;</span>).on(<span class="string">&quot; proctime &quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"><span class="comment">// Tumbling Row-count Window</span></span><br><span class="line">.window( Tumble.over(<span class="string">&quot; 10.rows &quot;</span>).on(<span class="string">&quot; proctime &quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>滑动窗口（Sliding windows）– 滑动窗口要用 <code>Slide</code> 类来定义</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sliding Event-time Window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.minutes&quot;</span>).every(<span class="string">&quot;5.minutes&quot;</span>).on(<span class="string">&quot;rowtime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"><span class="comment">// Sliding Processing-time window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.minutes&quot;</span>).every(<span class="string">&quot;5.minutes&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line"><span class="comment">// Sliding Row-count window</span></span><br><span class="line">.window(Slide.over(<span class="string">&quot;10.rows&quot;</span>).every(<span class="string">&quot;5.rows&quot;</span>).on(<span class="string">&quot;proctime&quot;</span>).as(<span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="11、自定义UDF"><a href="#11、自定义UDF" class="headerlink" title="11、自定义UDF"></a>11、自定义UDF</h4><h5 id="标量函数（Scalar-Functions）"><a href="#标量函数（Scalar-Functions）" class="headerlink" title="标量函数（Scalar Functions）"></a>标量函数（Scalar Functions）</h5><blockquote><p>• 用户定义的标量函数，可以将0、1或多个标量值，映射到新的标量值<br>• 为了定义标量函数，必须在 <code>org.apache.flink.table.functions</code> 中扩展基类<code>ScalarFunction</code>，并实现（一个或多个）求值（eval）方法<br>• 标量函数的行为由求值方法决定，求值方法必须公开声明并命名为 <code>eval</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、表的创建：连接外部系统，读取数据</span></span><br><span class="line">        <span class="comment">// 2.1 读取文件</span></span><br><span class="line">        String filePath = <span class="string">&quot;D:\\Java\\project\\Flink_Java\\src\\main\\resources\\sensor.txt&quot;</span>;</span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 转换成POJO</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;)</span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(SensorReading element)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、将流转换为表</span></span><br><span class="line">        Table sensorTable = tableEnv.fromDataStream(dataStream, <span class="string">&quot;id,timestamp as ts,temperature as temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义标量函数，实现求id的hash值</span></span><br><span class="line">        <span class="comment">// 4.1 table API</span></span><br><span class="line">        HashCode hashCode = <span class="keyword">new</span> HashCode(<span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 需要在环境中注册UDF</span></span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;hashCode&quot;</span>,hashCode);</span><br><span class="line">        Table resultTable = sensorTable.select(<span class="string">&quot;id,ts,hashCode(id)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 SQL</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>,sensorTable);</span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id,ts,hashCode(id) from sensor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;resultTable&quot;</span>);</span><br><span class="line">        tableEnv.toRetractStream(resultSqlTable, Row.class).print(<span class="string">&quot;resultSqlTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的ScalarFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCode</span> <span class="keyword">extends</span> <span class="title">ScalarFunction</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> factor = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashCode</span><span class="params">(<span class="keyword">int</span> factor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.factor = factor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.hashCode() * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="表函数（Table-Functions）"><a href="#表函数（Table-Functions）" class="headerlink" title="表函数（Table Functions）"></a>表函数（Table Functions）</h5><blockquote><p>• 用户定义的表函数，也可以将0、1或多个标量值作为输入参数；与标量函数不同的是，它可以返回任意数量的行作为输出，而不是单个值<br>• 为了定义一个表函数，必须扩展 <code>org.apache.flink.table.functions</code> 中的基类<code>TableFunction</code> 并实现（一个或多个）求值方法<br>• 表函数的行为由其求值方法决定，求值方法必须是 <code>public</code> 的，并命名为 <code>eval</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义TableFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Split</span> <span class="keyword">extends</span> <span class="title">TableFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 定义属性，分隔符</span></span><br><span class="line">        <span class="keyword">private</span> String separator = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Split</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.separator = separator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须实现一个eval方法，没有返回值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">( String str )</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>( String s: str.split(separator) )&#123;</span><br><span class="line">                collect(<span class="keyword">new</span> Tuple2&lt;&gt;(s, s.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 4. 自定义表函数，实现将id拆分，并输出（word, length）</span></span><br><span class="line">        <span class="comment">// 4.1 table API</span></span><br><span class="line">        Split split = <span class="keyword">new</span> Split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要在环境中注册UDF</span></span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;split&quot;</span>, split);</span><br><span class="line">        Table resultTable = sensorTable</span><br><span class="line">                .joinLateral(<span class="string">&quot;split(id) as (word, length)&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, ts, word, length&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 SQL</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, sensorTable);</span><br><span class="line">        Table resultSqlTable = tableEnv.sqlQuery(<span class="string">&quot;select id, ts, word, length &quot;</span> +</span><br><span class="line">                <span class="string">&quot; from sensor, lateral table(split(id)) as splitid(word, length)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="聚合函数（Aggregate-Functions）"><a href="#聚合函数（Aggregate-Functions）" class="headerlink" title="聚合函数（Aggregate Functions）"></a>聚合函数（Aggregate Functions）</h5><blockquote><p><strong>AggregateFunction 的工作原理如下：</strong></p><p>首先，它需要一个累加器（Accumulator），用来保存聚合中间结果的数据结构；可以通过调用 createAccumulator() 方法创建空累加器<br>随后，对每个输入行调用函数的 accumulate() 方法来更新累加器<br>处理完所有行后，将调用函数的 getValue() 方法来计算并返回最终结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 实现自定义的AggregateFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgTemp</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Double</span>, <span class="title">Tuple2</span>&lt;<span class="title">Double</span>, <span class="title">Integer</span>&gt;&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">getValue</span><span class="params">(Tuple2&lt;Double, Integer&gt; accumulator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> accumulator.f0 / accumulator.f1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;Double, Integer&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">0.0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须实现一个accumulate方法，来数据之后更新状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">( Tuple2&lt;Double, Integer&gt; accumulator, Double temp )</span></span>&#123;</span><br><span class="line">            accumulator.f0 += temp;</span><br><span class="line">            accumulator.f1 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">        <span class="comment">// 4. 自定义聚合函数，求当前传感器的平均温度值</span></span><br><span class="line">        <span class="comment">// 4.1 table API</span></span><br><span class="line">        AvgTemp avgTemp = <span class="keyword">new</span> AvgTemp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要在环境中注册UDF</span></span><br><span class="line">        tableEnv.registerFunction(<span class="string">&quot;avgTemp&quot;</span>, avgTemp);</span><br><span class="line">        Table resultTable = sensorTable</span><br><span class="line">                .groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .aggregate( <span class="string">&quot;avgTemp(temp) as avgtemp&quot;</span> )</span><br><span class="line">                .select(<span class="string">&quot;id, avgtemp&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="表聚合函数（Table-Aggregate-Functions）"><a href="#表聚合函数（Table-Aggregate-Functions）" class="headerlink" title="表聚合函数（Table Aggregate Functions）"></a>表聚合函数（Table Aggregate Functions）</h5><blockquote><p><strong>TableAggregateFunction 的工作原理如下:</strong><br>– 首先，它同样需要一个累加器（Accumulator），它是保存聚合中间结果的数据结构。通过调用 createAccumulator() 方法可以创建空累加器。<br>– 随后，对每个输入行调用函数的 accumulate() 方法来更新累加器。<br>– 处理完所有行后，将调用函数的 emitValue() 方法来计算并返回最终结果。</p></blockquote>]]></content>
    
    
    <summary type="html">Apache Flink® — Stateful Computations over Data Streams.</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Apache" scheme="https://www.buildworld.cn/tags/Apache/"/>
    
    <category term="Flink" scheme="https://www.buildworld.cn/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>BigData--大数据技术之Spark机器学习库MLLib</title>
    <link href="https://www.buildworld.cn/2020/09/09/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSpark%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93MLLib/"/>
    <id>https://www.buildworld.cn/2020/09/09/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSpark%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93MLLib/</id>
    <published>2020-09-09T03:58:07.000Z</published>
    <updated>2021-04-09T02:17:19.979Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>MLlib fits into Spark’s APIs and interoperates with NumPy in Python (as of Spark 0.9) and R libraries (as of Spark 1.5). You can use any Hadoop data source (e.g. HDFS, HBase, or local files), making it easy to plug into Hadoop workflows.</p></blockquote><h3 id="1、Spark-MLib介绍"><a href="#1、Spark-MLib介绍" class="headerlink" title="1、Spark MLib介绍"></a>1、Spark MLib介绍</h3><blockquote><ul><li>MLlib 是 Spark 的机器学习库，旨在简化机器学习的工程实践工作，并方便扩展到更大规模。</li><li>MLlib 由一些通用的学习算法和工具组成，包括分类、回归、聚类、协同过滤、降维等，同时还包括底层的优化原语和高层的管道 API。</li></ul></blockquote><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>数据类型</td><td>向量、带类别的向量、矩阵等</td></tr><tr><td>数学统计计算库</td><td>基本统计量、相关分析、随机数产生器、假设检验等</td></tr><tr><td>算法评测</td><td>AUC、准确率、召回率、F-Measure 等</td></tr><tr><td>机器学习算法</td><td>分类算法、回归算法、聚类算法、协同过滤等</td></tr></tbody></table><blockquote><p><strong>Spark 机器学习库从 1.2 版本以后被分为两个包：</strong></p><ul><li><code>spark.mllib </code>包含基于RDD的原始算法API。Spark MLlib 历史比较长，在1.0 以前的版本即已经包含了，提供的算法实现都是基于原始的 RDD。</li><li><a href="http://spark.apache.org/docs/latest/ml-guide.html"><code>spark.ml</code></a> 则提供了基于<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html#dataframes">DataFrames</a> 高层次的API，可以用来构建机器学习工作流（<code>PipeLine</code>）。<code>ML Pipeline</code> 弥补了原始 MLlib 库的不足，向用户提供了一个基于 DataFrame 的机器学习工作流式 API 套件。</li></ul></blockquote><pre><code>#### 目前MLlib支持的主要的机器学习算法</code></pre><p><img src="https://file.buildworld.cn/img/20200909141502.png"></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-mllib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-mllib_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>DataFrame</code>：使用Spark SQL中的DataFrame作为数据集，它可以容纳各种数据类型。 较之 RDD，包含了 schema 信息，更类似传统数据库中的二维表格。它被 ML Pipeline 用来存储源数据。例如，DataFrame中的列可以是存储的文本，特征向量，真实标签和预测的标签等。</li><li><code>Transformer</code>：翻译成转换器，是一种可以将一个DataFrame转换为另一个DataFrame的算法。比如一个模型就是一个 Transformer。它可以把 一个不包含预测标签的测试数据集 DataFrame 打上标签，转化成另一个包含预测标签的 DataFrame。技术上，Transformer实现了一个方法transform（），它通过附加一个或多个列将一个DataFrame转换为另一个DataFrame。</li><li><code>Estimator</code>：翻译成估计器或评估器，它是学习算法或在训练数据上的训练方法的概念抽象。在 Pipeline 里通常是被用来操作 DataFrame 数据并生产一个 Transformer。从技术上讲，Estimator实现了一个方法fit（），它接受一个DataFrame并产生一个转换器。如一个随机森林算法就是一个 Estimator，它可以调用fit（），通过训练特征数据而得到一个随机森林模型。</li><li><code>Paramete</code>r：Parameter 被用来设置 Transformer 或者 Estimator 的参数。现在，所有转换器和估计器可共享用于指定参数的公共API。ParamMap是一组（参数，值）对。</li><li><code>PipeLine</code>：翻译为工作流或者管道。工作流将多个工作流阶段（转换器和估计器）连接在一起，形成机器学习的工作流，并获得结果输出。</li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.spark.ml</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.&#123;<span class="type">Pipeline</span>, <span class="type">PipelineModel</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">LogisticRegression</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.&#123;<span class="type">HashingTF</span>, <span class="type">Tokenizer</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">Row</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.linalg.<span class="type">Vector</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkMLIB_DEMO</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span>.builder().master(<span class="string">&quot;local&quot;</span>).appName(<span class="string">&quot;MLib&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引入要包含的包并构建训练数据集</span></span><br><span class="line">    <span class="keyword">val</span> training = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">      (<span class="number">0</span>L, <span class="string">&quot;a b c d e spark&quot;</span>, <span class="number">1.0</span>),</span><br><span class="line">      (<span class="number">1</span>L, <span class="string">&quot;b d&quot;</span>, <span class="number">0.0</span>),</span><br><span class="line">      (<span class="number">2</span>L, <span class="string">&quot;spark f g h&quot;</span>, <span class="number">1.0</span>),</span><br><span class="line">      (<span class="number">3</span>L, <span class="string">&quot;hadoop mapreduce&quot;</span>, <span class="number">0.0</span>)</span><br><span class="line">    )).toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tokenizer: <span class="type">Tokenizer</span> = <span class="keyword">new</span> <span class="type">Tokenizer</span>()</span><br><span class="line">      .setInputCol(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">      .setOutputCol(<span class="string">&quot;words&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> hashingTF: <span class="type">HashingTF</span> = <span class="keyword">new</span> <span class="type">HashingTF</span>()</span><br><span class="line">      .setNumFeatures(<span class="number">1000</span>)</span><br><span class="line">      .setInputCol(tokenizer.getInputCol)</span><br><span class="line">      .setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lr: <span class="type">LogisticRegression</span> = <span class="keyword">new</span> <span class="type">LogisticRegression</span>()</span><br><span class="line">      .setMaxIter(<span class="number">10</span>)</span><br><span class="line">      .setRegParam(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//照具体的处理逻辑有序的组织PipelineStages 并创建一个Pipeline</span></span><br><span class="line">    <span class="keyword">val</span> pipeline: <span class="type">Pipeline</span> = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>(tokenizer, hashingTF, lr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在构建的Pipeline本质上是一个Estimator，在它的fit（）方法运行之后，它将产生一个PipelineModel，它是一个Transformer。</span></span><br><span class="line">    <span class="keyword">val</span> model: <span class="type">PipelineModel</span> = pipeline.fit(training)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建测试数据</span></span><br><span class="line">    <span class="keyword">val</span> test = spark.createDataFrame(<span class="type">Seq</span>(</span><br><span class="line">      (<span class="number">4</span>L, <span class="string">&quot;spark i j k&quot;</span>),</span><br><span class="line">      (<span class="number">5</span>L, <span class="string">&quot;l m n&quot;</span>),</span><br><span class="line">      (<span class="number">6</span>L, <span class="string">&quot;spark a&quot;</span>),</span><br><span class="line">      (<span class="number">7</span>L, <span class="string">&quot;apache hadoop&quot;</span>)</span><br><span class="line">    )).toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;text&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用我们训练好的PipelineModel的transform（）方法，让测试数据按顺序通过拟合的工作流，生成我们所需要的预测结果。</span></span><br><span class="line">    model.transform(test).select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;text&quot;</span>, <span class="string">&quot;probability&quot;</span>, <span class="string">&quot;prediction&quot;</span>).collect().foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Row</span>(id: <span class="type">Long</span>, text: <span class="type">String</span>, prob: <span class="type">Vector</span>, prediction: <span class="type">Double</span>) =&gt;</span><br><span class="line">        println(<span class="string">s&quot;(<span class="subst">$id</span>, <span class="subst">$text</span>) --&gt; prob=<span class="subst">$prob</span>, prediction=<span class="subst">$prediction</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="先挖个坑，后面有机会再来学习"><a href="#先挖个坑，后面有机会再来学习" class="headerlink" title="先挖个坑，后面有机会再来学习"></a>先挖个坑，后面有机会再来学习</h3>]]></content>
    
    
    <summary type="html">MLlib is Apache Spark&#39;s scalable machine learning library.</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Spark" scheme="https://www.buildworld.cn/tags/Spark/"/>
    
    <category term="MLlib" scheme="https://www.buildworld.cn/tags/MLlib/"/>
    
  </entry>
  
  <entry>
    <title>BigData--大数据技术之SparkStreaming</title>
    <link href="https://www.buildworld.cn/2020/09/07/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSparkStreaming/"/>
    <id>https://www.buildworld.cn/2020/09/07/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSparkStreaming/</id>
    <published>2020-09-07T02:31:19.000Z</published>
    <updated>2021-04-09T02:17:29.254Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Spark Streaming用于流式数据的处理。Spark Streaming支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ和简单的TCP套接字等等。数据输入后可以用Spark的高度抽象原语如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如HDFS，数据库等。</p></blockquote><p><img src="https://file.buildworld.cn/img/20200906163217.png"></p><h3 id="1、SparkStreaming架构"><a href="#1、SparkStreaming架构" class="headerlink" title="1、SparkStreaming架构"></a>1、SparkStreaming架构</h3><p><img src="https://file.buildworld.cn/img/20200907215002.png" alt="SparkStreaming架构"></p><h4 id="依赖（采用scala-2-12-x版本）"><a href="#依赖（采用scala-2-12-x版本）" class="headerlink" title="依赖（采用scala 2.12.x版本）"></a>依赖（采用scala 2.12.x版本）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-kafka-0-10_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、WordCount案例实操"><a href="#2、WordCount案例实操" class="headerlink" title="2、WordCount案例实操"></a>2、WordCount案例实操</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.spark.streaming</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用SparkStreaming完成WordCount</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spark配置对象</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实时数据分析环境对象</span></span><br><span class="line">    <span class="comment">//采集周期：以指定的时间为周期采集实时数据</span></span><br><span class="line">    <span class="keyword">val</span> streamingContext = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从指定的端口中采集数据</span></span><br><span class="line">    <span class="keyword">val</span> socketLineDStream = streamingContext.socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将采集的书籍进行分解，扁平化</span></span><br><span class="line">    <span class="keyword">val</span> wordDStream = socketLineDStream.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据进行结构的转换，方便统计分析</span></span><br><span class="line">    <span class="keyword">val</span> mapDStream = wordDStream.map((_, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将转换结构之后的数据进行聚合处理</span></span><br><span class="line">    <span class="keyword">val</span> wordToSumDStream = mapDStream.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结果打印出来</span></span><br><span class="line">    wordToSumDStream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动采集器</span></span><br><span class="line">    streamingContext.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Driver等待采集器的执行</span></span><br><span class="line">    streamingContext.awaitTermination()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、自定义数据源"><a href="#3、自定义数据源" class="headerlink" title="3、自定义数据源"></a>3、自定义数据源</h3><blockquote><p>除了可以从socket中读取数据，我们还可以从mysql中读取数据，具体看自己的业务需求</p></blockquote><h4 id="1）声明采集器"><a href="#1）声明采集器" class="headerlink" title="1）声明采集器"></a>1）声明采集器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明采集器</span></span><br><span class="line"><span class="comment">// 1) 继承Receiver</span></span><br><span class="line"><span class="comment">// 2) 重写onStart,onStop方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span>(<span class="params">host: <span class="type">String</span>, port: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Receiver</span>[<span class="type">String</span>](<span class="params"><span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> socket: <span class="type">Socket</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="type">Socket</span>(host, port)</span><br><span class="line">    <span class="keyword">val</span> reader = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(socket.getInputStream, <span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line: <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//将采集的数据存储到采集器的内部进行转换</span></span><br><span class="line">      <span class="keyword">this</span>.store(line)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        receive()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socket.close()</span><br><span class="line">    socket = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）使用自定义的采集器"><a href="#2）使用自定义的采集器" class="headerlink" title="2）使用自定义的采集器"></a>2）使用自定义的采集器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从指定的端口中采集数据</span></span><br><span class="line"><span class="keyword">val</span> receiverStream = streamingContext.receiverStream(<span class="keyword">new</span> <span class="type">MyReceiver</span>(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9999</span>))</span><br></pre></td></tr></table></figure><h3 id="4、Kafka数据源（版本kafka0-11-x）"><a href="#4、Kafka数据源（版本kafka0-11-x）" class="headerlink" title="4、Kafka数据源（版本kafka0.11.x）"></a>4、Kafka数据源（版本kafka0.11.x）</h3><blockquote><p>两个版本的代码不太一样：</p><p>spark官网kafka0.10版本样例：<a href="http://spark.apache.org/docs/2.3.0/streaming-kafka-0-10-integration.html">http://spark.apache.org/docs/2.3.0/streaming-kafka-0-10-integration.html</a></p><p>spark官网kafka0.8.x版本样例：<a href="http://spark.apache.org/docs/2.3.0/streaming-kafka-0-8-integration.html">http://spark.apache.org/docs/2.3.0/streaming-kafka-0-8-integration.html</a></p></blockquote><p><strong>以下代码在kafka0.11.x上面的运行的</strong></p><h4 id="模拟产生数据（通过代码自动生成消息）"><a href="#模拟产生数据（通过代码自动生成消息）" class="headerlink" title="模拟产生数据（通过代码自动生成消息）"></a>模拟产生数据（通过代码自动生成消息）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaWordProducer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// kafka服务器地址</span></span><br><span class="line">    <span class="keyword">val</span> brokers = <span class="string">&quot;hadoop102:9092&quot;</span></span><br><span class="line">    <span class="comment">// kafka topic</span></span><br><span class="line">    <span class="keyword">val</span> topic = <span class="string">&quot;michong&quot;</span></span><br><span class="line">    <span class="comment">// 每秒发送三次消息</span></span><br><span class="line">    <span class="keyword">val</span> messagesPerSec = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 每次发送五个数字</span></span><br><span class="line">    <span class="keyword">val</span> wordsPerMessage = <span class="number">5</span></span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Object</span>]()</span><br><span class="line">    props.put(<span class="type">ProducerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>, brokers)</span><br><span class="line">    props.put(<span class="type">ProducerConfig</span>.<span class="type">VALUE_SERIALIZER_CLASS_CONFIG</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">    props.put(<span class="type">ProducerConfig</span>.<span class="type">KEY_SERIALIZER_CLASS_CONFIG</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>[<span class="type">String</span>, <span class="type">String</span>](props)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">      (<span class="number">1</span> to messagesPerSec.toInt).foreach&#123;</span><br><span class="line">        messageNum =&gt; <span class="keyword">val</span> str = (<span class="number">1</span> to wordsPerMessage.toInt).map(x =&gt; <span class="type">Random</span>.nextInt(<span class="number">30</span>).toString).mkString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">          println(str)</span><br><span class="line">          <span class="keyword">val</span> message = <span class="keyword">new</span> <span class="type">ProducerRecord</span>[<span class="type">String</span>, <span class="type">String</span>](topic, <span class="literal">null</span>, str)</span><br><span class="line">          producer.send(message)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="控制台生成Topic以及消息"><a href="#控制台生成Topic以及消息" class="headerlink" title="控制台生成Topic以及消息"></a>控制台生成Topic以及消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个名字叫michong 的topic</span></span><br><span class="line">bin/kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 2 --partitions 3 --topic michong</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入kafka控制台手动输入消息</span></span><br><span class="line">bin/kafka-console-producer.sh --broker-list hadoop102:9092 --topic michong</span><br></pre></td></tr></table></figure><h4 id="Wordcount词频统计"><a href="#Wordcount词频统计" class="headerlink" title="Wordcount词频统计"></a>Wordcount词频统计</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">al sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;kafkaDirectWordCount&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">KafkaTopic</span> = <span class="type">List</span>(<span class="string">&quot;michong&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">    <span class="string">&quot;bootstrap.servers&quot;</span> -&gt; <span class="string">&quot;hadoop102:9092&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">    <span class="string">&quot;value.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">    <span class="string">&quot;group.id&quot;</span> -&gt; <span class="string">&quot;michong&quot;</span>,</span><br><span class="line">    <span class="string">&quot;auto.offset.reset&quot;</span> -&gt; <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;enable.auto.commit&quot;</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO ... 消费数据</span></span><br><span class="line">  <span class="comment">// messages 是全部的数据</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定kafka数据源</span></span><br><span class="line"><span class="comment">     * ssc：StreamingContext的实例</span></span><br><span class="line"><span class="comment">     * LocationStrategies：位置策略，如果kafka的broker节点跟Executor在同一台机器上给一种策略，不在一台机器上给另外一种策略</span></span><br><span class="line"><span class="comment">     * 设定策略后会以最优的策略进行获取数据</span></span><br><span class="line"><span class="comment">     * 一般在企业中kafka节点跟Executor不会放到一台机器的，原因是kakfa是消息存储的，Executor用来做消息的计算，</span></span><br><span class="line"><span class="comment">     * 因此计算与存储分开，存储对磁盘要求高，计算对内存、CPU要求高</span></span><br><span class="line"><span class="comment">     * 如果Executor节点跟Broker节点在一起的话使用PreferBrokers策略，如果不在一起的话使用PreferConsistent策略</span></span><br><span class="line"><span class="comment">     * 使用PreferConsistent策略的话，将来在kafka中拉取了数据以后尽量将数据分散到所有的Executor上</span></span><br><span class="line"><span class="comment">     * ConsumerStrategies：消费者策略（指定如何消费）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">val</span> messages = <span class="type">KafkaUtils</span>.createDirectStream(ssc,</span><br><span class="line">    <span class="type">LocationStrategies</span>.<span class="type">PreferConsistent</span>,</span><br><span class="line">    <span class="type">ConsumerStrategies</span>.<span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="type">KafkaTopic</span>, kafkaParams))</span><br><span class="line">  <span class="comment">// x.value获得数据里的值</span></span><br><span class="line">  messages.map(x =&gt; x.value())</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">    .reduceByKey(_ + _)</span><br><span class="line">    .print()</span><br><span class="line">  ssc.start()</span><br><span class="line">  ssc.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计结果如下"><a href="#统计结果如下" class="headerlink" title="统计结果如下"></a>统计结果如下</h4><p><img src="https://file.buildworld.cn/img/20200907202538.png"></p><h3 id="5、DStream转换"><a href="#5、DStream转换" class="headerlink" title="5、DStream转换"></a>5、DStream转换</h3><h4 id="无状态转化操作"><a href="#无状态转化操作" class="headerlink" title="无状态转化操作"></a>无状态转化操作</h4><p><strong>上面的Wordcount词频统计代码就是使用的无状态转化操作。</strong></p><blockquote><p>无状态转化操作就是把简单的RDD转化操作应用到每个批次上，也就是转化DStream中的每一个RDD。部分无状态转化操作列在了下表中。注意，针对键值对的DStream转化操作(比如 reduceByKey())要添加<code>import StreamingContext._</code>才能在Scala中使用。</p><ul><li>map(func) ：对源DStream的每个元素，采用func函数进行转换，得到一个新的DStream；</li><li>flatMap(func)： 与map相似，但是每个输入项可用被映射为0个或者多个输出项；</li><li>filter(func)： 返回一个新的DStream，仅包含源DStream中满足函数func的项；</li><li>repartition(numPartitions)： 通过创建更多或者更少的分区改变DStream的并行程度；</li><li>union(otherStream)： 返回一个新的DStream，包含源DStream和其他DStream的元素；</li><li>count()：统计源DStream中每个RDD的元素数量；</li><li>reduce(func)：利用函数func聚集源DStream中每个RDD的元素，返回一个包含单元素RDDs的新DStream；</li><li>countByValue()：应用于元素类型为K的DStream上，返回一个（K，V）键值对类型的新DStream，每个键的值是在原DStream的每个RDD中的出现次数；</li><li>reduceByKey(func, [numTasks])：当在一个由(K,V)键值对组成的DStream上执行该操作时，返回一个新的由(K,V)键值对组成的DStream，每一个key的值均由给定的recuce函数（func）聚集起来；</li><li>join(otherStream, [numTasks])：当应用于两个DStream（一个包含（K,V）键值对,一个包含(K,W)键值对），返回一个包含(K, (V, W))键值对的新DStream；</li><li>cogroup(otherStream, [numTasks])：当应用于两个DStream（一个包含（K,V）键值对,一个包含(K,W)键值对），返回一个包含(K, Seq[V], Seq[W])的元组；</li><li>transform(func)：通过对源DStream的每个RDD应用RDD-to-RDD函数，创建一个新DStream。支持在新的DStream中做任何RDD操作。</li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20200907210350.png"></p><h4 id="有状态转化操作"><a href="#有状态转化操作" class="headerlink" title="有状态转化操作"></a>有状态转化操作</h4><p><strong>将历史数据也拿过来分析</strong></p><h5 id="追踪状态变化-updateStateByKey-的转换"><a href="#追踪状态变化-updateStateByKey-的转换" class="headerlink" title="追踪状态变化(updateStateByKey)的转换"></a>追踪状态变化(updateStateByKey)的转换</h5><blockquote><p><code>UpdateStateByKey</code>原语用于记录历史记录，有时，我们需要在 DStream 中跨批次维护状态(例如流计算中累加wordcount)。针对这种情况，<code>updateStateByKey()</code> 为我们提供了对一个状态变量的访问，用于键值对形式的 DStream。给定一个由(键，事件)对构成的 DStream，并传递一个指定如何根据新的事件 更新每个键对应状态的函数，它可以构建出一个新的 DStream，其内部数据为(键，状态) 对。 </p><p><code>updateStateByKey()</code> 的结果会是一个新的 DStream，其内部的 RDD 序列是由每个时间区间对应的(键，状态)对组成的。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.<span class="type">ConsumerRecord</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.<span class="type">StringDeserializer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.dstream.&#123;<span class="type">DStream</span>, <span class="type">InputDStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka010._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">HashPartitioner</span>, <span class="type">SparkConf</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaDirectStream</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 更新方法</span></span><br><span class="line">  <span class="keyword">val</span> updateFunc = (it: <span class="type">Iterator</span>[(<span class="type">String</span>, <span class="type">Seq</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>])]) =&gt; &#123;</span><br><span class="line">    it.map &#123; <span class="keyword">case</span> (w, s, o) =&gt; (w, s.sum + o.getOrElse(<span class="number">0</span>)) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;KafkaDirectStream&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc: <span class="type">StreamingContext</span> = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    ssc.checkpoint(<span class="string">&quot;./ck&quot;</span>)</span><br><span class="line">    <span class="comment">//跟Kafka整合（直连方式，调用Kafka底层的消费数据的API）</span></span><br><span class="line">    <span class="keyword">val</span> brokerList = <span class="string">&quot;hadoop102:9092&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">      <span class="string">&quot;bootstrap.servers&quot;</span> -&gt; brokerList,</span><br><span class="line">      <span class="string">&quot;key.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">      <span class="string">&quot;value.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">      <span class="string">&quot;group.id&quot;</span> -&gt; <span class="string">&quot;michong&quot;</span>,</span><br><span class="line">      <span class="comment">//这个代表，任务启动之前产生的数据也要读</span></span><br><span class="line">      <span class="string">&quot;auto.offset.reset&quot;</span> -&gt; <span class="string">&quot;earliest&quot;</span>,</span><br><span class="line">      <span class="string">&quot;enable.auto.commit&quot;</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">&quot;michong&quot;</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定kafka数据源</span></span><br><span class="line"><span class="comment">     * ssc：StreamingContext的实例</span></span><br><span class="line"><span class="comment">     * LocationStrategies：位置策略，如果kafka的broker节点跟Executor在同一台机器上给一种策略，不在一台机器上给另外一种策略</span></span><br><span class="line"><span class="comment">     * 设定策略后会以最优的策略进行获取数据</span></span><br><span class="line"><span class="comment">     * 一般在企业中kafka节点跟Executor不会放到一台机器的，原因是kakfa是消息存储的，Executor用来做消息的计算，</span></span><br><span class="line"><span class="comment">     * 因此计算与存储分开，存储对磁盘要求高，计算对内存、CPU要求高</span></span><br><span class="line"><span class="comment">     * 如果Executor节点跟Broker节点在一起的话使用PreferBrokers策略，如果不在一起的话使用PreferConsistent策略</span></span><br><span class="line"><span class="comment">     * 使用PreferConsistent策略的话，将来在kafka中拉取了数据以后尽量将数据分散到所有的Executor上</span></span><br><span class="line"><span class="comment">     * ConsumerStrategies：消费者策略（指定如何消费）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> directStream: <span class="type">InputDStream</span>[<span class="type">ConsumerRecord</span>[<span class="type">String</span>, <span class="type">String</span>]] = <span class="type">KafkaUtils</span>.createDirectStream(ssc,</span><br><span class="line">      <span class="type">LocationStrategies</span>.<span class="type">PreferConsistent</span>,</span><br><span class="line">      <span class="type">ConsumerStrategies</span>.<span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出词频统计结果</span></span><br><span class="line">    <span class="keyword">val</span> result: <span class="type">DStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = directStream.map(_.value()).flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_, <span class="number">1</span>))</span><br><span class="line">      .updateStateByKey(updateFunc, <span class="keyword">new</span> <span class="type">HashPartitioner</span>(ssc.sparkContext.defaultParallelism), <span class="literal">true</span>)</span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    directStream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> offsetRange: <span class="type">Array</span>[<span class="type">OffsetRange</span>] = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">      <span class="keyword">val</span> maped: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = rdd.map(record =&gt; (record.key, record.value))</span><br><span class="line">      <span class="comment">//计算逻辑</span></span><br><span class="line">      maped.foreach(println)</span><br><span class="line">      <span class="comment">//循环输出</span></span><br><span class="line">      println(<span class="string">&quot;************&quot;</span>+<span class="type">System</span>.currentTimeMillis()+<span class="string">&quot;************&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> (o &lt;- offsetRange) &#123;</span><br><span class="line">        println(<span class="string">s&quot;<span class="subst">$&#123;o.topic&#125;</span> <span class="subst">$&#123;o.partition&#125;</span> <span class="subst">$&#123;o.fromOffset&#125;</span> <span class="subst">$&#123;o.untilOffset&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Window-Operations"><a href="#Window-Operations" class="headerlink" title="Window Operations"></a>Window Operations</h5><blockquote><p>Window Operations可以设置窗口的大小和滑动窗口的间隔来动态的获取当前Steaming的允许状态。基于窗口的操作会在一个比 StreamingContext 的批次间隔更长的时间范围内，通过整合多个批次的结果，计算出整个窗口的结果。</p></blockquote><p><img src="https://file.buildworld.cn/img/20200908094728.png"></p><p><strong>所有基于窗口的操作都需要两个参数，分别为窗口时长以及滑动步长，两者都必须是 StreamContext 的批次间隔的整数倍。</strong></p><h6 id="关于Window的操作有如下原语："><a href="#关于Window的操作有如下原语：" class="headerlink" title="关于Window的操作有如下原语："></a>关于Window的操作有如下原语：</h6><blockquote><ul><li>（1）<code>window(windowLength, slideInterval):</code> 基于对源DStream窗化的批次进行计算返回一个新的Dstream</li><li>（2）<code>countByWindow(windowLength, slideInterval)：</code>返回一个滑动窗口计数流中的元素。</li><li>（3）<code>reduceByWindow(func, windowLength, slideInterval)：</code>通过使用自定义函数整合滑动区间流元素来创建一个新的单元素流。</li><li>（4）<code>reduceByKeyAndWindow(func, windowLength, slideInterval, [numTasks])：</code>当在一个(K,V)对的DStream上调用此函数，会返回一个新(K,V)对的DStream，此处通过对滑动窗口中批次数据使用reduce函数来整合每个key的value值。Note:默认情况下，这个操作使用Spark的默认数量并行任务(本地是2)，在集群模式中依据配置属性(spark.default.parallelism)来做grouping。你可以通过设置可选参数numTasks来设置不同数量的tasks。</li><li>（5）<code>reduceByKeyAndWindow(func, invFunc, windowLength, slideInterval, [numTasks])：</code>这个函数是上述函数的更高效版本，每个窗口的reduce值都是通过用前一个窗的reduce值来递增计算。通过reduce进入到滑动窗口数据并”反向reduce”离开窗口的旧数据来实现这个操作。一个例子是随着窗口滑动对keys的“加”“减”计数。通过前边介绍可以想到，这个函数只适用于”可逆的reduce函数”，也就是这些reduce函数有相应的”反reduce”函数(以参数invFunc形式传入)。如前述函数，reduce任务的数量通过可选参数来配置。注意：为了使用这个操作，<a href="#checkpointing">检查点</a>必须可用。 </li><li>（6）<code>countByValueAndWindow(windowLength,slideInterval, [numTasks])：</code>对(K,V)对的DStream调用，返回(K,Long)对的新DStream，其中每个key的值是其在滑动窗口中频率。如上，可配置reduce任务数量。</li></ul><p><code>reduceByWindow()</code> 和 <code>reduceByKeyAndWindow()</code> 让我们可以对每个窗口更高效地进行归约操作。它们接收一个归约函数，在整个窗口上执行，比如 +。除此以外，它们还有一种特殊形式，通过只考虑新进入窗口的数据和离开窗口的数据，让 Spark 增量计算归约结果。这种特殊形式需要提供归约函数的一个逆函数，比 如 + 对应的逆函数为 -。对于较大的窗口，提供逆函数可以大大提高执行效率  </p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口大小应该为采集周期的整数倍，窗口滑动的步长也应该为采集周期的整数倍</span></span><br><span class="line"><span class="keyword">val</span> windowDStream: <span class="type">DStream</span>[<span class="type">ConsumerRecord</span>[<span class="type">String</span>, <span class="type">String</span>]] = directStream.window(<span class="type">Seconds</span>(<span class="number">10</span>), <span class="type">Seconds</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h3 id="6、DStream输出"><a href="#6、DStream输出" class="headerlink" title="6、DStream输出"></a>6、DStream输出</h3><blockquote><p>输出操作指定了对流数据经转化操作得到的数据所要执行的操作(例如把结果推入外部数据库或输出到屏幕上)。与RDD中的惰性求值类似，如果一个DStream及其派生出的DStream都没有被执行输出操作，那么这些DStream就都不会被求值。如果StreamingContext中没有设定输出操作，整个context就都不会启动。 </p><p><strong>输出操作如下：</strong></p><ul><li><p>（1）<code>print()：</code>在运行流程序的驱动结点上打印DStream中每一批次数据的最开始10个元素。这用于开发和调试。在Python API中，同样的操作叫print()。</p></li><li><p>（2）<code>saveAsTextFiles(prefix, [suffix])：</code>以text文件形式存储这个DStream的内容。每一批次的存储文件名基于参数中的prefix和suffix。”prefix-Time_IN_MS[.suffix]”. </p></li><li><p>（3）<code>saveAsObjectFiles(prefix, [suffix])：</code>以Java对象序列化的方式将Stream中的数据保存为 SequenceFiles . 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”. Python中目前不可用。</p></li><li><p>（4）<code>saveAsHadoopFiles(prefix, [suffix])：</code>将Stream中的数据保存为 Hadoop files. 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”。<br>Python API Python中目前不可用。</p></li><li><p>（5）<code>foreachRDD(func)：</code>这是最通用的输出操作，即将函数 func 用于产生于 stream的每一个RDD。其中 参数传入的函数func应该实现将每一个RDD中数据推送到外部系统，如将RDD存入文件或者通过网络将其写入数据库。注意：函数func在运行流应用的驱动中被执行，同时其中一般函数RDD操作从而强制其对于流RDD的运算。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">windowDStream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> offsetRange: <span class="type">Array</span>[<span class="type">OffsetRange</span>] = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">  <span class="keyword">val</span> maped: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = rdd.map(record =&gt; (record.key, record.value))</span><br><span class="line">  <span class="comment">//计算逻辑</span></span><br><span class="line">  maped.foreach(println)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环输出</span></span><br><span class="line">  println(<span class="string">&quot;************&quot;</span>+<span class="type">System</span>.currentTimeMillis()+<span class="string">&quot;************&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (o &lt;- offsetRange) &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$&#123;o.topic&#125;</span> <span class="subst">$&#123;o.partition&#125;</span> <span class="subst">$&#123;o.fromOffset&#125;</span> <span class="subst">$&#123;o.untilOffset&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>通用的输出操作foreachRDD()，它用来对DStream中的RDD运行任意计算。这和transform() 有些类似，都可以让我们访问任意RDD。在foreachRDD()中，可以重用我们在Spark中实现的所有行动操作。</p><p>比如，常见的用例之一是把数据写到诸如MySQL的外部数据库中。 注意：</p><ul><li>（1）连接不能写在driver层面；</li><li>（2）如果写在foreach则每个RDD都创建，得不偿失；</li><li>（3）增加foreachPartition，在分区创建。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">Spark Streaming用于流式数据的处理。Spark Streaming支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ和简单的TCP套接字等等。</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Spark" scheme="https://www.buildworld.cn/tags/Spark/"/>
    
    <category term="SparkStreaming" scheme="https://www.buildworld.cn/tags/SparkStreaming/"/>
    
  </entry>
  
  <entry>
    <title>BigData--大数据技术之SparkSQL</title>
    <link href="https://www.buildworld.cn/2020/09/03/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSparkSQL/"/>
    <id>https://www.buildworld.cn/2020/09/03/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8BSparkSQL/</id>
    <published>2020-09-03T07:44:59.000Z</published>
    <updated>2021-04-09T02:17:25.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://file.buildworld.cn/img/20200810132517.png"></p><h3 id="一、Spark-SQL概述"><a href="#一、Spark-SQL概述" class="headerlink" title="一、Spark SQL概述"></a>一、Spark SQL概述</h3><h4 id="1、DataFrame"><a href="#1、DataFrame" class="headerlink" title="1、DataFrame"></a>1、DataFrame</h4><blockquote><p>与RDD类似，DataFrame也是一个分布式数据容器。然而DataFrame更像传统数据库的二维表格，除了数据以外，还记录数据的结构信息，即schema。同时，与Hive类似，DataFrame也支持嵌套数据类型（struct、array和map）。从API易用性的角度上看，DataFrame API提供的是一套高层的关系操作，比函数式的RDD API要更加友好，门槛更低。</p></blockquote><h4 id="2、DataSet"><a href="#2、DataSet" class="headerlink" title="2、DataSet"></a>2、DataSet</h4><blockquote><ul><li>1）是<code>Dataframe API</code>的一个扩展，是Spark最新的数据抽象。</li><li>2）用户友好的API风格，既具有类型安全检查也具有Dataframe的查询优化特性。</li><li>3）Dataset支持编解码器，当需要访问非堆上的数据时可以避免反序列化整个对象，提高了效率。</li><li>4）样例类被用来在Dataset中定义数据的结构信息，样例类中每个属性的名称直接映射到DataSet中的字段名称。</li><li>5） Dataframe是Dataset的特列，<code>DataFrame=Dataset[Row]</code> ，所以可以通过as方法将Dataframe转换为Dataset。Row是一个类型，跟Car、Person这些的类型一样，所有的表结构信息我都用Row来表示。</li><li>6）DataSet是强类型的。比如可以有Dataset[Car]，Dataset[Person].</li><li>7）DataFrame只是知道字段，但是不知道字段的类型，所以在执行这些操作的时候是没办法在编译的时候检查是否类型失败的，比如你可以对一个String进行减法操作，在执行的时候才报错，而DataSet不仅仅知道字段，而且知道字段类型，所以有更严格的错误检查。就跟JSON对象和类对象之间的类比。</li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20200810163552.png"></p><h3 id="二、SparkSQL程序"><a href="#二、SparkSQL程序" class="headerlink" title="二、SparkSQL程序"></a>二、SparkSQL程序</h3><h4 id="1、user-json"><a href="#1、user-json" class="headerlink" title="1、user.json"></a>1、user.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1201&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;satish&quot;</span>, <span class="attr">&quot;age&quot;</span> : <span class="string">&quot;25&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1202&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;krishna&quot;</span>, <span class="attr">&quot;age&quot;</span> : <span class="string">&quot;28&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1203&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;amith&quot;</span>, <span class="attr">&quot;age&quot;</span> : <span class="string">&quot;39&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1204&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;javed&quot;</span>, <span class="attr">&quot;age&quot;</span> : <span class="string">&quot;23&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span> : <span class="string">&quot;1205&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;prudvi&quot;</span>, <span class="attr">&quot;age&quot;</span> : <span class="string">&quot;23&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置配置</span></span><br><span class="line">  <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建SparkSession</span></span><br><span class="line">  <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">    .builder()</span><br><span class="line">    .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">    .config(sparkConf)</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加载json数据</span></span><br><span class="line">  <span class="keyword">val</span> dataFrame = spark.read.json(<span class="string">&quot;data\\user.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建user视图</span></span><br><span class="line">  dataFrame.createOrReplaceTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行SQL语句，并打印结果</span></span><br><span class="line">  spark.sql(<span class="string">&quot;select * from user where age &gt; 25&quot;</span>).show()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭</span></span><br><span class="line">  spark.stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、相互转换"><a href="#3、相互转换" class="headerlink" title="3、相互转换"></a>3、相互转换</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置配置</span></span><br><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">  .builder()</span><br><span class="line">  .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">  .config(sparkConf)</span><br><span class="line">  .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行转换之前，需要引入隐式转换规则</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建RDD</span></span><br><span class="line"><span class="keyword">val</span> rdd = spark.sparkContext.makeRDD(<span class="type">List</span>((<span class="number">1</span>, <span class="string">&quot;michong&quot;</span>, <span class="number">20</span>), (<span class="number">2</span>, <span class="string">&quot;qjzxzxd&quot;</span>, <span class="number">21</span>), (<span class="number">3</span>, <span class="string">&quot;米虫&quot;</span>, <span class="number">18</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为DF</span></span><br><span class="line"><span class="keyword">val</span> df = rdd.toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>)</span><br><span class="line">df.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为DS</span></span><br><span class="line"><span class="keyword">val</span> ds = df.as[<span class="type">User</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为DF</span></span><br><span class="line"><span class="keyword">val</span> df1 = ds.toDF()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为RDD</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = df1.rdd</span><br><span class="line">rdd1.foreach(row=&gt;&#123;</span><br><span class="line">  println(row.getString(<span class="number">1</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">spark.stop</span><br></pre></td></tr></table></figure><h4 id="4、RDD和DataSet之间相互转换"><a href="#4、RDD和DataSet之间相互转换" class="headerlink" title="4、RDD和DataSet之间相互转换"></a>4、RDD和DataSet之间相互转换</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置配置</span></span><br><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">  .builder()</span><br><span class="line">  .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">  .config(sparkConf)</span><br><span class="line">  .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行转换之前，需要引入隐式转换规则</span></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建RDD</span></span><br><span class="line"><span class="keyword">val</span> rdd = spark.sparkContext.makeRDD(<span class="type">List</span>((<span class="number">1</span>, <span class="string">&quot;michong&quot;</span>, <span class="number">20</span>), (<span class="number">2</span>, <span class="string">&quot;qjzxzxd&quot;</span>, <span class="number">21</span>), (<span class="number">3</span>, <span class="string">&quot;米虫&quot;</span>, <span class="number">18</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> userRDD = rdd.map&#123;</span><br><span class="line">  <span class="keyword">case</span> (id,name,age)=&gt;&#123;</span><br><span class="line">    <span class="type">User</span>(id,name,age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RDD转换为DataSet</span></span><br><span class="line"><span class="keyword">val</span> userDS = userRDD.toDS()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Represents the content of the Dataset as an `RDD` of `T`.</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = userDS.rdd</span><br><span class="line"></span><br><span class="line">rdd1.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">spark.stop</span><br></pre></td></tr></table></figure><h4 id="5、用户自定义聚合函数"><a href="#5、用户自定义聚合函数" class="headerlink" title="5、用户自定义聚合函数"></a>5、用户自定义聚合函数</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">hello4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//设置配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line">    <span class="comment">//创建SparkSession</span></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">      .config(sparkConf)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    <span class="comment">//创建聚合函数</span></span><br><span class="line">    <span class="keyword">val</span> udaf = <span class="keyword">new</span> <span class="type">MyAgeAvgFunction</span></span><br><span class="line">    spark.udf.register(<span class="string">&quot;avgAge&quot;</span>,udaf)</span><br><span class="line">    <span class="comment">//使用聚合函数</span></span><br><span class="line">    <span class="keyword">val</span> frame = spark.read.json(<span class="string">&quot;data/user.json&quot;</span>)</span><br><span class="line">    frame.createOrReplaceTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    spark.sql(<span class="string">&quot;select avgAge(age) from user&quot;</span>).show</span><br><span class="line"></span><br><span class="line">    spark.stop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用户自定义聚合函数</span></span><br><span class="line"><span class="comment">// 1）继承UserDefinedAggregateFunction</span></span><br><span class="line"><span class="comment">// 2）实现方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAgeAvgFunction</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数输入的数据结构</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StructType</span>().add(<span class="string">&quot;age&quot;</span>, <span class="type">LongType</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算时的数据结构</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StructType</span>().add(<span class="string">&quot;sum&quot;</span>, <span class="type">LongType</span>).add(<span class="string">&quot;count&quot;</span>, <span class="type">LongType</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数返回的数据类型</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数是否稳定</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算之前的缓冲区的初始化</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    buffer(<span class="number">0</span>) = <span class="number">0</span>L</span><br><span class="line">    buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据查询结果更新缓冲区的数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    buffer(<span class="number">0</span>) = buffer.getLong(<span class="number">0</span>) + input.getLong(<span class="number">0</span>)</span><br><span class="line">    buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将多个节点的缓冲区合并</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// sum</span></span><br><span class="line">    buffer1(<span class="number">0</span>) = buffer1.getLong(<span class="number">0</span>) + buffer2.getLong(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// count</span></span><br><span class="line">    buffer1(<span class="number">1</span>) = buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">    buffer.getLong(<span class="number">0</span>).toDouble / buffer.getLong(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二（强类型）"><a href="#方式二（强类型）" class="headerlink" title="方式二（强类型）"></a>方式二（强类型）</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>, <span class="type">Dataset</span>, <span class="type">Encoder</span>, <span class="type">Encoders</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">Aggregator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">hello5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//设置配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SparkSession</span></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">      .config(sparkConf)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引入隐式转换</span></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建聚合函数</span></span><br><span class="line">    <span class="keyword">val</span> udaf = <span class="keyword">new</span> <span class="type">MyAgeAvgClassFunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将聚合函数转化为查询列</span></span><br><span class="line">    <span class="keyword">val</span> avgCol = udaf.toColumn.name(<span class="string">&quot;avgAge&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用聚合函数</span></span><br><span class="line">    <span class="keyword">val</span> frame:<span class="type">DataFrame</span> = spark.read.json(<span class="string">&quot;data/user.json&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> userDS :<span class="type">Dataset</span>[<span class="type">UserBean</span>]= frame.as[<span class="type">UserBean</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应用函数</span></span><br><span class="line">    userDS.select(avgCol).show()</span><br><span class="line">    spark.stop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">BigInt</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgBuffer</span>(<span class="params">var sum: <span class="type">BigInt</span>, var count: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明用户自定义聚合函数(强类型)</span></span><br><span class="line"><span class="comment">// 1）继承Aggregator</span></span><br><span class="line"><span class="comment">// 2）实现方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAgeAvgClassFunction</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">UserBean</span>, <span class="type">AvgBuffer</span>, <span class="type">Double</span>] </span>&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">AvgBuffer</span> = &#123;</span><br><span class="line">    <span class="type">AvgBuffer</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 聚合数据</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param b</span></span><br><span class="line"><span class="comment">   * @param a</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(b: <span class="type">AvgBuffer</span>, a: <span class="type">UserBean</span>): <span class="type">AvgBuffer</span> = &#123;</span><br><span class="line">    b.sum = b.sum + a.age</span><br><span class="line">    b.count = b.count + <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓冲区合并操作</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param b1</span></span><br><span class="line"><span class="comment">   * @param b2</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">AvgBuffer</span>, b2: <span class="type">AvgBuffer</span>): <span class="type">AvgBuffer</span> = &#123;</span><br><span class="line">    b1.sum = b1.sum + b2.sum</span><br><span class="line">    b1.count = b1.count + b2.count</span><br><span class="line">    b1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 完成计算</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param reduction</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(reduction: <span class="type">AvgBuffer</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    reduction.sum.toDouble / reduction.count</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">AvgBuffer</span>] = <span class="type">Encoders</span>.product</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Spark连接MySQL数据库"><a href="#6、Spark连接MySQL数据库" class="headerlink" title="6、Spark连接MySQL数据库"></a>6、Spark连接MySQL数据库</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置配置</span></span><br><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Spark SQL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">  .builder()</span><br><span class="line">  .appName(<span class="string">&quot;Spark SQL basic example&quot;</span>)</span><br><span class="line">  .config(sparkConf)</span><br><span class="line">  .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> jdbcDF = spark.read</span><br><span class="line">  .format(<span class="string">&quot;jdbc&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/qiniuyun?serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=UTF8&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;dbtable&quot;</span>, <span class="string">&quot;myfile&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">  .load()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建视图</span></span><br><span class="line">jdbcDF.createOrReplaceTempView(<span class="string">&quot;myfile&quot;</span>)</span><br><span class="line"><span class="comment">// 查询出数据</span></span><br><span class="line">spark.sql(<span class="string">&quot;select * from myfile&quot;</span>).show</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Spark SQL是Spark用来处理结构化数据的一个模块，它提供了2个编程抽象：DataFrame和DataSet，并且作为分布式SQL查询引擎的作用。</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Spark" scheme="https://www.buildworld.cn/tags/Spark/"/>
    
    <category term="SparkSQL" scheme="https://www.buildworld.cn/tags/SparkSQL/"/>
    
  </entry>
  
  <entry>
    <title>BigData--大数据分析引擎Spark</title>
    <link href="https://www.buildworld.cn/2020/08/03/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8ESpark/"/>
    <id>https://www.buildworld.cn/2020/08/03/BigData-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8ESpark/</id>
    <published>2020-08-03T02:23:37.000Z</published>
    <updated>2021-04-09T02:17:15.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、Spark运行"><a href="#一、Spark运行" class="headerlink" title="一、Spark运行"></a>一、Spark运行</h2><h3 id="1、Spark内置模块"><a href="#1、Spark内置模块" class="headerlink" title="1、Spark内置模块"></a>1、Spark内置模块</h3><p><img src="https://file.buildworld.cn/img/20200803102434.png"></p><blockquote><ul><li><code>Spark Core</code>：实现了Spark的基本功能，包含任务调度、内存管理、错误恢复、与存储系统交互等模块。Spark Core中还包含了对弹性分布式数据集(Resilient Distributed DataSet，简称RDD)的API定义。 </li><li><code>Spark SQL</code>：是Spark用来操作结构化数据的程序包。通过Spark SQL，我们可以使用 SQL或者Apache Hive版本的SQL方言(HQL)来查询数据。Spark SQL支持多种数据源，比如Hive表、Parquet以及JSON等。 </li><li><code>Spark Streaming</code>：是Spark提供的对实时数据进行流式计算的组件。提供了用来操作数据流的API，并且与Spark Core中的 RDD API高度对应。 </li><li><code>Spark MLlib</code>：提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。 </li><li><code>集群管理器</code>：Spark 设计为可以高效地在一个计算节点到数千个计算节点之间伸缩计 算。为了实现这样的要求，同时获得最大灵活性，Spark支持在各种集群管理器(Cluster Manager)上运行，包括Hadoop YARN、Apache Mesos，以及Spark自带的一个简易调度 器，叫作<strong>独立调度器</strong>。</li></ul></blockquote><h3 id="2、spark通用运行建议流程"><a href="#2、spark通用运行建议流程" class="headerlink" title="2、spark通用运行建议流程"></a>2、spark通用运行建议流程</h3><p><img src="https://file.buildworld.cn/img/20200726140437.png"></p><blockquote><ul><li>textFile(“input”)：读取本地文件input文件夹数据；</li><li>flatMap(_.split(“ “))：压平操作，按照空格分割符将一行数据映射成一个个单词；</li><li>map((_,1))：对每一个元素操作，将单词映射为元组；</li><li>reduceByKey(<em>+</em>)：按照key将值进行聚合，相加；</li><li>collect：将数据收集到Driver端展示。</li></ul></blockquote><h3 id="3、Spark和yarn联动"><a href="#3、Spark和yarn联动" class="headerlink" title="3、Spark和yarn联动"></a>3、Spark和yarn联动</h3><p><img src="https://file.buildworld.cn/img/20200726174442.png"></p><h2 id="二、RDD转换"><a href="#二、RDD转换" class="headerlink" title="二、RDD转换"></a>二、RDD转换</h2><h3 id="1、-Value类型"><a href="#1、-Value类型" class="headerlink" title="1、 Value类型"></a>1、 Value类型</h3><h4 id="1）map-func"><a href="#1）map-func" class="headerlink" title="1）map(func)"></a>1）map(func)</h4><blockquote><p>返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成</p></blockquote><h4 id="2）mapPartitions-func"><a href="#2）mapPartitions-func" class="headerlink" title="2）mapPartitions(func)"></a>2）mapPartitions(func)</h4><blockquote><p>类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] =&gt; Iterator[U]。假设有N个元素，有M个分区，那么map的函数的将被调用N次,而mapPartitions被调用M次,一个函数一次处理所有分区。</p></blockquote><h4 id="3）mapPartitionsWithIndex-func"><a href="#3）mapPartitionsWithIndex-func" class="headerlink" title="3）mapPartitionsWithIndex(func)"></a>3）mapPartitionsWithIndex(func)</h4><blockquote><p>类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是(Int, Interator[T]) =&gt; Iterator[U]；</p></blockquote><p><strong>map()和mapPartition()的区别</strong></p><blockquote><ul><li>map()：每次处理一条数据。</li><li>mapPartition()：每次处理一个分区的数据，这个分区的数据处理完后，原RDD中分区的数据才能释放，可能导致OOM。</li></ul></blockquote><h4 id="4）flatMap-func"><a href="#4）flatMap-func" class="headerlink" title="4）flatMap(func)"></a>4）flatMap(func)</h4><blockquote><p>类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素）</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD: <span class="type">RDD</span>[<span class="type">List</span>[<span class="type">Int</span>]] = sc.makeRDD(<span class="type">Array</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> flatMapRDD = listRDD.flatMap(datas =&gt; datas)</span><br><span class="line"></span><br><span class="line">flatMapRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="5）glom"><a href="#5）glom" class="headerlink" title="5）glom"></a>5）glom</h4><blockquote><p>将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]]</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> flatMapRDD = listRDD.glom()</span><br><span class="line"></span><br><span class="line">flatMapRDD.collect().foreach(array=&gt;&#123;</span><br><span class="line">  println(array.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6）groupBy-func"><a href="#6）groupBy-func" class="headerlink" title="6）groupBy(func)"></a>6）groupBy(func)</h4><blockquote><p>分组，按照传入函数的返回值进行分组。将相同的key对应的值放入一个迭代器。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> groupByRDD = listRDD.groupBy(i =&gt; i % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">groupByRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">(<span class="number">0</span>,<span class="type">CompactBuffer</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>))</span><br><span class="line">(<span class="number">1</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure><h4 id="7）filter-func"><a href="#7）filter-func" class="headerlink" title="7）filter(func)"></a>7）filter(func)</h4><blockquote><p>过滤。返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filterRDD = listRDD.filter(i =&gt; (i % <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">filterRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="8）sample-withReplacement-fraction-seed"><a href="#8）sample-withReplacement-fraction-seed" class="headerlink" title="8）sample(withReplacement, fraction, seed)"></a>8）sample(withReplacement, fraction, seed)</h4><blockquote><p>以指定的随机种子随机抽样出数量为fraction的数据，withReplacement表示是抽出的数据是否放回，true为有放回的抽样，false为无放回的抽样，seed用于指定随机数生成器种子。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sampleRDD = listRDD.sample(<span class="literal">false</span>, <span class="number">0.4</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sampleRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="9）distinct-numTasks"><a href="#9）distinct-numTasks" class="headerlink" title="9）distinct([numTasks]))"></a>9）distinct([numTasks]))</h4><blockquote><p>对源RDD进行去重后返回一个新的RDD。默认情况下，只有8个并行任务来操作，但是可以传入一个可选的numTasks参数改变它。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> distinctRDD = listRDD.distinct()</span><br><span class="line"></span><br><span class="line">distinctRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="10）coalesce-numPartitions"><a href="#10）coalesce-numPartitions" class="headerlink" title="10）coalesce(numPartitions)"></a>10）coalesce(numPartitions)</h4><blockquote><p>缩减分区数，用于大数据集过滤后，提高小数据集的执行效率。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;缩减分区前=&quot;</span> + listRDD.partitions.size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> coalesceRDD = listRDD.coalesce(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;缩减分区后=&quot;</span> + coalesceRDD.partitions.size)</span><br></pre></td></tr></table></figure><h4 id="11）-repartition-numPartitions"><a href="#11）-repartition-numPartitions" class="headerlink" title="11） repartition(numPartitions)"></a>11） repartition(numPartitions)</h4><blockquote><p>根据分区数，重新通过网络随机洗牌所有数据。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> repartitionRDD = listRDD.repartition(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">repartitionRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><p><strong>coalesce和repartition的区别</strong></p><ul><li><ol><li>coalesce重新分区，可以选择是否进行shuffle过程。由参数<code>shuffle: Boolean = false/true</code>决定。</li></ol></li><li><ol start="2"><li>repartition实际上是调用的coalesce，默认是进行shuffle的。源码如下：</li></ol></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartition</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line"> coalesce(numPartitions, shuffle = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12）sortBy-func-ascending-numTasks"><a href="#12）sortBy-func-ascending-numTasks" class="headerlink" title="12）sortBy(func,[ascending], [numTasks])"></a>12）sortBy(func,[ascending], [numTasks])</h4><blockquote><p>使用func先对数据进行处理，按照处理后的数据比较结果排序，默认为正序(从小到大)。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listRDD = sc.makeRDD(<span class="number">1</span> to <span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装除以2余数来排序</span></span><br><span class="line"><span class="keyword">val</span> sortByRDD = listRDD.sortBy(x=&gt;x%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sortByRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="13）pipe-command-envVars"><a href="#13）pipe-command-envVars" class="headerlink" title="13）pipe(command, [envVars])"></a>13）pipe(command, [envVars])</h4><blockquote><p>管道，针对每个分区，都执行一个shell脚本，返回输出的RDD。</p></blockquote><h3 id="2、双Value类型"><a href="#2、双Value类型" class="headerlink" title="2、双Value类型"></a>2、双Value类型</h3><h4 id="1）union-otherDataset"><a href="#1）union-otherDataset" class="headerlink" title="1）union(otherDataset)"></a>1）union(otherDataset)</h4><blockquote><p>对源RDD和参数RDD求并集后返回一个新的RDD。</p></blockquote><h4 id="2）subtract-otherDataset"><a href="#2）subtract-otherDataset" class="headerlink" title="2）subtract (otherDataset)"></a>2）subtract (otherDataset)</h4><blockquote><p>计算差的一种函数，去除两个RDD中相同的元素，不同的RDD将保留下来。</p></blockquote><h4 id="3）intersection-otherDataset"><a href="#3）intersection-otherDataset" class="headerlink" title="3）intersection(otherDataset)"></a>3）intersection(otherDataset)</h4><blockquote><p>对源RDD和参数RDD求交集后返回一个新的RDD。</p></blockquote><h4 id="4）cartesian-otherDataset"><a href="#4）cartesian-otherDataset" class="headerlink" title="4）cartesian(otherDataset)"></a>4）cartesian(otherDataset)</h4><blockquote><p>笛卡尔积<strong>（尽量避免使用）</strong></p></blockquote><h4 id="5）zip-otherDataset"><a href="#5）zip-otherDataset" class="headerlink" title="5）zip(otherDataset)"></a>5）zip(otherDataset)</h4><blockquote><p>将两个RDD组合成Key/Value形式的RDD,这里默认两个RDD的partition数量以及元素数量都相同，否则会抛出异常。</p></blockquote><h3 id="3、Key-Value类型"><a href="#3、Key-Value类型" class="headerlink" title="3、Key-Value类型"></a>3、Key-Value类型</h3><h4 id="1）partitionBy"><a href="#1）partitionBy" class="headerlink" title="1）partitionBy"></a>1）partitionBy</h4><blockquote><p>对pairRDD进行分区操作，如果原有的partionRDD和现有的partionRDD是一致的话就不进行分区， 否则会生成ShuffleRDD，即会产生shuffle过程。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> listRDD = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> partRDD = listRDD.partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  partRDD.saveAsTextFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span>(<span class="params">partitions:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span></span>&#123;</span><br><span class="line">  <span class="comment">//设置分区数目</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    partitions</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置数据存放位置</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）groupByKey"><a href="#2）groupByKey" class="headerlink" title="2）groupByKey"></a>2）groupByKey</h4><blockquote><p>groupByKey也是对每个key进行操作，但只生成一个<code>sequence</code>。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> words = <span class="type">Array</span>(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;three&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> wordPairsRDD = sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> group = wordPairsRDD.groupByKey()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将相同key对应值聚合到一个sequence中</span></span><br><span class="line">group.collect().foreach(println)</span><br><span class="line"><span class="comment">//计算相同key对应值的相加结果</span></span><br><span class="line">group.map(t=&gt;(t._1,t._2.sum)).foreach(println)</span><br></pre></td></tr></table></figure><h4 id="3）reduceByKey-func-numTasks"><a href="#3）reduceByKey-func-numTasks" class="headerlink" title="3）reduceByKey(func, [numTasks])"></a>3）reduceByKey(func, [numTasks])</h4><blockquote><p>在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，reduce任务的个数可以通过第二个可选的参数来设置。</p></blockquote><p><strong>reduceByKey和groupByKey的区别</strong></p><blockquote><ul><li><ol><li>reduceByKey：按照key进行聚合，在shuffle之前有combine（预聚合）操作，返回结果是RDD[k,v].</li></ol></li><li><ol start="2"><li>groupByKey：按照key进行分组，直接进行shuffle。</li></ol></li><li><ol start="3"><li>开发指导：reduceByKey比groupByKey快，建议使用。但是需要注意是否会影响业务逻辑。</li></ol></li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20200803194634.png"></p><h4 id="4）aggregateByKey"><a href="#4）aggregateByKey" class="headerlink" title="4）aggregateByKey"></a>4）aggregateByKey</h4><blockquote><p>参数：<code>(zeroValue:U,[partitioner: Partitioner]) (seqOp: (U, V) =&gt; U,combOp: (U, U) =&gt; U)</code></p><ul><li><ol><li>作用：在kv对的RDD中，，按key将value进行分组合并，合并时，将每个value和初始值作为seq函数的参数，进行计算，返回的结果作为一个新的kv对，然后再将结果按照key进行合并，最后将每个分组的value传递给combine函数进行计算（先将前两个value进行计算，将返回结果和下一个value传给combine函数，以此类推），将key与计算结果作为一个新的kv对输出。</li></ol></li><li><ol start="2"><li>参数描述：</li></ol></li></ul><p>（1）<code>zeroValue</code>：给每一个分区中的每一个key一个初始值；</p><p>（2）<code>seqOp</code>：函数用于在每一个分区中用初始值逐步迭代value；</p><p>（3）<code>combOp</code>：函数用于合并每个分区中的结果。</p></blockquote><p><img src="https://file.buildworld.cn/img/20200804105505.png"></p><p><strong>创建一个pairRDD，取出每个分区相同key对应值的最大值，然后相加</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">8</span>)), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">rdd.glom().collect().foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> value = rdd.aggregateByKey(<span class="number">0</span>)(math.max(_, _), _ + _)</span><br><span class="line"></span><br><span class="line">value.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="5）foldByKey"><a href="#5）foldByKey" class="headerlink" title="5）foldByKey"></a>5）foldByKey</h4><blockquote><p>参数：<code>(zeroValue: V)(func: (V, V) =&gt; V): RDD[(K, V)]</code></p></blockquote><ul><li><ol><li>作用：aggregateByKey的简化操作，seqop和combop相同</li></ol></li><li><ol start="2"><li>需求：创建一个pairRDD，计算相同key对应值的相加结果</li></ol></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> agg = rdd.foldByKey(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure><h4 id="6）combineByKey-C"><a href="#6）combineByKey-C" class="headerlink" title="6）combineByKey[C]"></a>6）combineByKey[C]</h4><blockquote><p>参数：<code>(createCombiner: V =&gt; C, mergeValue: (C, V) =&gt; C, mergeCombiners: (C, C) =&gt; C)</code> </p></blockquote><blockquote><ul><li><ol><li>作用：对相同K，把V合并成一个集合。</li></ol></li><li><ol start="2"><li>参数描述：</li></ol><p>（1）createCombiner: combineByKey() 会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过，要么就和之前的某个元素的键相同。如果这是一个新的元素,combineByKey()会使用一个叫作createCombiner()的函数来创建那个键对应的累加器的初始值</p><p>（2）mergeValue: 如果这是一个在处理当前分区之前已经遇到的键，它会使用mergeValue()方法将该键的累加器对应的当前值与这个新的值进行合并</p><p>（3）mergeCombiners: 由于每个分区都是独立处理的， 因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器， 就需要使用用户提供的 mergeCombiners() 方法将各个分区的结果进行合并。</p></li></ul></blockquote><p><img src="https://file.buildworld.cn/img/20200804152509.png"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> input = sc.parallelize(<span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">91</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">93</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">98</span>)),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> value = input.combineByKey(x =&gt; x, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y)</span><br><span class="line"></span><br><span class="line">value.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="7）sortByKey-ascending-numTasks"><a href="#7）sortByKey-ascending-numTasks" class="headerlink" title="7）sortByKey([ascending], [numTasks])"></a>7）sortByKey([ascending], [numTasks])</h4><blockquote><p>作用：在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> input = sc.parallelize(<span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">91</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">93</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">98</span>)),<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> value1 = input.sortByKey(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h4 id="8）mapValues"><a href="#8）mapValues" class="headerlink" title="8）mapValues"></a>8）mapValues</h4><blockquote><p>针对于(K,V)形式的类型只对V进行操作</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"><span class="keyword">val</span> input = sc.parallelize(<span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">91</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">93</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">98</span>)), <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> value1 = input.mapValues(_ + <span class="number">100</span>)</span><br><span class="line">value1.collect().foreach(println)</span><br></pre></td></tr></table></figure><h4 id="9）join-otherDataset-numTasks"><a href="#9）join-otherDataset-numTasks" class="headerlink" title="9）join(otherDataset, [numTasks])"></a>9）join(otherDataset, [numTasks])</h4><blockquote><p>在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD</p></blockquote><h4 id="10）cogroup-otherDataset-numTasks"><a href="#10）cogroup-otherDataset-numTasks" class="headerlink" title="10）cogroup(otherDataset, [numTasks])"></a>10）cogroup(otherDataset, [numTasks])</h4><blockquote><p>在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD</p></blockquote><h3 id="三、Action（行动算子）"><a href="#三、Action（行动算子）" class="headerlink" title="三、Action（行动算子）"></a>三、Action（行动算子）</h3><h4 id="1）reduce-func"><a href="#1）reduce-func" class="headerlink" title="1）reduce(func)"></a>1）reduce(func)</h4><blockquote><p>通过func函数聚集RDD中的所有元素，先聚合分区内数据，再聚合分区间数据。</p></blockquote><h4 id="2）collect"><a href="#2）collect" class="headerlink" title="2）collect()"></a>2）collect()</h4><blockquote><p>在驱动程序中，以数组的形式返回数据集的所有元素。</p></blockquote><h4 id="3）-count"><a href="#3）-count" class="headerlink" title="3） count()"></a>3） count()</h4><blockquote><p>返回RDD中元素的个数</p></blockquote><h4 id="4）first"><a href="#4）first" class="headerlink" title="4）first()"></a>4）first()</h4><blockquote><p>返回RDD中的第一个元素</p></blockquote><h4 id="5）take-n"><a href="#5）take-n" class="headerlink" title="5）take(n)"></a>5）take(n)</h4><blockquote><p>返回一个由RDD的前n个元素组成的数组</p></blockquote><h4 id="6）takeOrdered-n"><a href="#6）takeOrdered-n" class="headerlink" title="6）takeOrdered(n)"></a>6）takeOrdered(n)</h4><blockquote><p>返回该RDD排序后的前n个元素组成的数组</p></blockquote><h4 id="7）aggregate-num-func1-func2"><a href="#7）aggregate-num-func1-func2" class="headerlink" title="7）aggregate(num)(func1)(func2)"></a>7）aggregate(num)(func1)(func2)</h4><blockquote><ul><li><ol><li>参数：(zeroValue: U)(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)</li></ol></li><li><ol start="2"><li>作用：aggregate函数将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。这个函数最终返回的类型不需要和RDD中元素类型一致。</li></ol></li></ul></blockquote><h4 id="8）fold-num-func"><a href="#8）fold-num-func" class="headerlink" title="8）fold(num)(func)"></a>8）fold(num)(func)</h4><blockquote><p>作用：折叠操作，aggregate的简化操作，seqop和combop一样。</p></blockquote><h4 id="9）saveAsTextFile-path"><a href="#9）saveAsTextFile-path" class="headerlink" title="9）saveAsTextFile(path)"></a>9）saveAsTextFile(path)</h4><blockquote><p>将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本</p></blockquote><h4 id="10）saveAsSequenceFile-path"><a href="#10）saveAsSequenceFile-path" class="headerlink" title="10）saveAsSequenceFile(path)"></a>10）saveAsSequenceFile(path)</h4><blockquote><p>将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统。</p></blockquote><h4 id="11）saveAsObjectFile-path"><a href="#11）saveAsObjectFile-path" class="headerlink" title="11）saveAsObjectFile(path)"></a>11）saveAsObjectFile(path)</h4><blockquote><p>用于将RDD中的元素序列化成对象，存储到文件中。</p></blockquote><h4 id="12）-countByKey"><a href="#12）-countByKey" class="headerlink" title="12） countByKey()"></a>12） countByKey()</h4><blockquote><p>针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>((<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">6</span>),(<span class="number">3</span>,<span class="number">8</span>)),<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> total = rdd.countByKey()</span><br><span class="line"></span><br><span class="line">println(total)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="type">Map</span>(<span class="number">3</span> -&gt; <span class="number">2</span>, <span class="number">1</span> -&gt; <span class="number">3</span>, <span class="number">2</span> -&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="13）-foreach-func"><a href="#13）-foreach-func" class="headerlink" title="13） foreach(func)"></a>13） foreach(func)</h4><blockquote><p>在数据集的每一个元素上，运行函数func进行更新。</p></blockquote><h3 id="四、RDD依赖关系"><a href="#四、RDD依赖关系" class="headerlink" title="四、RDD依赖关系"></a>四、RDD依赖关系</h3><h4 id="1）Lineage"><a href="#1）Lineage" class="headerlink" title="1）Lineage"></a>1）Lineage</h4><blockquote><p>RDD只支持粗粒度转换，即在大量记录上执行的单个操作。将创建RDD的一系列<code>Lineage</code>（血统）记录下来，以便恢复丢失的分区。RDD的<code>Lineage</code>会记录RDD的元数据信息和转换行为，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。</p></blockquote><h4 id="2）窄依赖"><a href="#2）窄依赖" class="headerlink" title="2）窄依赖"></a>2）窄依赖</h4><blockquote><p>窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用.</p></blockquote><h4 id="3）宽依赖"><a href="#3）宽依赖" class="headerlink" title="3）宽依赖"></a>3）宽依赖</h4><blockquote><p>宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition，会引起shuffle.</p></blockquote><h4 id="4）DAG-Directed-Acyclic-Graph"><a href="#4）DAG-Directed-Acyclic-Graph" class="headerlink" title="4）DAG(Directed Acyclic Graph)"></a>4）DAG(Directed Acyclic Graph)</h4><blockquote><p>DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就就形成了DAG，根据RDD之间的依赖关系的不同将DAG划分成不同的Stage，对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此<strong>宽依赖是划分Stage的依据</strong>。</p></blockquote><p><img src="https://file.buildworld.cn/img/20200807164413.png"></p><h3 id="五、累加器"><a href="#五、累加器" class="headerlink" title="五、累加器"></a>五、累加器</h3><blockquote><p>累加器用来对信息进行聚合，通常在向 Spark传递函数时，比如使用 map() 函数或者用 filter() 传条件时，可以使用驱动器程序中定义的变量，但是集群中运行的每个任务都会得到这些变量的一份新的副本，更新这些副本的值也不会影响驱动器中的对应变量。如果我们想实现所有分片处理时更新共享变量的功能，那么累加器可以实现我们想要的效果。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建累加器对象</span></span><br><span class="line"><span class="keyword">val</span> accumulator: <span class="type">LongAccumulator</span> = sc.longAccumulator</span><br><span class="line"></span><br><span class="line">rdd.foreach &#123;</span><br><span class="line">  <span class="keyword">case</span> i =&gt; &#123;</span><br><span class="line">    <span class="comment">//执行累加器的累加功能</span></span><br><span class="line">    accumulator.add(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取累加器保存的值</span></span><br><span class="line">println(accumulator.value)</span><br></pre></td></tr></table></figure><h4 id="自定义累加器"><a href="#自定义累加器" class="headerlink" title="自定义累加器"></a>自定义累加器</h4><blockquote><p>自定义累加器类型的功能在1.X版本中就已经提供了，但是使用起来比较麻烦，在2.0版本后，累加器的易用性有了较大的改进，而且官方还提供了一个新的抽象类：<code>AccumulatorV2</code>来提供更加友好的自定义类型累加器的实现方式。实现自定义类型累加器需要继承<code>AccumulatorV2</code>并至少覆写下例中出现的方法。</p></blockquote><h3 id="六、广播变量（调优策略）"><a href="#六、广播变量（调优策略）" class="headerlink" title="六、广播变量（调优策略）"></a>六、广播变量（调优策略）</h3><blockquote><p>广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的<strong>只读</strong>值，以供一个或多个Spark操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，甚至是机器学习算法中的一个很大的特征向量，广播变量用起来都很顺手。 在多个并行操作中使用同一个变量，但是 Spark会为每个任务分别发送。</p></blockquote><blockquote><p>使用广播变量的过程如下：</p><ul><li>(1) 通过对一个类型 T 的对象调用 SparkContext.broadcast 创建出一个 Broadcast[T] 对象。 任何可序列化的类型都可以这么实现。 </li><li>(2) 通过 value 属性访问该对象的值(在 Java 中为 value() 方法)。 </li><li>(3) 变量只会被发到各个节点一次，应作为只读值处理(修改这个值不会影响到别的节点)。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">Apache Spark™ is a unified analytics engine for large-scale data processing.</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Spark" scheme="https://www.buildworld.cn/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据利器--Scala语言学习(高级)</title>
    <link href="https://www.buildworld.cn/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%A9%E5%99%A8-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%BA%A7/"/>
    <id>https://www.buildworld.cn/2020/07/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%A9%E5%99%A8-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%BA%A7/</id>
    <published>2020-07-20T07:24:08.000Z</published>
    <updated>2020-07-25T04:23:05.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Scala高级"><a href="#Scala高级" class="headerlink" title="Scala高级"></a>Scala高级</h2><h2 id="一、集合"><a href="#一、集合" class="headerlink" title="一、集合"></a>一、集合</h2><blockquote><p>Scala 的集合有三大类：<code>序列 Seq、集 Set、映射 Map</code>，所有的集合都扩展自 Iterable 特质，在 Scala 中集合有<strong>可变（mutable）</strong>和<strong>不可变（immutable）</strong>两种类型。</p></blockquote><p><img src="https://file.buildworld.cn/img/20200720092724.png"></p><blockquote><ul><li>1.Set、Map 是 Java 中也有的集合。</li><li>2.<code>Seq</code> 是 Java 没有的，我们发现 List 归属到 Seq 了,因此这里的 List 就和 java 不是同一个概念了。</li><li>3.我们前面的 for 循环有一个 1 to 3 ,就是 <code>IndexedSeq</code> 下的 <code>Vector</code>。</li><li>4.String 也是属于 <code>IndexeSeq</code>。</li><li>5.我们发现经典的数据结构比如 <code>Queue</code> 和 <code>Stack</code> 被归属到 <code>LinearSeq</code>。</li><li>6.大家注意 Scala 中的 Map 体系有一个 <code>SortedMap</code>,说明 Scala 的 Map 可以支持排序。</li><li>7.<code>IndexSeq</code> 和 <code>LinearSeq</code> 的区别[<strong>IndexSeq 是通过索引来查找和定位，因此速度快，比如 String 就是一个索引集合，通过索引即可定位</strong>] [<strong>LineaSeq 是线型的，即有头尾的概念，这种数据结构一般是通过遍历来查找，它的价值在于应用到一些。具体的应用场景 (电商网站, 大数据推荐系统 :最近浏览的 10 个商品)</strong>]</li></ul></blockquote><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><h4 id="不可变数组"><a href="#不可变数组" class="headerlink" title="不可变数组"></a>不可变数组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种创建方法</span></span><br><span class="line"><span class="keyword">val</span> num = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">5</span>)</span><br><span class="line"><span class="comment">//赋值,集合元素采用小括号访问</span></span><br><span class="line">num(<span class="number">1</span>) = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种创建方法,在定义数组时，直接赋值//使用 apply 方法创建数组对象</span></span><br><span class="line"><span class="keyword">val</span> num2 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h4><p><strong>变长数组(声明泛型)</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> num = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">1</span>, <span class="string">&quot;michong&quot;</span>, <span class="number">3.14</span>)</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">num.appendAll(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- num) &#123;</span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">num.remove(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">num(<span class="number">0</span>) = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h4 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h4><blockquote><ul><li><ol><li><code>arr1.toBuffer</code> //定长数组转可变数组</li></ol></li><li><ol start="2"><li><code>arr2.toArray</code> //可变数组转定长数组</li></ol></li></ul></blockquote><h3 id="2、元组"><a href="#2、元组" class="headerlink" title="2、元组"></a>2、元组</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建元组</span></span><br><span class="line">    <span class="keyword">val</span> tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="comment">//访问元组</span></span><br><span class="line">    <span class="comment">//1. 使用 _顺序号</span></span><br><span class="line">    println(tuple._2) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    <span class="comment">//2. 使用</span></span><br><span class="line">    println(tuple.productElement(<span class="number">2</span>)) <span class="comment">//下标是从 0 开始计算</span></span><br><span class="line">    <span class="comment">//遍历元组</span></span><br><span class="line">    <span class="keyword">for</span>(i&lt;-tuple.productIterator)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple3</span>[+<span class="type">T1</span>, +<span class="type">T2</span>, +<span class="type">T3</span>](<span class="params">_1: <span class="type">T1</span>, _2: <span class="type">T2</span>, _3: <span class="type">T3</span></span>) <span class="keyword">extends</span> <span class="title">Product3</span>[<span class="type">T1</span>, <span class="type">T2</span>, <span class="type">T3</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">&quot;(&quot;</span> + _1 + <span class="string">&quot;,&quot;</span> + _2 + <span class="string">&quot;,&quot;</span> + _3 + <span class="string">&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><blockquote><ul><li><ol><li>List 默认为不可变的集合</li></ol></li><li><ol start="2"><li>List 在 scala 包对象声明的,因此不需要引入其它包也可以使用</li></ol></li><li><ol start="3"><li>val List = scala.collection.immutable.List</li></ol></li><li><ol start="4"><li>List 中可以放任何数据类型，比如 arr1 的类型为 List[Any]</li></ol></li><li><ol start="5"><li>如果希望得到一个空列表，可以使用 Nil 对象, 在 scala 包对象声明的,因此不需要引入其它包也可以使用</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(list )</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个空list</span></span><br><span class="line"><span class="keyword">val</span> list02 = <span class="type">Nil</span></span><br><span class="line">println(list02)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在list后面添加元素</span></span><br><span class="line"><span class="keyword">val</span> list03 = list:+<span class="number">4</span></span><br><span class="line">println(list03)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在list前面添加元素</span></span><br><span class="line"><span class="keyword">val</span> list04 = <span class="string">&quot;hi&quot;</span>+:list</span><br><span class="line">println(list04)</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号::表示向集合中,新建集合添加元素。从右向左</span></span><br><span class="line"><span class="keyword">val</span> list5 = <span class="number">4</span> :: <span class="number">5</span> :: <span class="number">6</span> :: list :: <span class="type">Nil</span></span><br><span class="line">println(list5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ::: 运算符是将集合中的每一个元素加入到空集合中去, ::: 左右两边需要时集合.</span></span><br><span class="line"><span class="keyword">val</span> list6 = <span class="number">4</span> :: <span class="number">5</span> :: <span class="number">6</span> :: list ::: <span class="type">Nil</span></span><br><span class="line">println(list6)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>()</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(hi, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="列表ListBuffer"><a href="#列表ListBuffer" class="headerlink" title="列表ListBuffer"></a>列表ListBuffer</h4><p><strong>ListBuffer:ListBuffer 是可变的 list 集合，可以添加，删除元素,ListBuffer 属于序</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">ListBuffer</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    list.addOne(<span class="number">4</span>)</span><br><span class="line">    list.append(<span class="number">5</span>)</span><br><span class="line">    println(list)</span><br><span class="line"></span><br><span class="line">    list += <span class="number">6</span></span><br><span class="line">    println(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//++ 表示的是加入的是集合中的各个元素</span></span><br><span class="line">    <span class="keyword">val</span> list2 = list ++ list</span><br><span class="line">    println(list2)</span><br><span class="line"></span><br><span class="line">    list2.remove(<span class="number">0</span>)</span><br><span class="line">    println(list2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="type">ListBuffer</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="4、队列"><a href="#4、队列" class="headerlink" title="4、队列"></a>4、队列</h3><blockquote><ul><li><ol><li>队列是一个有序列表，在底层可以用数组或是链表来实现。</li></ol></li><li><ol start="2"><li>其输入和输出要遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出。</li></ol></li><li><ol start="3"><li>在 Scala 中，由设计者直接给我们提供队列类型使用。</li></ol></li><li><ol start="4"><li>在 scala 中, 有 <code>scala.collection.mutable.Queue</code> 和 <code>scala.collection.immutable.Queue</code> , 一般来说，我们在开发中通常使用可变集合中的队列</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="keyword">val</span> q1  = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//追加数据</span></span><br><span class="line">    q1+=<span class="number">1</span></span><br><span class="line">    q1+=<span class="number">2</span></span><br><span class="line">    println(q1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加list</span></span><br><span class="line">    q1++=<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    println(q1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出队列最前面的那个元素</span></span><br><span class="line">    println(q1.dequeue())</span><br><span class="line">    println(q1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队尾追加元素</span></span><br><span class="line">    q1.enqueue(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    println(q1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列的第一个元素</span></span><br><span class="line">    println(q1.head)</span><br><span class="line">    <span class="comment">//返回队列的最后一个元素</span></span><br><span class="line">    println(q1.last)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回除第一个元素以外的其他元素的队列</span></span><br><span class="line">    println(q1.tail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">Queue</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="type">Queue</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Queue</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="type">Queue</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="5、映射–Map"><a href="#5、映射–Map" class="headerlink" title="5、映射–Map"></a>5、映射–Map</h3><blockquote><ul><li><ol><li>Scala 中的 Map 和 Java 类似，也是一个散列表，它存储的内容也是键值对(key-value)映射，Scala 中<strong>不可变的 Map 是有序的</strong>，<strong>可变的 Map 是无序的</strong>。</li></ol></li><li><ol start="2"><li>Scala 中，有<code>可变 Map (scala.collection.mutable.Map)</code> 和 <code>不可变 Map(scala.collection.immutable.Map)</code>。</li></ol></li></ul></blockquote><h4 id="构建map"><a href="#构建map" class="headerlink" title="构建map"></a>构建map</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造不可变map，输入输出结果一致</span></span><br><span class="line"><span class="keyword">val</span> map1 = <span class="type">Map</span>(<span class="string">&quot;MiChong&quot;</span> -&gt; <span class="number">25</span>, <span class="string">&quot;Zz&quot;</span> -&gt; <span class="number">24</span>, <span class="string">&quot;Alice&quot;</span> -&gt; <span class="number">18</span>)</span><br><span class="line">println(map1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造可变map</span></span><br><span class="line"><span class="keyword">val</span> map2 = scala.collection.mutable.<span class="type">Map</span>(<span class="string">&quot;MiChong&quot;</span> -&gt; <span class="number">25</span>, <span class="string">&quot;Zz&quot;</span> -&gt; <span class="number">24</span>, <span class="string">&quot;Alice&quot;</span> -&gt; <span class="number">18</span>)</span><br><span class="line">println(map2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空的map</span></span><br><span class="line"><span class="keyword">val</span> map3 = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">println(map3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对偶元组,即创建包含键值对的二元组</span></span><br><span class="line"><span class="keyword">val</span> map4 = mutable.<span class="type">Map</span>((<span class="string">&quot;A&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;C&quot;</span>,<span class="number">3</span>))</span><br><span class="line">println(map4(<span class="string">&quot;A&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map1 = <span class="type">Map</span>(<span class="string">&quot;MiChong&quot;</span> -&gt; <span class="number">25</span>, <span class="string">&quot;Zz&quot;</span> -&gt; <span class="number">24</span>, <span class="string">&quot;Alice&quot;</span> -&gt; <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1</span></span><br><span class="line">    <span class="comment">//    1) 如果 key 存在，则返回对应的值</span></span><br><span class="line">    <span class="comment">//    2) 如果 key 不存在，则抛出异常[java.util.NoSuchElementException]</span></span><br><span class="line">    println(map1(<span class="string">&quot;Zz&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2、</span></span><br><span class="line">    <span class="comment">// 1.如果 key 存在，则返回 true</span></span><br><span class="line">    <span class="comment">// 2.如果 key 不存在，则返回 false</span></span><br><span class="line">    println(map1.contains(<span class="string">&quot;Zz&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式3、通过 映射.get(键) 这样的调用返回一个 Option 对象，要么是 Some，要么是 None</span></span><br><span class="line">    <span class="comment">//  2) 如果 map.get(key) key 存在返回 some,如果 key 不存在，则返回 None</span></span><br><span class="line">    <span class="comment">//  3) 如果 map.get(key).get key 存在，返回 key 对应的值,否则，抛出异常 java.util.NoSuchElementException: None.get</span></span><br><span class="line">    println(map1.get(<span class="string">&quot;Zz&quot;</span>).get)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式4、getOrElse()</span></span><br><span class="line">    <span class="comment">//如果 key 存在，返回 key 对应的值。</span></span><br><span class="line">    <span class="comment">//如果 key 不存在，返回默认值。在 java 中底层有很多类似的操作。</span></span><br><span class="line">    println(map1.getOrElse(<span class="string">&quot;zz&quot;</span>,<span class="string">&quot;default&quot;</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改和添加"><a href="#修改和添加" class="headerlink" title="修改和添加"></a>修改和添加</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo8</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">&quot;MiChong&quot;</span> -&gt; <span class="number">25</span>, <span class="string">&quot;Zz&quot;</span> -&gt; <span class="number">24</span>, <span class="string">&quot;Alice&quot;</span> -&gt; <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改和添加</span></span><br><span class="line">    <span class="comment">//1) map 是可变的，才能修改，否则报错</span></span><br><span class="line">    <span class="comment">//2) 如果 key 存在：则修改对应的值,key 不存在,等价于添加一个 key-val</span></span><br><span class="line">    map1(<span class="string">&quot;qjzxzxd&quot;</span>)= <span class="number">22</span></span><br><span class="line">    println(map1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加多个元素</span></span><br><span class="line">    map1 +=(<span class="string">&quot;qjzxzxd&quot;</span>-&gt;<span class="number">1</span>,<span class="string">&quot;demo2&quot;</span>-&gt;<span class="number">2</span>)</span><br><span class="line">    println(map1)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo8</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">&quot;MiChong&quot;</span> -&gt; <span class="number">25</span>, <span class="string">&quot;Zz&quot;</span> -&gt; <span class="number">24</span>, <span class="string">&quot;Alice&quot;</span> -&gt; <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历map</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- map1) &#123;</span><br><span class="line">      println(<span class="string">&quot;键：&quot;</span> + k + <span class="string">&quot;  值：&quot;</span> + v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k&lt;-map1.keys)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(v&lt;-map1.values)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、集–Set"><a href="#6、集–Set" class="headerlink" title="6、集–Set"></a>6、集–Set</h3><blockquote><p>默认情况下，Scala 使用的是不可变集合，如果你想使用可变集合，需要引用 <code>scala.collection.mutable.Set</code> 包</p></blockquote><h4 id="新建set"><a href="#新建set" class="headerlink" title="新建set"></a>新建set</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo9</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变</span></span><br><span class="line">    <span class="keyword">val</span> set1 = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    println(set1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变</span></span><br><span class="line">    <span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    println(set2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">HashSet</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, abc, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="添加set"><a href="#添加set" class="headerlink" title="添加set"></a>添加set</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变</span></span><br><span class="line"><span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line">set2.add(<span class="number">5</span>)</span><br><span class="line">set2 += <span class="number">6</span></span><br><span class="line">set2 +=(<span class="number">7</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">HashSet</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, abc, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变</span></span><br><span class="line"><span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line">set2.add(<span class="number">5</span>)</span><br><span class="line">set2 += <span class="number">6</span></span><br><span class="line">set2 += (<span class="number">7</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line">set2 -= <span class="number">2</span></span><br><span class="line">set2 -= (<span class="number">3</span>)</span><br><span class="line">set2.remove(<span class="number">4</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">HashSet</span>(<span class="number">1</span>, abc, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变</span></span><br><span class="line"><span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">println(set2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x &lt;- set2) &#123;</span><br><span class="line">  println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Set更多操作"><a href="#Set更多操作" class="headerlink" title="Set更多操作"></a>Set更多操作</h4><table><thead><tr><th align="center">序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">1</td><td>def +(elem: A): Set[A]</td><td>为集合添加新元素，并创建一个新的集合，除非元素已存在</td></tr><tr><td align="center">2</td><td>def -(elem: A): Set[A]</td><td>移除集合中的元素，并创建一个新的集合</td></tr><tr><td align="center">3</td><td>def contains(elem: A): Boolean</td><td>如果元素在集合中存在，返回 true，否则返回 false。</td></tr><tr><td align="center">4</td><td>def &amp;(that: Set[A]): Set[A]</td><td>返回两个集合的交集</td></tr><tr><td align="center">5</td><td>def &amp;~(that: Set[A]): Set[A]</td><td>返回两个集合的差集</td></tr><tr><td align="center">6</td><td>def ++(elems: A): Set[A]</td><td>合并两个集合</td></tr><tr><td align="center">7</td><td>def drop(n: Int): Set[A]]</td><td>返回丢弃前n个元素新集合</td></tr><tr><td align="center">8</td><td>def dropRight(n: Int): Set[A]</td><td>返回丢弃最后n个元素新集合</td></tr><tr><td align="center">9</td><td>def dropWhile(p: (A) =&gt; Boolean): Set[A]</td><td>从左向右丢弃元素，直到条件p不成立</td></tr><tr><td align="center">10</td><td>def max: A //演示下</td><td>查找最大元素</td></tr><tr><td align="center">11</td><td>def min: A //演示下</td><td>查找最小元素</td></tr><tr><td align="center">12</td><td>def take(n: Int): Set[A]</td><td>返回前 n 个元素</td></tr></tbody></table><h3 id="7、集合元素的映射-map-映射操作"><a href="#7、集合元素的映射-map-映射操作" class="headerlink" title="7、集合元素的映射-map 映射操作"></a>7、集合元素的映射-map 映射操作</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line">  <span class="comment">//map中传入一个方法，用于处理list中每个元素</span></span><br><span class="line">  <span class="keyword">val</span> list2 = list.map(f1)</span><br><span class="line">  println(list2)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> f2 = f1 _</span><br><span class="line">  println(f2(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(n:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  n*<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、flatmap-映射：flat-即压扁，压平，扁平化映射"><a href="#8、flatmap-映射：flat-即压扁，压平，扁平化映射" class="headerlink" title="8、flatmap 映射：flat 即压扁，压平，扁平化映射"></a>8、flatmap 映射：flat 即压扁，压平，扁平化映射</h3><blockquote><p>flatmap：flat 即压扁，压平，扁平化，效果就是将集合中的每个元素的子元素映射到某个函数并返回新的集合。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> names = <span class="type">List</span>(<span class="string">&quot;MiChong&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  println(names.flatMap(upper))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper</span></span>(string: <span class="type">String</span>):<span class="type">String</span>=&#123;</span><br><span class="line">  string.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、集合元素的过滤-filter"><a href="#9、集合元素的过滤-filter" class="headerlink" title="9、集合元素的过滤-filter"></a>9、集合元素的过滤-filter</h3><blockquote><p>filter：将符合要求的数据(筛选)放置到新的集合中</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只保留A开头的单词</span></span><br><span class="line">    <span class="keyword">val</span> list  = <span class="type">List</span>(<span class="string">&quot;Ace&quot;</span>,<span class="string">&quot;Baby&quot;</span>,<span class="string">&quot;Zoom&quot;</span>)</span><br><span class="line">    println(list.filter(startA))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startA</span></span>(string: <span class="type">String</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>(string.startsWith(<span class="string">&quot;A&quot;</span>)) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、reduceLeft-化简"><a href="#10、reduceLeft-化简" class="headerlink" title="10、reduceLeft 化简"></a>10、reduceLeft 化简</h3><blockquote><p>化简：将 二元函数引用于集合中的函数,。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list  = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    println(list.reduceLeft(sum))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行相加程序</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    n1 + n2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、折叠–fold"><a href="#11、折叠–fold" class="headerlink" title="11、折叠–fold"></a>11、折叠–fold</h3><blockquote><ul><li><ol><li>fold 函数将上 一步返回的值作为函数的第一个参数继续传递参与运算，直到 list  中的所有元素被遍历。</li></ol></li><li><ol start="2"><li>可以把 <code>reduceLeft</code>  看做简化版的 <code>foldLeft</code></li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    println(list.foldLeft(<span class="number">5</span>)(minus)) <span class="comment">//从左到右</span></span><br><span class="line">    println(list.foldRight(<span class="number">5</span>)(minus))<span class="comment">//从右到左</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(n1:<span class="type">Int</span>,n2:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">    n1 - n2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、扫描–scan"><a href="#12、扫描–scan" class="headerlink" title="12、扫描–scan"></a>12、扫描–scan</h3><blockquote><p>扫描，即对做 某个集合的所有元素做 fold  操作，但是会把产生的存 所有中间结果放置于一个集合中保存 // 斐波那契</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = (<span class="number">1</span> to <span class="number">5</span>).scanLeft(<span class="number">5</span>)(minus)</span><br><span class="line">    println(list)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(n1:<span class="type">Int</span>,n2:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">    n1 - n2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="type">Vector</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-5</span>, <span class="number">-10</span>)</span><br></pre></td></tr></table></figure><h2 id="二、模式匹配"><a href="#二、模式匹配" class="headerlink" title="二、模式匹配"></a>二、模式匹配</h2><blockquote><ul><li><ol><li>如果所有 case 都不匹配，那么会执行 <code>case _</code> 分支，类似于 Java 中 default 语句</li></ol></li><li><ol start="2"><li>如果所有 case 都不匹配，又没有写 case _ 分支，那么会抛出 <code>MatchError</code></li></ol></li><li><ol start="3"><li>每个 case 中，<strong>不用 break 语句</strong>，自动中断 case</li></ol></li><li><ol start="4"><li>可以在 match 中使用其它类型，而不仅仅是字符,可以是表达式</li></ol></li><li><ol start="5"><li><code>=&gt;</code> 等价于 java swtich 的 <code>:</code></li></ol></li><li><ol start="6"><li>=&gt; 后面的代码块到下一个 case， 是作为一个整体执行，可以使用{} 扩起来，也可以不扩。</li></ol></li></ul></blockquote><h3 id="1、守卫"><a href="#1、守卫" class="headerlink" title="1、守卫"></a>1、守卫</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ch &lt;- <span class="string">&quot;+-3!&quot;</span>)&#123;</span><br><span class="line">  ch <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &#x27;+&#x27; =&gt; println(ch)</span><br><span class="line">    <span class="keyword">case</span> &#x27;-&#x27; =&gt; println(ch)</span><br><span class="line">    <span class="comment">//case _ if ... 这里不是默认匹配, 表示忽略 ch ， 而是进行后面的 if 匹配.</span></span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> ch.toString.equals(&#x27;<span class="number">3</span>&#x27;) =&gt;println(ch)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、匹配数组"><a href="#2、匹配数组" class="headerlink" title="2、匹配数组"></a>2、匹配数组</h3><blockquote><ul><li><ol><li><code>Array(0)</code> 匹配只有一个元素且为 0 的数组。</li></ol></li><li><ol start="2"><li><code>Array(x,y)</code> 匹配数组有两个元素，并将两个元素赋值为 x 和 y。当然可以依次类推 Array(x,y,z) 匹配数组有 3 个元素的等等….</li></ol></li><li><ol start="3"><li><code>Array(0,_*)</code> 匹配数组以 0 开始</li></ol></li></ul></blockquote><h3 id="3、匹配列表"><a href="#3、匹配列表" class="headerlink" title="3、匹配列表"></a>3、匹配列表</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> :: <span class="type">Nil</span> =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">// 匹配的 List(0)</span></span><br><span class="line">    <span class="keyword">case</span> x :: y :: <span class="type">Nil</span> =&gt; x + <span class="string">&quot; &quot;</span> + y <span class="comment">// 匹配的是有两个元素的 List(x,y)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> :: tail =&gt; <span class="string">&quot;0 ...&quot;</span> <span class="comment">// 匹配 以 0 开头的后面有任意元素的 List</span></span><br><span class="line">    <span class="keyword">case</span> x :: <span class="type">Nil</span> =&gt; <span class="type">List</span>(x)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、匹配元组"><a href="#4、匹配元组" class="headerlink" title="4、匹配元组"></a>4、匹配元组</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请返回 (34, 89) =&gt; (89,34)</span></span><br><span class="line"><span class="keyword">for</span> (pair &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">34</span>, <span class="number">89</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">  <span class="keyword">val</span> result = pair <span class="keyword">match</span> &#123; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">&quot;0 ...&quot;</span> <span class="comment">// 表示匹配 0 开头的二元组</span></span><br><span class="line">    <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; y <span class="comment">//表示匹配 0 结尾的二元组</span></span><br><span class="line">    <span class="keyword">case</span> (x, y) =&gt; (y, x)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;other&quot;</span> <span class="comment">//.默认</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、对象匹配"><a href="#5、对象匹配" class="headerlink" title="5、对象匹配"></a>5、对象匹配</h3><blockquote><ul><li><ol><li>构建对象时 apply 会被调用 ，比如 val n1 = Square(5)</li></ol></li><li><ol start="2"><li>当将 Square(n) 写在 case 后时[case Square(n) =&gt; xxx]，会默认调用 unapply 方法(对象提取器)</li></ol></li><li><ol start="3"><li>number 会被 传递给 def unapply(z: Double) 的 z 形参</li></ol></li><li><ol start="4"><li>如果返回的是 Some 集合，则 unapply 提取器返回的结果会返回给 n 这个形参</li></ol></li><li><ol start="5"><li>case 中对象的 unapply 方法(提取器)返回 some 集合则为匹配成功</li></ol></li><li><ol start="6"><li>返回 None 集合则为匹配失败</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 模式匹配使用：</span></span><br><span class="line">    <span class="keyword">val</span> number: <span class="type">Double</span> = <span class="number">36.0</span> <span class="comment">//Square(6.0)</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 当 number 去和 case Square(n) 时，会进行如下操作</span></span><br><span class="line">    <span class="comment">//2. 把 number 传递给 Square unapply(z: Double) 的 z</span></span><br><span class="line">    <span class="comment">//3. unapply 被调用，返回一个结果, 返回的结果和程序员的逻辑代码,比如 Some(math.sqrt(z))</span></span><br><span class="line">    <span class="comment">//4. 如果返回的结果是 Some 集合，则表示匹配成功 ,如果返回的是 None 则表示匹配失败</span></span><br><span class="line">    <span class="comment">//5. 如果匹配成功，就是将 Some(?) 的 值,赋给 case Square(n) 的 n</span></span><br><span class="line">    <span class="comment">//6. 这样就等价于将原来对象的构建参数，提取出来，我们将这个过程称为对象匹配, 这个使用很多.</span></span><br><span class="line">    number <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Square</span>(n) =&gt; println(n) <span class="comment">// 6.0</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;nothing matched&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. unapply 为对象提取器</span></span><br><span class="line"><span class="comment">//2. apply 对象构建器</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Square</span> </span>&#123; <span class="comment">//静态性质</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(z: <span class="type">Double</span>): <span class="type">Option</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    println(<span class="string">&quot;unapply 被调用 z =&quot;</span> + z) <span class="comment">// 36.0</span></span><br><span class="line">    <span class="type">Some</span>(math.sqrt(z)) <span class="comment">// Some(6.0)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(z: <span class="type">Double</span>): <span class="type">Double</span> = z * z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、样例类"><a href="#6、样例类" class="headerlink" title="6、样例类"></a>6、样例类</h3><blockquote><ul><li><ol><li>样例类仍然是类。</li></ol></li><li><ol start="2"><li>样例类用 case 关键字进行声明。</li></ol></li><li><ol start="3"><li>样例类是为模式匹配(对象)而优化的类。</li></ol></li><li><ol start="4"><li>构造器中的每一个参数都成为 val——除非它被显式地声明为 var（不建议这样做）。</li></ol></li><li><ol start="5"><li>在样例类对应的伴生对象中提供 apply 方法让你不用 new 关键字就能构造出相应的对象。</li></ol></li><li><ol start="6"><li>提供 unapply 方法让模式匹配可以工作。</li></ol></li><li><ol start="7"><li>将自动生成 toString、equals、hashCode 和 copy 方法(有点类似模板类，直接给生成，供程序员使用)。</li></ol></li><li><ol start="8"><li>除上述外，样例类和其他类完全一样。你可以添加方法和字段，扩展它们。</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Dollar</span>(<span class="params">value: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Amount</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Currency 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Currency</span>(<span class="params">value: <span class="type">Double</span>, unit: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Amount</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NoAmount 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NoAmount</span> <span class="keyword">extends</span> <span class="title">Amount</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//样例类依然可以有自己的方法和属性</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cry</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;小狗汪汪叫~~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、密封类"><a href="#7、密封类" class="headerlink" title="7、密封类"></a>7、密封类</h3><blockquote><ul><li><ol><li>如果想让 case 类的所有子类都必须在申明该类的相同的源文件中定义，可以将样例类的通用超类声明为<code>sealed</code>，这个超类称之为密封类。</li></ol></li><li><ol start="2"><li>密封就是不能在其他文件中定义/使用类。</li></ol></li></ul></blockquote><h2 id="三、函数式编程"><a href="#三、函数式编程" class="headerlink" title="三、函数式编程"></a>三、函数式编程</h2><h3 id="1、偏函数"><a href="#1、偏函数" class="headerlink" title="1、偏函数"></a>1、偏函数</h3><blockquote><p>在对符合某个条件，而不是所有情况 进行逻辑操作时，使用偏函数是一个不错的选择将包在大括号内的一组 case 语句封装为函数，我们称之为偏函数，它只对会作用于指定类型的参数或指定范围值的参数实施计算，超出范围的值会忽略.</p><p>偏函数在 Scala 中是一个特质 <code>PartialFunction</code></p></blockquote><blockquote><ul><li><ol><li>使用构建特质的实现类(使用的方式是 PartialFunction 的匿名子类)</li></ol></li><li><ol start="2"><li>PartialFunction 是个特质(看源码)</li></ol></li><li><ol start="3"><li>构建偏函数时，参数形式 [Any, Int]是泛型，第一个表示传入参数类型，第二个表示返回参数</li></ol></li><li><ol start="4"><li>当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行 isDefinedAt()如果为 true ,就会执行 apply,构建一个新的 Int 对象返回</li></ol></li><li><ol start="5"><li>执行 isDefinedAt() 为 false 就过滤掉这个元素，即不构建新的 Int 对象.</li></ol></li><li><ol start="6"><li>map 函数不支持偏函数，因为 map 底层的机制就是所有循环遍历，无法过滤处理原来集合的元素</li></ol></li><li><ol start="7"><li>collect 函数支持偏函数</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> function1 = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Int</span>] &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        <span class="comment">//判断x是否是int类型</span></span><br><span class="line">        x.isInstanceOf[<span class="type">Int</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="comment">//将是int类型的元素值+1,然后返回相加之后的值</span></span><br><span class="line">        v1.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用偏函数不能使用 map, 而是 collect</span></span><br><span class="line">    <span class="keyword">val</span> list2 = list.collect(function1)</span><br><span class="line">    println(list2)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>偏函数简化</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">println(list.collect(f2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list3 = list.collect &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">println(list3)</span><br></pre></td></tr></table></figure><h3 id="2、匿名函数"><a href="#2、匿名函数" class="headerlink" title="2、匿名函数"></a>2、匿名函数</h3><blockquote><p>没有名字的函数就是匿名函数，可以通过 函数表达式，来设置匿名函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> add = (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; a + b</span><br><span class="line">println(add(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="3、高阶函数"><a href="#3、高阶函数" class="headerlink" title="3、高阶函数"></a>3、高阶函数</h3><blockquote><p>能够接受函数作为参数的函数，叫做高阶函数 <code>(higher-order function)</code>。可使应用程序更加健壮。 高阶函数可以返回一个匿名函数。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(minusxy(<span class="number">3</span>)(<span class="number">4</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minusxy</span></span>(x: <span class="type">Int</span>) = &#123;</span><br><span class="line">    (y: <span class="type">Int</span>) =&gt; x - y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h3><blockquote><p>基本介绍：闭包就是一个函数和与其相关的引用环境（变量/值）组合的一个整体(实体)。</p></blockquote><p><strong>f就是一个闭包</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> f = minusxy(<span class="number">10</span>)</span><br><span class="line">    println(f(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minusxy</span></span>(x: <span class="type">Int</span>) = &#123;</span><br><span class="line">    (y: <span class="type">Int</span>) =&gt; x - y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、函数柯里化-curry"><a href="#5、函数柯里化-curry" class="headerlink" title="5、函数柯里化(curry)"></a>5、函数柯里化(curry)</h3><blockquote><ul><li><ol><li>函数编程中，接受多个参数的函数都可以转化为接受单个参数的函数，这个转化过程就叫柯里化。</li></ol></li><li><ol start="2"><li>柯里化就是证明了函数只需要一个参数而已。其实我们刚才的学习过程中，已经涉及到了柯里化操作。</li></ol></li><li><ol start="3"><li>不用设立柯里化存在的意义这样的命题。柯里化就是以函数为主体这种思想发展的必然产生的结果。(即：柯里化是面向函数思想的必然产生结果)<br>传统方式, 函数/方法(变量)， 对象.方法(变量)<br>集合.函数(函数).函数(函数).函数(函数) //函数链</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eq</span></span>(s1: <span class="type">String</span>)(s2: <span class="type">String</span>):<span class="type">Boolean</span>=&#123;</span><br><span class="line">  s1.eq(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、控制抽象"><a href="#6、控制抽象" class="headerlink" title="6、控制抽象"></a>6、控制抽象</h3><blockquote><ul><li><ol><li>参数是函数</li></ol></li><li><ol start="2"><li>函数参数没有输入值也没有返回值</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myRunThread</span></span>(f1: =&gt;<span class="type">Unit</span>)=&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        f1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.start()</span><br><span class="line">  </span><br><span class="line">  myRunThread&#123;</span><br><span class="line">    println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">new</span> <span class="type">IntMessage</span>[<span class="type">Int</span>](<span class="number">20</span>)</span><br><span class="line">    println(value.get)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 Scala 定义泛型用[T]， s 为泛型的引用</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>[<span class="type">T</span>](<span class="params">s:<span class="type">T</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>:<span class="type">T</span> = s</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以构建 Int 类型的 Message</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">IntMessage</span>[<span class="type">Int</span>](<span class="params">msg:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Message</span>(<span class="params">msg</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//String 类型的 Message</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StringMessage</span>[<span class="type">String</span>](<span class="params">msg:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Message</span>(<span class="params">msg</span>)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、上界、下界"><a href="#1、上界、下界" class="headerlink" title="1、上界、下界"></a>1、上界、下界</h3><p><strong>scala 中上界</strong><br>在 scala 里表示某个类型是 A 类型的子类型，也称上界或上限，使用 &lt;: 关键字，语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &lt;:<span class="type">A</span>] <span class="comment">//A 是 T 的上界</span></span><br><span class="line"><span class="comment">//或用通配符:</span></span><br><span class="line">[_ &lt;:<span class="type">A</span>]</span><br></pre></td></tr></table></figure><p><strong>scala 中下界</strong><br>在 scala 的下界或下限，使用 &gt;: 关键字，语法如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &gt;: <span class="type">A</span>] <span class="comment">//A 是 T 的下界,下限</span></span><br><span class="line"><span class="comment">//或用通配符:</span></span><br><span class="line">[_ &gt;:<span class="type">A</span>]</span><br></pre></td></tr></table></figure><h3 id="2、协变、逆变和不变"><a href="#2、协变、逆变和不变" class="headerlink" title="2、协变、逆变和不变"></a>2、协变、逆变和不变</h3><blockquote><p>Scala 的协变(+)，逆变(-)，协变 covariant、逆变 contravariant、不可变 invariant</p></blockquote><ul><li><ol><li>C[+T]：如果 A 是 B 的子类，那么 C[A]是 C[B]的子类，称为协变。</li></ol></li><li><ol start="2"><li>C[-T]：如果 A 是 B 的子类，那么 C[B]是 C[A]的子类，称为逆变。</li></ol></li><li><ol start="3"><li>C[T]：无论 A 和 B 是什么关系，C[A]和 C[B]没有从属关系。称为不变。</li></ol></li></ul>]]></content>
    
    
    <summary type="html">Scala combines object-oriented and functional programming in one concise, high-level language. Scala&#39;s static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</summary>
    
    
    
    <category term="编程语言" scheme="https://www.buildworld.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Scala" scheme="https://www.buildworld.cn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>大数据利器--Scala语言学习(基础)</title>
    <link href="https://www.buildworld.cn/2020/07/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%A9%E5%99%A8-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.buildworld.cn/2020/07/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%A9%E5%99%A8-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-12T08:21:30.000Z</published>
    <updated>2020-07-20T08:16:48.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><blockquote><p>Scala combines object-oriented and functional programming in one concise, high-level language. Scala’s static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</p></blockquote><blockquote><p>给大家推荐一个在线的scala文档网站：<a href="https://static.runoob.com/download/Scala%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf">https://static.runoob.com/download/Scala%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83.pdf</a></p></blockquote><h3 id="1、Scala基本的程序结构说明"><a href="#1、Scala基本的程序结构说明" class="headerlink" title="1、Scala基本的程序结构说明"></a>1、Scala基本的程序结构说明</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 scala 的基本的程序结构说明</span></span><br><span class="line"><span class="comment">//1. object 是一个关键字，表示一个伴生对象</span></span><br><span class="line"><span class="comment">//2. 如果该文件只出现了一个 object HelloScala 就会在编译后两个.class 文件</span></span><br><span class="line"><span class="comment">//3. 第一个文件是 HelloScala.class 这个表示他的伴生类，但是空的.</span></span><br><span class="line"><span class="comment">//4. 第 2 个文件是 HelloScala$.class 对应的是 object HelloScala,但是本质是调用它对应的一个静态属性 MODULE$</span></span><br><span class="line"><span class="comment">//5. 这两个文件的关系和 main 函数的入口关系一会分析</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloScala</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. def 表示一个方法或者一个函数</span></span><br><span class="line">  <span class="comment">// 2. main 表示入口</span></span><br><span class="line">  <span class="comment">// 3. args: Array[String] 表示形参，args 是形参名 Array[String] 是形参类型表示一个 Array 数组</span></span><br><span class="line">  <span class="comment">// 4. :Unit 表示返回值类型为 Unit ，等价于 java 的 void</span></span><br><span class="line">  <span class="comment">// 5. = 表示 后面写的是函数体/方法体, 它还有返回值类型推导的作用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 表示是 输出， 类似 System.out.println(&quot;hello, scala 世界!&quot;)</span></span><br><span class="line">    <span class="comment">// 在 scala 语句后，不需要带; //体现简洁</span></span><br><span class="line">    println(<span class="string">&quot;hello, scala 世界!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Scala-的数据类型一览图"><a href="#2、Scala-的数据类型一览图" class="headerlink" title="2、Scala 的数据类型一览图"></a>2、Scala 的数据类型一览图</h3><p><img src="https://file.buildworld.cn/img/20200712154042.png"></p><ul><li><ol><li><code>Any</code> 是所有类的根类型,即所有类的父类(基类)</li></ol></li><li><ol start="2"><li>在 <code>Scala</code>中类分为两个大的类型分支(<code>AnyVal</code> [<strong>值类型，即可以理解成就是 java 的基本数据类型</strong>],<code>AnyRef</code> 类型)</li></ol></li><li><ol start="3"><li>在 <code>AnyVal</code> 虽然叫值类型，但是仍然是<strong>类(对象)</strong></li></ol></li><li><ol start="4"><li>在 <code>Scala</code>中有两个特别的类型(<code>Null</code> ), 还有一个是 <code>Nothing</code></li></ol></li><li><ol start="5"><li><code>Null</code> 类型只有一个实例 <code>null</code>, 他是 <code>bottom class</code> ,是 <code>AnyRef</code> 的子类.</li></ol></li><li><ol start="6"><li><code>Nothing</code> 类型是所有类的子类， 它的价值是在于因为它是所有类的子类，就可以将 <code>Nothing</code> 类型的对象返回给任意的变量或者方法，比如案例</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>():<span class="type">Nothing</span>= &#123; <span class="comment">//表示 f1 方法就是没有正常的返回值，专门用于返回异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;异常发生&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><ol start="7"><li>在 <code>Scala</code>中仍然遵守 低精度的数据自动的转成高精度的数据类型。</li></ol></li><li><ol start="8"><li>在 <code>Scala</code>中，<code>Unit</code> 类型比较特殊，这个类型也只有一个实例 ()  </li></ol></li></ul><h4 id="Scala数据类型列表"><a href="#Scala数据类型列表" class="headerlink" title="Scala数据类型列表"></a>Scala数据类型列表</h4><table><thead><tr><th align="center">数据类型</th><th>描述</th></tr></thead><tbody><tr><td align="center">Byte</td><td>8位有符号补码整数。数值区间为 -128 到 127</td></tr><tr><td align="center">Short</td><td>16位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td align="center">Int</td><td>32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td align="center">Long</td><td>64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr><tr><td align="center">Float</td><td>32 位 IEEE 754标准的单精度浮点数</td></tr><tr><td align="center">Double</td><td>64 位 IEEE 754标准的双精度浮点数</td></tr><tr><td align="center">Char</td><td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td align="center">String</td><td>字符序列</td></tr><tr><td align="center">Boolean</td><td>true或false</td></tr><tr><td align="center">Unit</td><td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr><tr><td align="center">Null</td><td><strong>null  可以赋值给任意引用类型(AnyRef)，但是不能赋值给值类型</strong></td></tr><tr><td align="center">Nothing</td><td>Nothing类型在Scala的类层级的最低端；它是任何其他类型的子类型。</td></tr><tr><td align="center">Any</td><td>Any是所有其他类的超类</td></tr><tr><td align="center">AnyRef</td><td>AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table><h3 id="3、函数式编程"><a href="#3、函数式编程" class="headerlink" title="3、函数式编程"></a>3、函数式编程</h3><h4 id="函数式编程基础"><a href="#函数式编程基础" class="headerlink" title="函数式编程基础"></a>函数式编程基础</h4><blockquote><ul><li><ol><li>函数定义/声明</li></ol></li><li><ol start="2"><li>函数运行机制</li></ol></li><li><ol start="3"><li>递归 [<strong>推荐编程者递归来解决问题, 算法基础, 邮差问题，最短路径，背包问题, 迷宫，回溯</strong> ]</li></ol></li><li><ol start="4"><li>过程</li></ol></li><li><ol start="5"><li>惰性函数和异常</li></ol></li></ul></blockquote><h4 id="函数式编程高级"><a href="#函数式编程高级" class="headerlink" title="函数式编程高级"></a>函数式编程高级</h4><blockquote><ul><li><ol><li>值函数(函数字面量)</li></ol></li><li><ol start="2"><li>高阶函数</li></ol></li><li><ol start="3"><li>闭包</li></ol></li><li><ol start="4"><li>应用函数</li></ol></li><li><ol start="5"><li>柯里化函数，抽象控制..</li></ol></li></ul></blockquote><p><strong>在 Scala 当中，函数是一等公民，像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量. ，函数的创建不用依赖于类或者对象，而在 Java 当中，函数的创建则要依赖于类、抽象类或者接口。</strong></p><h4 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h4><blockquote><p>当函数返回值被声明为 lazy 时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称之为惰性函数，在 Java 的某些框架代码中称之为懒加载(延迟加载）,Java中没有原生方法。</p></blockquote><ul><li><ol><li><code>lazy</code> 不能修饰 <code>var</code> 类型的变量</li></ol></li><li><ol start="2"><li>不但是在调用函数时，加了 <code>lazy</code> ,会导致函数的执行被推迟，我们在声明一个变量时，如果给声明了 <code>lazy</code> ,那么变量值得分配也会推迟。 比如 <code>lazy val i = 10</code></li></ol></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> res = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">    println(res) <span class="comment">//使用res时，才会真正的开始计算</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(args: <span class="type">Int</span>*): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (n &lt;- args) &#123;</span><br><span class="line">      res += n</span><br><span class="line">    &#125;</span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scala 中去掉所谓的 checked（编译） 异常</span></span><br><span class="line">    <span class="comment">//设计者认为，如果程序员编程时，认为某段代码可疑，就直接 try 并处理</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 如果代码可疑，使用 try 进行处理</span></span><br><span class="line">    <span class="comment">//2. 在 catch 中，可以有多个 case ，对可能的异常进行匹配</span></span><br><span class="line">    <span class="comment">//3. case ex: Exception =&gt; println(&quot;异常信息=&quot; + ex.getMessage)</span></span><br><span class="line">    <span class="comment">// (1) case 是一个关键字</span></span><br><span class="line">    <span class="comment">// (2) ex: Exception 异常的种类</span></span><br><span class="line">    <span class="comment">// (3) =&gt; 表明后的代码是对异常进行处理,如果处理的代码有多条语句可以&#123;&#125;扩起</span></span><br><span class="line">    <span class="comment">//4. 在 scala 中把范围小的异常放在后面，语法不会报错，但是不推荐</span></span><br><span class="line">    <span class="comment">//5. 如果捕获异常，代码即使出现异常，程序也不会崩溃。</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">10</span> /<span class="number">0</span></span><br><span class="line">  &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ex:<span class="type">ArithmeticException</span>=&gt;&#123;</span><br><span class="line">      println(<span class="string">&quot;异常：&quot;</span>+ex.getMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> exception: <span class="type">Exception</span>=&gt;&#123;</span><br><span class="line">      println(exception.getMessage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;完成&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Scala 提供了 <code>throws</code> 关键字来声明异常。可以使用方法定义声明异常。 它向调用者函数提供了此方法可能引发此异常的信息。 它有助于调用函数处理并将该代码包含在 try-catch 块中，以避免程序异常终止。在 scala 中，可以使用<code>@throws</code> 注释来声明异常</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@throws</span> (classOf[<span class="type">ArithmeticException</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function1</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">10</span>/<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Scala-构造器的基本语法"><a href="#4、Scala-构造器的基本语法" class="headerlink" title="4、Scala 构造器的基本语法"></a>4、Scala 构造器的基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">类名</span>(<span class="params"> 形参列表</span>) </span>&#123; <span class="comment">//  主构造器</span></span><br><span class="line"><span class="comment">//  类体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>( 形参列表) &#123; <span class="comment">//  辅助构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>( 形参列表) &#123; <span class="comment">// 辅助构造器可以有多个...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性高级"><a href="#属性高级" class="headerlink" title="属性高级"></a>属性高级</h4><blockquote><ul><li><ol><li>Scala 类的主构造器的形参<code>未用任何修饰符修饰</code>，那么这个参数是局部变量。</li></ol></li><li><ol start="2"><li>如果参数使用 <code>val</code> 关键字声明，那么 Scala 会将参数作为类的私有的只读属性使用</li></ol></li><li><ol start="3"><li>如果参数使用 <code>var</code> 关键字声明，那么那么 Scala 会将参数作为类的成员属性使用,并会提供属性对应的xxx()[类似 getter]/xxx_$eq()[类似 setter]方法，即这时的成员属性是私有的，但是可读写。</li></ol></li></ul></blockquote><h4 id="Bean-属性"><a href="#Bean-属性" class="headerlink" title="Bean 属性"></a>Bean 属性</h4><blockquote><p>JavaBeans 规范定义了 Java 的属性是像 getXxx（）和 setXxx（）的方法。许多 Java 工具（框架）都依赖这个命名习惯。为了 Java 的互操作性。将 Scala 字段加<code>@BeanProperty</code> 时，这样会自动生成规范的 setXxx/getXxx 方法。这时可以使用 对象.setXxx() 和 对象.getXxx() 来调用属性。</p></blockquote><ul><li><ol><li>给某个属性加入<code>@BeanPropetry</code> 注解后，会生成 getXXX 和 setXXX 的方法</li></ol></li><li><ol start="2"><li>并且对 原来底层自动生成类似 xxx(),xxx_$eq()</li></ol></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> color: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>()</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s&quot;Cat(<span class="subst">$name</span>, <span class="subst">$age</span>, <span class="subst">$color</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、Scala-中包的可见性和访问修饰符的使用"><a href="#5、Scala-中包的可见性和访问修饰符的使用" class="headerlink" title="5、Scala 中包的可见性和访问修饰符的使用"></a>5、Scala 中包的可见性和访问修饰符的使用</h3><blockquote><ul><li><ol><li>当属性访问权限为默认时，从底层看属性是 private 的，但是因为提供了 xxx_$eq()[类似 setter]/xxx()[类似getter] 方法，因此从使用效果看是任何地方都可以访问)。</li></ol></li><li><ol start="2"><li>当方法访问权限为默认时，默认为 public 访问权限。</li></ol></li><li><ol start="3"><li><code>private</code> 为私有权限，只在类的内部和伴生对象中可用。</li></ol></li><li><ol start="4"><li><code>protected</code> 为受保护权限，scala  中受保护权限比 Java  中更严格 ， <strong>只能子类访问，问同包无法访问</strong> (编译器从语法层面控制)。</li></ol></li><li><ol start="5"><li><strong>在 scala 中没有 public 关键字</strong>,即不能用 public 显式的修饰属性和方法。</li></ol></li></ul></blockquote><p><strong>scala 设计者将访问的方式分成三大类: (1) 处处可以访问 public (2) 子类和伴生对象能访问 protected (3) 本类和伴生对象访问 private</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="comment">//import 可以放在任何的地方，同时他的作用范围就是&#123;&#125; 块中</span></span><br><span class="line"><span class="comment">//import 如果使用到 3 次及以上，则可以放在文件前面,否则可以使用就近引入.</span></span><br><span class="line"><span class="keyword">import</span> scala.beans.<span class="type">BeanProperty</span></span><br><span class="line"><span class="meta">@BeanProperty</span> <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java 中如果想要导入包中所有的类，可以通过通配符*，Scala 中采用下 _</span></span><br><span class="line"><span class="comment">//如果不想要某个包中全部的类，而是其中的几个类，可以采用选取器,使用&#123;&#125; 括起来即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有多个同名的类或者 trait 等，可以使用 scala 重命名的机制来解决.</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123; <span class="type">HashMap</span>=&gt;<span class="type">JavaHashMap</span>, <span class="type">List</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某个冲突的类根本就不会用到，那么这个类可以直接隐藏掉</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123; <span class="type">HashMap</span>=&gt;_, _&#125; <span class="comment">// 含义为 引入 java.util 包的所有类，但是忽略 HahsMap 类</span></span><br></pre></td></tr></table></figure><h3 id="6、继承"><a href="#6、继承" class="headerlink" title="6、继承"></a>6、继承</h3><h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><p><strong>Scala 明确规定， 重写一个非抽象方法需要用 override  修饰符，调用超类的方法使用 super  关键字</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> student</span><br><span class="line">  student.name = <span class="string">&quot;michong&quot;</span></span><br><span class="line">  student.num = <span class="string">&quot;123123&quot;</span></span><br><span class="line"></span><br><span class="line">  student.getInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getInfo</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;姓名：&quot;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> num: <span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getInfo</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.getInfo()</span><br><span class="line">    println(<span class="string">&quot;学号：&quot;</span> + num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scala-中类型检查和转换"><a href="#Scala-中类型检查和转换" class="headerlink" title="Scala 中类型检查和转换"></a>Scala 中类型检查和转换</h4><p><strong>基本介绍</strong></p><blockquote><p>要测试某个对象是否属于某个给定的类，可以用 <code>isInstanceOf</code> 方法。用 <code>asInstanceOf</code> 方法将引用转换为子类的引用。<code>classOf</code> 获取对象的类名。</p></blockquote><ul><li><ol><li>classOf[String]就如同 Java 的 String.class 。</li></ol></li><li><ol start="2"><li>obj.isInstanceOf[T]就如同 Java 的 obj instanceof T 判断 obj 是不是 T 类型。</li></ol></li><li><ol start="3"><li>obj.asInstanceOf[T]就如同 Java 的(T)obj 将 obj 强转成 T 类型</li></ol></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student:person = <span class="keyword">new</span> student</span><br><span class="line">student.name = <span class="string">&quot;michong&quot;</span></span><br><span class="line">student.asInstanceOf[student].num = <span class="string">&quot;123123&quot;</span></span><br></pre></td></tr></table></figure><h4 id="var-重写抽象的-var-属性小结"><a href="#var-重写抽象的-var-属性小结" class="headerlink" title="var 重写抽象的 var 属性小结"></a>var 重写抽象的 var 属性小结</h4><blockquote><ul><li>一个属性没有初始化，那么这个属性就是抽象属性</li><li>抽象属性在编译成字节码文件时，属性并不会声明，但是会自动生成抽象方法，所以类必须声明为抽象类</li><li>如果是覆写一个父类的抽象属性，那么 <code>override</code> 关键字可省略 [原因：父类的抽象属性，生成的是抽象方法，因此就不涉及到方法重写的概念，因此 <code>override</code> 可省略]</li></ul></blockquote><h4 id="Scala-抽象类"><a href="#Scala-抽象类" class="headerlink" title="Scala 抽象类"></a>Scala 抽象类</h4><blockquote><ul><li><ol><li>抽象类不能被实例</li></ol></li><li><ol start="2"><li>抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法</li></ol></li><li><ol start="3"><li>一旦类包含了抽象方法或者抽象属性,则这个类必须声明为 abstract</li></ol></li><li><ol start="4"><li>抽象方法不能有主体，不允许使用 abstract 修饰。</li></ol></li><li><ol start="5"><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法和抽象属性，除非它自己也声明为 abstract类。【案例演示+反编译】</li></ol></li><li><ol start="6"><li>抽象方法和抽象属性不能使用 private、final 来修饰，因为这些关键字都是和重写/实现相违背的。</li></ol></li><li><ol start="7"><li>抽象类中可以有实现的方法.</li></ol></li><li><ol start="8"><li>子类重写抽象方法不需要 override，写上也不会错.</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">//抽象类，他不能实例化，我们可以通过匿名子类的方式创建一个实例</span></span><br><span class="line">  <span class="keyword">val</span> p = <span class="keyword">new</span> person &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p.info()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、伴生对象"><a href="#7、伴生对象" class="headerlink" title="7、伴生对象"></a>7、伴生对象</h3><blockquote><ul><li><ol><li>Scala 中伴生对象采用 <code>object</code> 关键字声明，伴生对象中声明的全是 “<code>静态</code>“内容，可以通过伴生对象名称直接调用。</li></ol></li><li><ol start="2"><li>伴生对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致。</li></ol></li><li><ol start="3"><li>伴生对象中的属性和方法都可以通过伴生对象名直接调用访问</li></ol></li><li><ol start="4"><li>从语法角度来讲，所谓的伴生对象其实就是类的静态方法和静态变量的集合</li></ol></li><li><ol start="5"><li>从技术角度来讲，scala 还是没有生成静态的内容，只不过是将伴生对象生成了一个新的类，实现属性和方法的调用。[反编译看源码]</li></ol></li><li><ol start="6"><li>从底层原理看，伴生对象实现静态特性是依赖于 <code>public static final MODULE$</code> 实现的。</li></ol></li><li><ol start="7"><li> 伴生对象的声明应该和伴生类的声明在同一个源码文件中(如果不在同一个文件中会运行错误!)，但是如果没有伴生类，也就没有所谓的伴生对象了，所以放在哪里就无所谓了。</li></ol></li><li><ol start="8"><li>如果 class A 独立存在，那么 A 就是一个类， 如果 object A 独立存在，那么 A 就是一个”静态”性质的对象[即类对象], 在 object A 中声明的属性和方法可以通过 A.属性 和 A.方法 来实现调用</li></ol></li></ul></blockquote><p><strong>案例</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;michong&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;qjzxzxd&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;米虫&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span>.joinGroup(p1)</span><br><span class="line">    <span class="type">Person</span>.joinGroup(p2)</span><br><span class="line">    <span class="type">Person</span>.joinGroup(p3)</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span>.showInfo()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">pname: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = pname</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">joinGroup</span></span>(person: <span class="type">Person</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      num += <span class="number">1</span></span><br><span class="line">      println(person.name + <span class="string">&quot;--加入组织&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">showInfo</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">       println(<span class="string">&quot;当前&quot;</span>+num+<span class="string">&quot;人&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;Say Hi&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、特质-trait"><a href="#8、特质-trait" class="headerlink" title="8、特质(trait)"></a>8、特质(trait)</h3><h4 id="trait的声明"><a href="#trait的声明" class="headerlink" title="trait的声明"></a><strong>trait的声明</strong></h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">名</span> <span class="title">特质名</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">体</span> <span class="title">体</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) <span class="class"><span class="keyword">trait</span> <span class="title">命名</span> <span class="title">一般首字母大写</span>.</span></span><br><span class="line"><span class="number">2</span>) 在 scala 中，java 中的接口可以当做特质使用</span><br></pre></td></tr></table></figure><p><strong>trait使用</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#没有父类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">质</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">质</span> <span class="title">特质</span> 2 <span class="keyword">with</span> <span class="title">质</span> <span class="title">特质</span> 3 ..</span></span><br><span class="line">#有父类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">父类</span> <span class="keyword">with</span> <span class="title">质</span> <span class="title">特质</span> 1 <span class="keyword">with</span> <span class="title">质</span> <span class="title">特质</span> 2 <span class="keyword">with</span>  </span></span><br></pre></td></tr></table></figure><h4 id="带有特质的对象，动态混入"><a href="#带有特质的对象，动态混入" class="headerlink" title="带有特质的对象，动态混入"></a><strong>带有特质的对象，动态混入</strong></h4><blockquote><ul><li><ol><li>除了可以在类声明时继承特质以外，还可以在构建对象时混入特质，扩展目标类的功能【反编译看动态混入本质】</li></ol></li><li><ol start="2"><li>此种方式也可以应用于对抽象类功能进行扩展</li></ol></li><li><ol start="3"><li>动态混入是 Scala 特有的方式（java 没有动态混入），可在不修改类声明/定义的情况下，扩展类的功能，非常的灵活，耦合性低 。</li></ol></li><li><ol start="4"><li>动态混入可以在不影响原有的继承关系的基础上，给指定的类扩展功能。[如何理解]</li></ol></li><li><ol start="5"><li>抽象类中有 抽象的方法，如何动态混入特质-&gt;可以，在创建实例时，实现抽象方法即可</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">C</span></span><br><span class="line">    c.getConnect(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有特质的对象，动态混入</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="keyword">new</span> <span class="type">B</span> <span class="keyword">with</span> <span class="type">Trait1</span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getConnect</span></span>(user: <span class="type">String</span>, pwd: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;用户登录信息：user: &quot;</span>+user+<span class="string">&quot; pwd: &quot;</span>+pwd)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.getConnect(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">Trait1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getConnect</span></span>(user:<span class="type">String</span>,pwd:<span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">with</span> <span class="title">Trait1</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getConnect</span></span>(user: <span class="type">String</span>, pwd: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;用户登录信息：user: &quot;</span>+user+<span class="string">&quot; pwd: &quot;</span>+pwd)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">with</span> <span class="title">Trait1</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getConnect</span></span>(user: <span class="type">String</span>, pwd: <span class="type">String</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特质构造顺序"><a href="#特质构造顺序" class="headerlink" title="特质构造顺序"></a><strong>特质构造顺序</strong></h4><blockquote><p>特质也是有构造器的，构造器中的内容由“字段的初始化”和一些其他语句构成。具体实现请参考“特质叠加”</p></blockquote><ul><li><strong>第一种特质构造顺序(声明类的同时混入特质)</strong></li></ul><blockquote><ol><li>调用当前类的超类构造器</li><li>第一个特质的父特质构造器</li><li>第一个特质构造器</li><li>第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行</li><li>第二个特质构造器</li><li>…….重复 4,5 的步骤(如果有第 3 个，第 4 个特质)</li></ol></blockquote><ul><li><strong>第 2 种特质构造顺序(在构建对象时，动态混入特质)</strong></li></ul><blockquote><ol><li>调用当前类的超类构造</li><li>当前类构造</li><li>第一个特质构造器的父特质构造器</li><li>第一个特质构造器.</li><li>第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行</li><li>第二个特质构造器</li><li>……重复 5,6 的步骤(如果有第 3 个，第 4 个特质)</li></ol></blockquote><h4 id="自身类型"><a href="#自身类型" class="headerlink" title="自身类型"></a>自身类型</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#在<span class="type">Logger</span>中已经可以使用<span class="type">Exception</span>中的相关的方法了</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>:<span class="type">Exception</span>=&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>()=&#123;</span><br><span class="line">    println(getMessage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#使用<span class="type">MyLogger</span>时先继承<span class="type">Exception</span>类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">with</span> <span class="title">Logger</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><blockquote><ul><li>方式 1<br>内部类如果想要访问外部类的属性，可以通过外部类对象访问。即：访问方式：<strong>外部类名.this.属性名</strong></li><li>方式 2<br>内部类如果想要访问外部类的属性，也可以通过外部类别名访问(推荐)。即：<strong>访问方式：外部类名别名.属性名</strong> 【外部类名.this 等价 外部类名别名】</li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  myOuter=&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InnerAAA</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用别名的方式来访问外部类的属性和方法，相当于 myouter 是一个外部类的实例 AAA.this</span></span><br><span class="line">    <span class="comment">//这时需要将外部类的属性和方法的定义/声明放在别名后</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(innerAAA: <span class="type">InnerAAA</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(innerAAA)</span><br><span class="line"></span><br><span class="line">      println(myOuter.name)</span><br><span class="line">      println(myOuter.sal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name:<span class="type">String</span>=_</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sal:<span class="type">Double</span>=_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、隐式转换"><a href="#9、隐式转换" class="headerlink" title="9、隐式转换"></a>9、隐式转换</h3><h4 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h4><blockquote><p>隐式值也叫隐式变量，将某个形参变量标记为 implicit，所以编译器会在方法省略隐式参数的情况下去搜索作用域内的隐式值作为缺省参数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式值</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> str1:<span class="type">String</span> = <span class="string">&quot;michong&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(<span class="keyword">implicit</span> name:<span class="type">String</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(name)</span><br><span class="line">    &#125;</span><br><span class="line">    hello</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h4><blockquote><ul><li><ol><li>其所带的 构造参数有且只能有一个</li></ol></li><li><ol start="2"><li>隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的(top-level objects)</li></ol></li><li><ol start="3"><li>隐式类不能是 case class（case class 在后续介绍样例类）</li></ol></li><li><ol start="4"><li>作用域内不能有与之相同名称的标识符</li></ol></li></ul></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> db = <span class="keyword">new</span> <span class="type">MySql</span></span><br><span class="line">    db.add()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//隐式类</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">DB</span>(<span class="params">val m :<span class="type">MySql</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;添加&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MySql</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式函数"><a href="#隐式函数" class="headerlink" title="隐式函数"></a>隐式函数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.scala.day2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式函数</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">addDelete</span></span>(mySql: <span class="type">MySql</span>):<span class="type">DB</span>=&#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="type">DB</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> db = <span class="keyword">new</span> <span class="type">MySql</span></span><br><span class="line">    db.delete()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MySql</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;删除数据！！！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式解析机制"><a href="#隐式解析机制" class="headerlink" title="隐式解析机制"></a>隐式解析机制</h4><blockquote><ul><li><ol><li>首先会在 当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）。(一般是这种情况)</li></ol></li><li><ol start="2"><li>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生模块，一个隐式实体的类型 T 它的查找范围如下( 第二种情况范围广且复杂在使用时，应当尽量避免出现)：</li></ol></li><li><p>a) 如果 T 被定义为 T with A with B with C,那么 A,B,C 都是 T 的部分，在 T 的隐式解析过程中，它们的伴生对象都会被搜索。</p></li><li><p>b) 如果 T 是参数化类型，那么类型参数和与类型参数相关联的部分都算作 T 的部分，比如 List[String]的隐式搜索会搜索 List 的伴生对象和 String 的伴生对象。</p></li><li><p>c) 如果 T 是一个单例类型 p.T，即 T 是属于某个 p 对象内，那么这个 p 对象也会被搜索。</p></li><li><p>d) 如果 T 是个类型注入 S#T，那么 S 和 T 都会被搜索。</p></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Scala combines object-oriented and functional programming in one concise, high-level language. Scala&#39;s static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.</summary>
    
    
    
    <category term="编程语言" scheme="https://www.buildworld.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Scala" scheme="https://www.buildworld.cn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>BigData-Apache HBase数据库</title>
    <link href="https://www.buildworld.cn/2020/07/09/BigData-Apache-HBase%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://www.buildworld.cn/2020/07/09/BigData-Apache-HBase%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-07-09T08:13:00.000Z</published>
    <updated>2020-07-10T08:03:23.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h2 id="HBase-1"><a href="#HBase-1" class="headerlink" title="HBase"></a>HBase</h2><blockquote><p>Apache](<a href="https://www.apache.org/">https://www.apache.org/</a>) HBase™ is the <a href="https://hadoop.apache.org/">Hadoop</a> database, a distributed, scalable, big data store.</p></blockquote><h2 id="一、HBase原理"><a href="#一、HBase原理" class="headerlink" title="一、HBase原理"></a>一、HBase原理</h2><h3 id="1、数据模型"><a href="#1、数据模型" class="headerlink" title="1、数据模型"></a>1、数据模型</h3><h4 id="1-）-Name-Space"><a href="#1-）-Name-Space" class="headerlink" title="1 ） Name Space"></a>1 ） Name Space</h4><blockquote><p>命名空间，类似于关系型数据库的 DatabBase 概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是 <code>hbase</code> 和 <code>default</code>，hbase 中存放的是 HBase 内置的表，default 表是用户默认使用的命名空间。</p></blockquote><h4 id="2-）-Region"><a href="#2-）-Region" class="headerlink" title="2 ） Region"></a>2 ） Region</h4><blockquote><p>类似于关系型数据库的表概念。不同的是，HBase 定义表时只需要声明列族即可，不需要声明具体的列。这意味着，往 HBase 写入数据时，字段可以动态、按需指定。因此，和关系型数据库相比，HBase 能够轻松应对字段变更的场景。</p></blockquote><h4 id="3-）-Row"><a href="#3-）-Row" class="headerlink" title="3 ） Row"></a>3 ） Row</h4><blockquote><p>HBase 表中的每行数据都由一个 <code>RowKey</code> 和多个  <code>Column</code>（列）组成，数据是按照 <code>RowKey</code>的字典顺序存储的，并且查询数据时只能根据 <code>RowKey</code> 进行检索，所以 <code>RowKey</code> 的设计十分重要。</p></blockquote><h4 id="4-）-Column"><a href="#4-）-Column" class="headerlink" title="4 ） Column"></a>4 ） Column</h4><blockquote><p>HBase 中的每个列都由 Column Family(列族)和 Column Qualifier（列限定符）进行限定，例如 <code>info：name，info：age</code>。建表时，只需指明列族，而列限定符无需预先定义。</p></blockquote><h3 id="2、HBase基础架构"><a href="#2、HBase基础架构" class="headerlink" title="2、HBase基础架构"></a>2、HBase基础架构</h3><p><img src="https://file.buildworld.cn/img/20200705133837.png"></p><h4 id="1-）-Region-Server"><a href="#1-）-Region-Server" class="headerlink" title="1 ） Region Server"></a>1 ） Region Server</h4><blockquote><p><code>Region Server</code> 为 Region 的管理者，其实现类为 <code>HRegionServer</code>，主要作用如下:<br>对于数据的操作：<code>get, put, delete</code>；<br>对于 Region 的操作：<code>splitRegion、compactRegion</code>。</p></blockquote><h3 id="2-）-Master"><a href="#2-）-Master" class="headerlink" title="2 ） Master"></a>2 ） Master</h3><blockquote><p><code>Master</code> 是所有 <code>Region Server</code> 的管理者，其实现类为 <code>HMaster</code>，主要作用如下：<br>对于表的操作：<code>create, delete, alter</code><br>对于<code>RegionServer</code>的操作：分配<code>regions</code>到每个<code>RegionServer</code>，监控每个<code>RegionServer</code>的状态，负载均衡和故障转移。</p></blockquote><h4 id="3-）-Zookeeper"><a href="#3-）-Zookeeper" class="headerlink" title="3 ） Zookeeper"></a>3 ） Zookeeper</h4><blockquote><p><code>HBase</code> 通过 <code>Zookeeper</code> 来做 Master 的高可用、<code>RegionServer</code> 的监控、元数据的入口以及集群配置的维护等工作。</p></blockquote><h4 id="4-）-HDFS"><a href="#4-）-HDFS" class="headerlink" title="4 ） HDFS"></a>4 ） HDFS</h4><blockquote><p><code>HDFS</code> 为 <code>HBase</code> 提供最终的底层数据存储服务，同时为 <code>HBase</code> 提供高可用的支持。</p></blockquote><h3 id="3、HBase架构详解"><a href="#3、HBase架构详解" class="headerlink" title="3、HBase架构详解"></a>3、HBase架构详解</h3><p><img src="https://file.buildworld.cn/img/20200706133638.png"></p><h4 id="1）StoreFile"><a href="#1）StoreFile" class="headerlink" title="1）StoreFile"></a>1）StoreFile</h4><blockquote><p>保存实际数据的物理文件，<code>StoreFile</code> 以 <code>HFile</code> 的形式存储在 HDFS 上。每个 <code>Store</code> 会有一个或多个 <code>StoreFile（HFile</code>），数据在每个 <code>StoreFile</code> 中都是有序的。</p></blockquote><h4 id="2）MemStore"><a href="#2）MemStore" class="headerlink" title="2）MemStore"></a>2）MemStore</h4><blockquote><p>写缓存，由于 <code>HFile</code> 中的数据要求是有序的，所以数据是先存储在 <code>MemStore</code> 中，排好序后，等到达刷写时机才会刷写到 <code>HFile</code>，每次刷写都会形成一个新的 <code>HFile</code>。 </p></blockquote><h4 id="3）WAL（Write-Ahead-logfile）"><a href="#3）WAL（Write-Ahead-logfile）" class="headerlink" title="3）WAL（Write-Ahead logfile）"></a>3）WAL（Write-Ahead logfile）</h4><blockquote><p>由于数据要经 <code>MemStore</code> 排序后才能刷写到 <code>HFile</code>，但把数据保存在内存中会有很高的概率导致数据丢失，为了解决这个问题，数据会先写在一个叫做 <code>Write-Ahead logfile</code> 的文件中，然后再写入 <code>MemStore</code> 中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。<strong>（HLog）</strong></p></blockquote><h3 id="4、HBase写流程"><a href="#4、HBase写流程" class="headerlink" title="4、HBase写流程"></a>4、HBase写流程</h3><p><img src="https://file.buildworld.cn/img/20200706193753.png"></p><blockquote><ul><li>1）<code>Client</code> 先访问 <code>zookeeper</code>，获取 <code>hbase:meta</code> 表位于哪个 <code>Region Server</code>。 </li><li>2）访问对应的 <code>Region Server</code>，获取 <code>hbase:meta</code> 表，根据读请求的 <code>namespace:table/rowkey</code>，查询出目标数据位于哪个 <code>Region Server</code> 中的哪个 <code>Region</code> 中。并将该 <code>table</code> 的 <code>region</code> 信息以及 <code>meta</code> 表的位置信息缓存在客户端的 <code>meta cache</code>，方便下次访问。</li><li>3）与目标 <code>Region Server</code> 进行通讯；</li><li>4）将数据顺序写入（追加）到 WAL； </li><li>5）将数据写入对应的 <code>MemStore</code>，数据会在 <code>MemStore</code> 进行排序； </li><li>6）向客户端发送 <code>ack</code>； </li><li>7）等达到 <code>MemStore</code> 的刷写时机后，将数据刷写到 <code>HFile</code>。</li></ul></blockquote><h3 id="5、读流程"><a href="#5、读流程" class="headerlink" title="5、读流程"></a>5、读流程</h3><p><img src="https://file.buildworld.cn/img/20200706223000.png"></p><blockquote><ul><li>1）<code>Client</code> 先访问 <code>zookeeper</code>，获取 <code>hbase:meta</code> 表位于哪个 <code>Region Server</code>。 </li><li>2）访问对应的 <code>Region Server</code>，获取 <code>hbase:meta</code> 表，根据读请求的 <code>namespace:table/rowkey</code>，查询出目标数据位于哪个 <code>Region Server</code> 中的哪个 <code>Region</code> 中。并将该 <code>table</code> 的 <code>region</code> 信息以及 <code>meta</code> 表的位置信息缓存在客户端的 <code>meta cache</code>，方便下次访问。</li><li>3）与目标 <code>Region Server</code> 进行通讯；</li><li>4）分别在 <code>Block Cache</code>（读缓存），<code>MemStore</code> 和 <code>Store File（HFile）</code>中查询目标数据，并将查到的所有数据进行合并。此处所有数据是指同一条数据的不同版本<code>（time stamp）</code>或者不同的类型<code>（Put/Delete）</code>。</li><li>5） 将从文件中查询到的数据块（Block，HFile 数据存储单元，默认大小为 64KB）缓存到<code>Block Cache</code>。 </li><li>6）将合并后的最终结果返回给客户端。</li></ul></blockquote><p><strong>内存和磁盘同时读取，但是将两个数据进行对比，返回时间戳大的数据，所以说HBase读取比写入要慢得多</strong></p><h3 id="6、StoreFile-Compaction"><a href="#6、StoreFile-Compaction" class="headerlink" title="6、StoreFile Compaction"></a>6、<strong>StoreFile Compaction</strong></h3><blockquote><p><code>Compaction</code> 分为两种，分别是 <code>Minor Compaction</code> 和 <code>Major Compaction</code>。<code>Minor Compaction</code>会将临近的若干个较小的 <code>HFile</code> 合并成一个较大的 <code>HFile</code>，但<strong>不会清理过期和删除的数据</strong>。<code>Major Compaction</code> 会将一个 <code>Store</code> 下的所有的 <code>HFile</code> 合并成一个大 <code>HFile</code>，并且<strong>会清理掉过期和删除的数据</strong>。 </p></blockquote><p><img src="https://ae01.alicdn.com/kf/Hfc24467fbef54cd39b2f87d5a53bd52cs.jpg"></p><h2 id="二、HBase-API使用（Java）"><a href="#二、HBase-API使用（Java）" class="headerlink" title="二、HBase API使用（Java）"></a>二、HBase API使用（Java）</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、Java调用"><a href="#2、Java调用" class="headerlink" title="2、Java调用"></a>2、Java调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.buildworld.hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MiChong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-07-09 19:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Admin admin = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1、获取配置文件信息</span></span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop102,hadoop103,hadoop104&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2、创建连接对象</span></span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、创建Admin对象</span></span><br><span class="line">            admin = connection.getAdmin();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (admin != <span class="keyword">null</span>) &#123;</span><br><span class="line">            admin.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、判断表是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTabExist</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//3、判断表是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = admin.tableExists(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(String tableName, String... cfs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断参数是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (cfs.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请设置&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (isTabExist(tableName)) &#123;</span><br><span class="line">            System.out.println(tableName + <span class="string">&quot;表已经存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建表描述器</span></span><br><span class="line">        HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String cf : cfs) &#123;</span><br><span class="line">            <span class="comment">//创建列族描述器</span></span><br><span class="line">            HColumnDescriptor hColumnDescriptor = <span class="keyword">new</span> HColumnDescriptor(cf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加具体的列族信息</span></span><br><span class="line">            hTableDescriptor.addFamily(hColumnDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建表</span></span><br><span class="line">        admin.createTable(hTableDescriptor);</span><br><span class="line">        System.out.println(tableName + <span class="string">&quot;表创建成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、删除表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dropTable</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!isTabExist(tableName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要删除的表不存在！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、使表下线</span></span><br><span class="line">        admin.disableTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、删除表</span></span><br><span class="line">        admin.deleteTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        System.out.println(tableName + <span class="string">&quot;表删除成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、创建命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createNameSpace</span><span class="params">(String ns)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建命名空间描述器</span></span><br><span class="line">        NamespaceDescriptor build = NamespaceDescriptor.create(ns).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建命名空间</span></span><br><span class="line">            admin.createNamespace(build);</span><br><span class="line">            System.out.println(ns + <span class="string">&quot;命名空间已经创建完成！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamespaceExistException ne) &#123;</span><br><span class="line">            System.out.println(ns + <span class="string">&quot;命名空间已经存在！！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、往表里面插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putData</span><span class="params">(String tableName, String rowKey, String cf, String cn, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取表对象</span></span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建put对象</span></span><br><span class="line">        Put put = <span class="keyword">new</span> Put(Bytes.toBytes(rowKey));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给put对象赋值</span></span><br><span class="line">        put.addColumn(Bytes.toBytes(cf), Bytes.toBytes(cn), Bytes.toBytes(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        table.put(put);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String tableName, String rowKey, String cf, String cn)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取表对象</span></span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、创建Get对象</span></span><br><span class="line">        Get get = <span class="keyword">new</span> Get(Bytes.toBytes(rowKey));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置获取指定族的值</span></span><br><span class="line">        <span class="comment">//get.addFamily(Bytes.toBytes(cf));</span></span><br><span class="line">        <span class="comment">//获取指定族和指定列的值</span></span><br><span class="line">        get.addColumn(Bytes.toBytes(cf), Bytes.toBytes(cn));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、获取数据</span></span><br><span class="line">        Result result = table.get(get);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、解析result</span></span><br><span class="line">        Cell[] cells = result.rawCells();</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : cells) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CF:&quot;</span> + Bytes.toString(CellUtil.cloneFamily(cell))</span><br><span class="line">                    + <span class="string">&quot; --CN:&quot;</span> + Bytes.toString(CellUtil.cloneQualifier(cell))</span><br><span class="line">                    + <span class="string">&quot; --Value:&quot;</span> + Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scanTable</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取表对象</span></span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取扫描器</span></span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan(Bytes.toBytes(<span class="string">&quot;1001&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CF:&quot;</span> + Bytes.toString(CellUtil.cloneFamily(cell))</span><br><span class="line">                        + <span class="string">&quot; --CN:&quot;</span> + Bytes.toString(CellUtil.cloneQualifier(cell))</span><br><span class="line">                        + <span class="string">&quot; --Value:&quot;</span> + Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8、删除数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(String tableName, String rowKey, String cf, String cn)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建删除对象</span></span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(rowKey));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除指定的列族</span></span><br><span class="line">        <span class="comment">//delete.addFamily(Bytes.toBytes(cf));</span></span><br><span class="line">        delete.addColumns(Bytes.toBytes(cf), Bytes.toBytes(cn));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行删除操作</span></span><br><span class="line">        table.delete(delete);</span><br><span class="line"></span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、测试表是否存在</span></span><br><span class="line">        <span class="comment">// System.out.println(isTabExist(&quot;student&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、创建表测试</span></span><br><span class="line">        <span class="comment">//createTable(&quot;idea:java&quot;, &quot;class&quot;, &quot;desc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、删除表测试</span></span><br><span class="line">        <span class="comment">//dropTable(&quot;teacher&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、测试命名空间创建</span></span><br><span class="line">        <span class="comment">//createNameSpace(&quot;idea&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、测试插入如数据</span></span><br><span class="line">        <span class="comment">//putData(&quot;student&quot;,&quot;1003&quot;,&quot;info&quot;,&quot;name&quot;,&quot;michong&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、获取表数据</span></span><br><span class="line">        <span class="comment">//getData(&quot;student&quot;, &quot;1001&quot;, &quot;info&quot;, &quot;sex&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、扫描表</span></span><br><span class="line">        <span class="comment">//scanTable(&quot;student&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、测试删除</span></span><br><span class="line">        deleteData(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;1002&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Apache HBase™ is the Hadoop database, a distributed, scalable, big data store.</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="HBase" scheme="https://www.buildworld.cn/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>BCI-EEG脑电数据处理</title>
    <link href="https://www.buildworld.cn/2020/07/07/BCI-EEG%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://www.buildworld.cn/2020/07/07/BCI-EEG%E8%84%91%E7%94%B5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2020-07-07T11:42:56.000Z</published>
    <updated>2021-04-09T02:13:38.361Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="EEG脑电数据处理"><a href="#EEG脑电数据处理" class="headerlink" title="EEG脑电数据处理"></a>EEG脑电数据处理</h2><blockquote><p>脑电波（Electroencephalogram,EEG）是一种使用电生理指标记录大脑活动的方法，大脑在活动时，大量神经元同步发生的突触后电位经总和后形成的。它记录大脑活动时的电波变化，是脑神经细胞的电生理活动在大脑皮层或头皮表面的总体反映。脑机接<br>口（BCI），是一种通过检测中枢神经系统活动并将其转化为人工输出，来替代、修复、增强、补充或者改善中枢神经系统的正常输出，从而改变中枢神经系统与内外环境之间的交互作用的技术。</p></blockquote><h3 id="一、十大基本步骤"><a href="#一、十大基本步骤" class="headerlink" title="一、十大基本步骤"></a>一、十大基本步骤</h3><h4 id="1、-定位通道位置"><a href="#1、-定位通道位置" class="headerlink" title="1、 定位通道位置"></a>1、 定位通道位置</h4><blockquote><p>将EEG数据加载进eeglab之后，<code>eeglab</code>能够读取到的仅仅是每一个通道的名称和数值，但是它并不知道这个通道是位于头皮上的什么地方，因此我们需要加载进一个跟记录数据时相匹配的通道位置信息</p></blockquote><blockquote><p>eeglab中默认的文件是 <strong>standard-10-5-cap385(<a href="https://mp.weixin.qq.com/s?__biz=MzU5NjU4OTc4MA==&mid=2247484433&idx=1&sn=1d4bba3c10192920d8255d899a6d8f28&chksm=fe6129aac916a0bc648142cb3a53c0679cd1c03a21c20553bba0b4858c613cd6dd0e73e8b727&scene=21#wechat_redirect">国际10-5系统</a>)</strong></p></blockquote><h4 id="2、删除无用通道"><a href="#2、删除无用通道" class="headerlink" title="2、删除无用通道"></a>2、删除无用通道</h4><blockquote><p>在<strong>EEGLAB</strong>中预处理数据的时候，使用<code>ICA</code>方式去除眼电成分，这种方式可以不用眼电通道数据的参与就可以进行。</p></blockquote><h4 id="3、滤波"><a href="#3、滤波" class="headerlink" title="3、滤波"></a>3、滤波</h4><blockquote><p>滤波分为<code>高通滤波</code>，<code>低通滤波</code>，<code>带通滤波</code>和<code>凹陷滤波</code>。</p></blockquote><ul><li><strong>高通滤波</strong>是指，高于某个频率的信号可以通过，而低于这个频率的信号会被衰减过滤掉。而<strong>低通滤波</strong>则相反，指的是低于某个频率的信号可以通过，而高于这个频率的信号则相反。所以，在输入数值的时候，高通滤波要输入的是一个较小的数字，而低通滤波则是输入一个较大的数字。这可能跟我们的第一反应有点相悖。因此，也可以用它们的英文叫法来辨别，高通<code>high-pass</code>，低通<code>low-pass</code>，英文看起来就更为直观了。</li><li><strong>带通滤波</strong>，指的是在某个频率段范围内的信号可以通过，而这个频率段范围以外的信号会被衰减过滤掉，就相当于同时做了高通滤波和低通滤波。</li><li><strong>凹陷滤波</strong>，指的是在某个频率范围内的信号会被衰减过滤掉，而这个频率范围以外的信号会被保留下来。这个操作通常是用来去除50Hz市电的干扰。我国的50Hz，因此在收集到的信号中，会有一个非常强烈的50Hz频段的信号存在，这就可以用凹陷滤波来去掉。</li></ul><h4 id="4、分段"><a href="#4、分段" class="headerlink" title="4、分段"></a>4、分段</h4><blockquote><p>数据打上<strong>mark</strong>，将数据切分为一段一段，在这些范围以外的的数据，直接去除。</p><p>一般的ERP分段在事件前200毫秒到事件后1000毫秒这个时间段就足够了，因为几乎所有的ERP成分，都是在1秒以内产生的。但是如果后期还要做时频分析的话，则需要将分段时间拉长，扩大到事件前1秒到事件后2秒这个时间段内，因为时频分析的算法，要求数据要有一定的长度。</p></blockquote><h4 id="5、基线校正"><a href="#5、基线校正" class="headerlink" title="5、基线校正"></a>5、基线校正</h4><blockquote><p>被试被认为是处于一个相对平静的状态，此时的脑电活动代表了一个平静状态下的脑电活动，将这段时间内的脑电活动当做成一个基线。</p><p>一般来说，都是以分段中，事件之前这段时间来作为基线的，比如分段为-200毫秒到1000毫秒，那就将所有的数据，减去前200毫米以内数据的均值。</p><p>基线校正的第二个作用是<strong>防止数据漂移带来的影响</strong>。有时候因为某些原因，我们采集到的数据，会呈现一个逐渐缓慢向上漂移的趋势，而在分完段之后，由于向上飘的影响，每一段数据的起点将不在同一个地方，也会使得这段数据的绝对波幅变高。而基线校正就可以校正这种漂移带来的影响，让每一段数据都拥有一个差不多的起点。</p></blockquote><h4 id="6、重参考"><a href="#6、重参考" class="headerlink" title="6、重参考"></a>6、重参考</h4><blockquote><ul><li>首先要解释的是参考的定义。我们看到采集之后的数据是一个个的数值，但这个数值是什么意思呢，就是电极所在位置跟参考电极之间的电位差。</li><li>一般在脑电记录的时候会采用的参考电极有鼻尖参考，cz或头顶中央参考，还有单侧乳突参考，乳突就是耳朵后面一小块突起的区域。我们所看到的每个通道的数值，其实就是指这个通道跟参考通道之间的电位差。</li><li>在分析数据的时候，有时候我们会想要转换参考点的位置。因为不同位置的参考，会对数据造成一定的影响。比如记录时采用的是cz或头顶中央参考，那么自然地，距离cz点较近的电极点，记录到的电位差会非常小，而离得远的电极记录到的电位差就自然会大一点，这种大与小的差异，并不是由认知活动产生的，而是由记录方式产生的。又比如，单侧乳突参考，那脑袋左边的电极点跟右边的电极点，也会存在着记录方式不同产生的电位差不同。</li><li>常用的一些参考位置有双侧乳突平均参考，指将两个乳突数据的平均值作为参考数据，或者是全脑平均参考，指的是将全脑所有数据的均值作为参考数据的方法，不过使用全脑平均参考的时候要注意，眼电数据不要纳入其中，因为眼电数据的波动起伏非常大，很容易对数据造成比较大的干扰。</li></ul></blockquote><h4 id="7、降低采样率"><a href="#7、降低采样率" class="headerlink" title="7、降低采样率"></a>7、降低采样率</h4><blockquote><ul><li>采样率的单位是Hz，指的是一秒内要记录多少个数据点的意思，比如原始数据的采样率是1000Hz的话，就是代表一秒内有1000个数据点。</li><li>在后期分析的时候，我们有时候会想要降低采样率，比如降到500Hz或者250Hz。这样做最大的好处其实就是减小数据量，以提高计算速度，没有其他的作用了。所以这一步并不是必须的。</li><li>但降低采样率需要注意两点，<strong>一是降低采样率要在滤波之后</strong>。因为降低采样率会使我们丢失高频信息，使高频信息变得扭曲，所以最好在保留了我们感兴趣波段之后再去降低采样率，这样可以保证信号最大程度不会失真。<strong>二是有一个采样定理，</strong>理论上来说，我们的采样率必须是我们想要分析的波段的两倍，比如我们想要分析60Hz的波，那数据采样率为120Hz就足够了。实际上，建议采样率最好在分析波段的三到四倍。</li></ul></blockquote><h4 id="8、插值坏导"><a href="#8、插值坏导" class="headerlink" title="8、插值坏导"></a>8、插值坏导</h4><blockquote><ul><li>在做完上述这些处理之后，可以保存一下数据。因为在这之前的操作，是每个被试都需要做的基础操作，后期我们可以通过代码来实现批处理。而在这之后的操作，是需要根据每个被试的具体情况具体分析去处理的，因此只能一个个做，不能进行批处理。</li><li>从这一步开始可以说是真正的去除伪迹的过程了。去伪迹大体分为两种，<code>横向操作</code>和<code>纵向操作</code>，<strong>横向即对通道进行校正操作，对数据不好的导联进行插值处理，纵向是指挑出数据不好的trials，删除掉。</strong>建议是先横向处理后再纵向剔除，尽量保留下更多的trials数。</li><li>EEGLAB中插值坏导有两种方式，<strong>一种是以某通道周围几个通道的数据的平均值，来替代这个通道的数据，这种直接通过代码实现即可。</strong> <strong>另外一种是EEGLAB里内置的一种算法实现</strong>，具体换算是什么过程我也不太清楚，但是我问过贾会宾老师，他是推荐使用第二种方法。原因在于，我们记录的是头皮脑电，头是一个球体，因此直接用周围数据的均值来代替这种方法有点粗糙，而EEGLAB内置的方法则会考虑到容积传导效应，以及近的点和远的点贡献的权重不同来进行插值，因此会更加有效。</li></ul></blockquote><h4 id="9、独立主成分分析"><a href="#9、独立主成分分析" class="headerlink" title="9、独立主成分分析"></a>9、独立主成分分析</h4><p><strong><a href="https://mp.weixin.qq.com/s?__biz=MzU5NjU4OTc4MA==&mid=2247486858&idx=1&sn=abb9ba31da1264ca1f2d5a690ee04b4d&chksm=fe612031c916a927a710161d50ac9e5c8969b02141c5952c739e4689d61f59bbdf8e391f7186&scene=21#wechat_redirect">如何识别ICA成分</a></strong></p><blockquote><p>这是一个很有用但也很难的方法，我并不是十分清楚它的原理，只能大概理解，也只能大概描述一下。前面说过，我们记录到的是头皮脑电，脑电帽上划出了一个个的点来表示位置，但是我们在<code>FPz</code>点记录到的数据，就真的是<code>FPz</code>点这个位置头皮下方的区域所产生的电活动？不一定。做过实验的都知道，眨眼会产生影响，左右看会产生影响，帽子戴得太紧导致肌肉紧张也会产生影响，还有左右的<code>FP1，FP2</code>处产生的电活动也会影响到<code>FPz</code>，甚至在离它最远的Oz点下方产生的电活动，也有可能对前方<code>FPz</code>点产生微弱的影响。因为真正的电活动产生于头皮下方颅骨内部，它经过了这么一层又一层的传播之后，不同源的电活动肯定会相互影响，从而导致某个记录点记录到的数据，混合了很多不同成分的电活动。而独立主成分分析，就是要对记录点的数据做一个逆运算，把每个记录点的数据， 分解成一个又一个的成分组成。然后我们再从中剔除掉伪迹成分，比如眨眼的成分，肌肉紧张的成分等，从而得到一个相对干净的数据。</p></blockquote><h4 id="10、剔除坏段"><a href="#10、剔除坏段" class="headerlink" title="10、剔除坏段"></a>10、剔除坏段</h4><blockquote><ul><li>预处理到了这一步，已经接近于完成了。最后一个步骤就是要剔除掉波幅超过100微幅的trial(要求严格一点也可以定位80)，因为波幅起伏这么大的活动，已经不是由认知活动引起的了，肯定是由于其他的动作引起的，所以可以直接剔除掉。</li><li>这一步操作一定要在插值坏导和ICA去除眼电成分之后再做，因为有可能被试眨眼比较频繁，那这么操作下来，有可能就需要删掉接近一半的trials数了，删掉的trials数太多，这个数据也就废了。所以要将它留到最后一步才做，同时，这个操作也能用来检查我们前两步操作是否足够有效。</li></ul></blockquote><h3 id="二、ICA-独立成分分析"><a href="#二、ICA-独立成分分析" class="headerlink" title="二、ICA(独立成分分析)"></a>二、ICA(独立成分分析)</h3><p><strong>ICA是一种分离线性混合源的技术。例如，我们可以尝试混合然后分开两个源。</strong></p><p><a href="https://labeling.ucsd.edu/tutorial/labels">ICA判断网站</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NjU4OTc4MA==&mid=2247485932&idx=1&sn=8749bfe4967f60de387fe7f9ba38be62&chksm=fe612457c916ad41df8ec9f2890458d86ca4ac7df44c360a4e77234e6a26115e40c957cf979a&scene=21#wechat_redirect">结合matlab代码案例解释ICA独立成分分析原理</a></p><h4 id="1、ICA假设"><a href="#1、ICA假设" class="headerlink" title="1、ICA假设"></a>1、ICA假设</h4><blockquote><p>基于ICA的伪影校正可以通过线性分解从EEG数据中分离并去除多种伪影。ICA方法基于以下假设：</p><ul><li>1）在头皮上记录的时间序列是时间上独立的大脑和伪迹活动的空间稳定混合物，</li><li>2）并且大脑，头皮和身体不同部位产生的电势之和为在电极上呈线性关系，</li><li>3）从源到电极的传播延迟可以忽略不计</li></ul></blockquote><h4 id="2、ICA特性"><a href="#2、ICA特性" class="headerlink" title="2、ICA特性"></a>2、ICA特性</h4><blockquote><ul><li>ICA只能分离线性混合的源。</li><li>由于ICA处理的是点云，因此改变点的绘制顺序(EEG中的时间点顺序)对算法的结果几乎没有影响。</li><li>改变通道顺序(例如在EEG中交换电极位置)也不会影响算法的结果。对于脑电信号来说，该算法对电极位置没有先验知识，ICA分量在大多数情况下可以被解析为一个等效偶极子，这证明了ICA能够分离出皮层同步化的致密区域。</li><li> 由于独立分量分析通过最大化源的非高斯性来分离源，所以完美的高斯源是不能被分离的。</li><li> 即使信息源不是独立的，独立分量分析也能找到一个最大独立空间。</li></ul></blockquote><h3 id="三、共空间模式-Common-Spatial-Pattern-CSP"><a href="#三、共空间模式-Common-Spatial-Pattern-CSP" class="headerlink" title="三、共空间模式(Common Spatial Pattern, CSP)"></a>三、共空间模式(Common Spatial Pattern, CSP)</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NjU4OTc4MA==&mid=2247486495&idx=1&sn=3bb4aa2415bf9c48947f700db3a1a69e&chksm=fe6121a4c916a8b2a585a5e3d10aa38d6e578726e77403efabfb05c14d5855a6916ad7b9e93e&scene=21#wechat_redirect">详细介绍地址</a></p><blockquote><p><code>共空间模式（Common Spatial Pattern, CSP）</code>是一种对两分类任务下的空域滤波特征提取算法，能够从多通道的脑机接口数据里面提取出每一类的空间分布成分。公共空间模式算法的基本原理是利用矩阵的对角化，找到一组最优空间滤波器进行投影，使得两类信号的方差值差异最大化，从而得到具有较高区分度的特征向量。</p></blockquote><h4 id="1、CSP发展史"><a href="#1、CSP发展史" class="headerlink" title="1、CSP发展史"></a>1、CSP发展史</h4><p><img src="https://file.buildworld.cn/img/37d37a272098ac16bee4514f24235efe_640_wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1.png" alt="共空间模式（CSP）的研究概况"></p><blockquote><p>由于不同特征的信息包含在信号的不同频段中，因此考虑EEG信号，可以将其分离到不同的特定频段进行分析。在当前研究的特征提取和特征分类算法中，<code>CSP</code>是性能最好和应用最广泛的特征提取方法。<code>CSP</code>将当前数据转换到另一个新的空间，使得类间数据的方差最大化，类内的方差最小化。</p></blockquote><blockquote><p>通常，在运动想象EEG信号分类中，<code>CSP</code>算法往往选择宽频段（4-40HZ）来进行信号处理。研究表明，这个宽频段包含了大多数的运动想象相关的信息，同时，也包含着其他冗余信息，所以不少研究工作重点考虑这个宽频段的选择最佳问题，以此来改善CSP的分类性能。在提出的<code>共空间频谱模式（CSSP）</code>中，<code>有限脉冲响应（FIR）滤波器</code>在<code>CSP滤波器</code>的基础上进行了优化，通过插入时间延迟τ来实现，该时间延迟τ允许单独调谐频率滤波器，评估若干样本点的时间延迟τ值，并且使用10倍交叉验证来选择最佳值。使用带通滤波器对信号进行滤波，然后进行空间滤波和特征提取。实验结果显示CSSP改进了性能。提出的<code>共稀疏频谱空间模式（CSSSP）</code>进一步改进了CSSP方法，其找到所有信道共用的频谱模式，而非CSSP为每个信道找到不同的频谱模式。</p></blockquote><blockquote><p>已经提出的<code>子带公空间模式（SBCSP）</code>，其中在多个子带处对运动图像EEG信号进行滤波，并且从每个子带提取CSP特征。为了减小子带的维数，<code>线性判别分析（LDA）</code>分别应用于每个子带的特征，并融合在一起以进行分类。 SBCSP实现了比CSP，CSSP和CSSSP更高的分类精度。然而，SBCSP忽略了从不同子带获得的CSP特征的可能关联，因此提出了<code>滤波器组CSP（FBCSP）</code>来解决该问题。 FBCSP计算来自多个子带的CSP特征的互信息，以便选择最具辨识性的特征，所选特征使用支持向量机（SVM）分类器进行分类。 FBCSP的表现优于SBCSP，然而，它仍然使用了若干子带，这些子带依然会带来不少的计算成本的增加。所以提出<code>DFBCSP</code>来解决这个问题，DFBCSP利用单信道（C3，C4或Cz）频带功率的Fisher比（FR）来从多个重叠子频带中选择最具判别性的子频带。然后为每个子带提取CSP特征，并使用SVM分类器进行分类。与SBCSP和FBCSP相比，<strong>DFBCSP实现了更高的分类准确度和更低的计算成本。</strong></p></blockquote><h4 id="DFBCSP框架"><a href="#DFBCSP框架" class="headerlink" title="DFBCSP框架"></a>DFBCSP框架</h4><p><img src="https://file.buildworld.cn/img/e2fc1833625a49db3fba73dec5c9f5e0_640_wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1.png" alt="DFBCSP框架"></p><blockquote><p>考虑<code>DFBCSP</code>的优劣，因此提出了一种改进的<code>DFBCSP</code>方法来解决这些问题。首先，使用从使用所有通道数据生成的特征计算的互信息，而不是像在<code>DFBCSP-FR</code>中那样使用单通道频带功率的FR，来选择能够产生最佳结果的频带。而不使用仅使用单个信道频带功率和FR作为选择子频带（<code>DFBCSP-FR</code>）的方法。这是因为EEG信号主要受噪声污染。因此，如果用于计算FR的单个信道被噪声破坏，则选择出来的频段将会影响分类器的分类精度。这导致选择的子带往往不是最有效的子带，因为可能选择了具有冗余信息的子带。因此，文章建议利用所有可用信道数据通过利用互信息来选择最具判别性的子带，以便获得最佳结果。与使用用于频带选择的单信道信息相比，使用所有信道数据进行频带选择减少了选择具有冗余信息的子频带的机会。</p><p>其次，文章不再像在DFBCSP-FR中那样仅使用来自重叠子带的CSP特征，而是结合利用宽带CSP和CSSP的特征信息，文章引入了7-30Hz的单个宽带以及在4-30Hz范围内的12个重叠子带，带宽为4Hz并且重叠2Hz。</p></blockquote><p><strong>改进DFBCSP算法的详细流程框图</strong></p><p><img src="https://file.buildworld.cn/img/604a420080a816a842b035414e8e6e6e_640_wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1.png" alt="改进DFBCSP算法的详细流程框图"></p><h3 id="四、EEG信号特征提取算法-MI方向"><a href="#四、EEG信号特征提取算法-MI方向" class="headerlink" title="四、EEG信号特征提取算法(MI方向)"></a>四、EEG信号特征提取算法(MI方向)</h3><p><strong>EEG信号特征提取就是以脑电信号作为源信号，确定各种参数并以此为向量组成表征信号特征的特征向量。</strong></p><blockquote><p>特征參数主要包括<code>时域信号(如幅值)</code>和<code>频域信号(如频率)</code>两大类，相应的特征提取方法也分为<code>时域法</code>、<code>频域法</code> 和<code>时-频域</code>方法。</p></blockquote><h4 id="1、频域分析"><a href="#1、频域分析" class="headerlink" title="1、频域分析"></a>1、频域分析</h4><blockquote><p>频域分析方法主要是<strong>基于EEG信号各频段功率、相干</strong>等。</p></blockquote><blockquote><p>这类方法是建立在假设EEG信号具有平稳特性的基础上，同时只是考虑信号的频域信息，忽略信号在时间上的分辨率。在EEG信号研究中，常用的频域分析方法包括<code>功率谱估计</code>(<code>直接法和间接法</code>)。</p><p><strong>运动想象EEG信号</strong>的<code>ERD</code>和<code>ERS</code>现象只出现在特定频率范围，比如<code>8-12Hz 的Mu波</code>和<code>18-26Hz 的Beta 波</code>。因此，通过功率谱等谱分析方法，也可以有效地从EEG提取中特征。其中比较出名的方法有自回归功率谱分析、双谱分析法等。</p></blockquote><h4 id="2、时域分析"><a href="#2、时域分析" class="headerlink" title="2、时域分析"></a>2、时域分析</h4><blockquote><p>时域分析方法则主要分析EEG，如<code>幅度</code>、<code>均值</code>、<code>方差</code>、<code>偏歪度</code>、<code>峭度</code>等。</p></blockquote><blockquote><p>这类方法主要是利用EEG波形的性质，如波幅、均值、方差、偏歪度和峭度等对临床EEG记录进行观察分析。在EEG信号研究中，常用的时域分析方法有：<code>过零点分析</code>、<code>直方图分析</code>、<code>方差分析</code>、<code>相关分析</code>、<code>峰值检测</code>、<code>波形参数分析</code>和<code>波形识别</code>等。</p></blockquote><h4 id="3、空域方法："><a href="#3、空域方法：" class="headerlink" title="3、空域方法："></a>3、空域方法：</h4><blockquote><p>这是近年运动想象领域比较通用的特征提取方法，主要通过设计空域滤波器对EEG 的多通道空间分布进行处理，提取可分的特征。包括：<code>共空域模式法（Common spatialpattern，CSP）</code>，以及基于CSP改进的方法。</p></blockquote><p><strong>基于CSP改进的方法包括：</strong></p><ul><li><p>1.时空滤波的共空谱模式（Common spatio-spectralpattern, CSSP）；</p></li><li><p>2.共稀疏谱空模式（Common sparse spectral spatial pattern，CSSSP）；</p></li><li><p>3.正则化公用空间模式（Regularized Common Spatial Pattern, RCSP)等。</p></li></ul><h4 id="4、小波模糊熵的特征提取方法"><a href="#4、小波模糊熵的特征提取方法" class="headerlink" title="4、小波模糊熵的特征提取方法"></a>4、小波模糊熵的特征提取方法</h4><blockquote><p>鉴于脑电信号的非线性特性和运动想象时的节律特性，提出了小波模糊熵的特征提取方法，利用小波变换将EEG信号进行小波分解，得到对应运动想象EEG信号的alpha和beta节律，然后采用模糊熵方法提取特征。</p></blockquote><h4 id="5、常使用的特征提取方法："><a href="#5、常使用的特征提取方法：" class="headerlink" title="5、常使用的特征提取方法："></a>5、常使用的特征提取方法：</h4><ul><li>自回归(auto regressive, AR)</li><li>傅里叶变换(Fourier transform,FT)</li><li>表面拉普拉斯(surface-Laplacian)变换</li><li>小波变换(Wavelet transform,WT)</li></ul><p><strong>快速傅里叶变换(Fast Fourier transform, FFT)</strong></p><blockquote><p>经典的FFT在分析确定信号和平稳信号时很有效，但在分析突变信号的频谱时具有一定的局限性。对于alpha波、beta波等脑电基本节律，功率谱分析或FFT等方法可以从频域中直接提取出特征。</p></blockquote><p><strong>稀疏傅里叶变换(Sparse Fourier transform, SFT)</strong></p><blockquote><p>SFT是时间窗内信号特征的平均，时间窗里信号越短，获得的时间分辨率就越高。该方法在一定程度上克服了FFT不具有的局部分析能力的缺陷，在某些信号处理中有一定的作用。</p></blockquote><p><strong>自适应自回归(Adaptive Auto Regressive ,AAR)</strong></p><blockquote><p>AAR模型参数方法随每一样本点的输入而改变，能够很好地反映大脑的状态。不过，该方法更适合分析平稳的脑电信号，对包含高度非平稳信号的运动想象EEG，该模型是有局限性的。</p></blockquote><p><strong>小波变换(Wavelettransform, WT)</strong></p><blockquote><p>小波变换在低频时的时间分辨率较低，而频率分辨率较高；在高频时的时间分辨率较高，而频率分辨率较低，正符合低频信号变化緩慢而高频信号变化较快的特点。因此小波分析比傅里叶变换和短时傅里叶变换更适合分析非平稳的脑电信号。</p></blockquote><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2zy5g5eac5kwc">https://cloud.tencent.com/developer/support-plan?invite_code=2zy5g5eac5kwc</a></p>]]></content>
    
    
    <summary type="html">脑电波（Electroencephalogram,EEG）是一种使用电生理指标记录大脑活动的方法，大脑在活动时，大量神经元同步发生的突触后电位经总和后形成的。它记录大脑活动时的电波变化，是脑神经细胞的电生理活动在大脑皮层或头皮表面的总体反映。脑机接口（BCI），是一种通过检测中枢神经系统活动并将其转化为人工输出，来替代、修复、增强、补充或者改善中枢神经系统的正常输出，从而改变中枢神经系统与内外环境之间的交互作用的技术。</summary>
    
    
    
    <category term="脑机交互" scheme="https://www.buildworld.cn/categories/%E8%84%91%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="BCI" scheme="https://www.buildworld.cn/tags/BCI/"/>
    
    <category term="EEG" scheme="https://www.buildworld.cn/tags/EEG/"/>
    
    <category term="ICA" scheme="https://www.buildworld.cn/tags/ICA/"/>
    
  </entry>
  
  <entry>
    <title>BigData-消息队列框架Apache Kafka入门、原理解析</title>
    <link href="https://www.buildworld.cn/2020/07/02/BigData-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A1%86%E6%9E%B6Apache-Kafka/"/>
    <id>https://www.buildworld.cn/2020/07/02/BigData-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A1%86%E6%9E%B6Apache-Kafka/</id>
    <published>2020-07-02T07:11:20.000Z</published>
    <updated>2020-09-07T03:11:57.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Kafka–消息队列框架"><a href="#Kafka–消息队列框架" class="headerlink" title="Kafka–消息队列框架"></a>Kafka–消息队列框架</h2><h3 id="1、Kafka-基础架构"><a href="#1、Kafka-基础架构" class="headerlink" title="1、Kafka 基础架构"></a>1、<strong>Kafka</strong> 基础架构</h3><p><img src="https://file.buildworld.cn/img/20200907111151.png"></p><blockquote><p>1）<strong>Producer</strong> ：消息生产者，就是向kafka broker发消息的客户端；<br>2）<strong>Consumer</strong> ：消息消费者，向kafka broker取消息的客户端；<br>3）<strong>Consumer Group （CG）</strong>：消费者组，由多个consumer组成。<code>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个消费者消费；消费者组之间互不影响。</code>所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。<br>4）<strong>Broker ：</strong>一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。<br>5）<strong>Topic</strong> ：可以理解为一个队列，<code>生产者和消费者面向的都是一个topic</code>；<br>6）<strong>Partition</strong>：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，<strong>一个topic可以分为多个partition</strong>，每个partition是一个有序的队列；<br>7）<strong>Replica</strong>：副本，为保证集群中的某个节点发生故障时，<strong>该节点上的partition数据不丢失，且kafka仍然能够继续工作</strong>，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。<br>8）<strong>leader</strong>：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。<br>9）<strong>follower</strong>：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的follower。</p></blockquote><h3 id="2、-Kafka-命令行操作"><a href="#2、-Kafka-命令行操作" class="headerlink" title="2、 Kafka 命令行操作"></a>2、 <strong>Kafka</strong> 命令行操作</h3><h4 id="0）启动kafka"><a href="#0）启动kafka" class="headerlink" title="0）启动kafka"></a>0）启动kafka</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 kafka]$ /opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties</span><br></pre></td></tr></table></figure><h4 id="1）查看所有的topic"><a href="#1）查看所有的topic" class="headerlink" title="1）查看所有的topic"></a>1）查看所有的topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 bin]$ kafka-topics.sh --list --zookeeper hadoop102:2181</span><br></pre></td></tr></table></figure><h4 id="2）创建topic"><a href="#2）创建topic" class="headerlink" title="2）创建topic"></a>2）创建topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 3 --partitions 1 --topic first</span><br></pre></td></tr></table></figure><blockquote><p>选项说明：</p><p><code>--topic</code> 定义topic名</p><p><code>--replication-factor</code>  定义副本数</p><p><code>--partitions</code>  定义分区数</p></blockquote><h4 id="3）删除"><a href="#3）删除" class="headerlink" title="3）删除"></a>3）删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --delete --topic first</span><br></pre></td></tr></table></figure><p><strong>需要server.properties中设置delete.topic.enable=true否则只是标记删除。</strong></p><h4 id="4）发送消息"><a href="#4）发送消息" class="headerlink" title="4）发送消息"></a>4）发送消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 bin]$ kafka-console-producer.sh --broker-list hadoop102:9092 --topic first</span><br></pre></td></tr></table></figure><h4 id="5）消费消息"><a href="#5）消费消息" class="headerlink" title="5）消费消息"></a>5）消费消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop103 kafka]$ kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --from-beginning --topic first</span><br></pre></td></tr></table></figure><p><strong>--from-beginning：会把主题中以往所有的数据都读取出来。</strong></p><h4 id="6）查看某个topic详情"><a href="#6）查看某个topic详情" class="headerlink" title="6）查看某个topic详情"></a>6）查看某个topic详情</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop104 kafka]$ kafka-topics.sh --describe --topic first --zookeeper hadoop102:2181</span><br></pre></td></tr></table></figure><h4 id="7）修改分区"><a href="#7）修改分区" class="headerlink" title="7）修改分区"></a>7）修改分区</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop104 kafka]$ kafka-topics.sh --alter --topic first --zookeeper hadoop102:2181 --partitions 6</span><br></pre></td></tr></table></figure><h3 id="3、Kafka-工作流程"><a href="#3、Kafka-工作流程" class="headerlink" title="3、Kafka 工作流程"></a>3、<strong>Kafka</strong> 工作流程</h3><p><img src="https://file.buildworld.cn/img/20200702172047.png"></p><blockquote><p><code>Kafka</code>中消息是以<code>topic</code>进行分类的，生产者生产消息，消费者消费消息，都是面向<code>topic</code>的。</p><p><code>topic</code>是逻辑上的概念，而<code>partition</code>是物理上的概念，每个<code>partition</code>对应于一个<code>log</code>文件，该<code>log</code>文件中存储的就是<code>producer</code>生产的数据。<code>Producer</code>生产的数据会被不断追加到该<code>log</code>文件末端，且每条数据都有自己的<code>offset</code>。消费者组中的每个消费者，都会实时记录自己消费到了哪个<code>offset</code>，以便出错恢复时，从上次的位置继续消费。</p></blockquote><h3 id="4、Kafka文件存储机制"><a href="#4、Kafka文件存储机制" class="headerlink" title="4、Kafka文件存储机制"></a>4、Kafka文件存储机制</h3><p><img src="https://file.buildworld.cn/img/20200702193119.png"></p><blockquote><p>由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片和索引</strong>机制，将每个<code>partition</code>分为多个<code>segment</code>。每个<code>segment</code>对应两个文件——“<code>.index</code>”文件和“<code>.log</code>”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：<code>topic名称+分区序号</code>。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。</p></blockquote><h3 id="5、Kafka-生产者"><a href="#5、Kafka-生产者" class="headerlink" title="5、Kafka 生产者"></a>5、Kafka 生产者</h3><h4 id="1）分区原因："><a href="#1）分区原因：" class="headerlink" title="1）分区原因："></a>1）分区原因：</h4><ul><li>（1） <strong>方便在集群中扩展</strong>，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了；</li><li>（2） <strong>可以提高并发</strong>，因为可以以 Partition 为单位读写了。</li></ul><h4 id="2）数据可靠保证"><a href="#2）数据可靠保证" class="headerlink" title="2）数据可靠保证"></a>2）数据可靠保证</h4><p><img src="https://file.buildworld.cn/img/20200703102441.png"></p><h5 id="（1）ack"><a href="#（1）ack" class="headerlink" title="（1）ack"></a>（1）ack</h5><blockquote><p>Topic的每个partition收到producer发送的数据后，  都需要向producer发送<code>ack</code>（<code>acknowledgement</code> 确认收到），如果producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p></blockquote><h5 id="（2）in-sync-replica-set-ISR"><a href="#（2）in-sync-replica-set-ISR" class="headerlink" title="（2）in-sync replica set (ISR)"></a>（2）in-sync replica set (ISR)</h5><blockquote><p>Leader 维护了一个动态的 <code>in-sync replica set (ISR)</code>，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果follower长 时 间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR ， 该 时 间 阈 值 由<code>replica.lag.time.max.ms</code> 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p></blockquote><p><strong>ack关系数据丢不丢失的问题，ISR关系数据一致性和存储问题</strong></p><h3 id="6、Kafka消费者"><a href="#6、Kafka消费者" class="headerlink" title="6、Kafka消费者"></a>6、Kafka消费者</h3><h4 id="1）消费方式"><a href="#1）消费方式" class="headerlink" title="1）消费方式"></a>1）消费方式</h4><blockquote><p>消费者采用<code>pull（拉）</code>模式从broker中读取数据。</p><p><code>push（推）</code>模式难以适应消费速率不同的消费者！</p><p>如果kafka没有数据，消费者可能陷入到循环中，一直返回空数据。</p></blockquote><h4 id="2）分配策略"><a href="#2）分配策略" class="headerlink" title="2）分配策略"></a>2）分配策略</h4><ul><li>RoundRobin</li><li>Range（默认的）</li></ul><h4 id="3）offset"><a href="#3）offset" class="headerlink" title="3）offset"></a>3）offset</h4><blockquote><p>下图是记录在zookeeper中的数据结构</p></blockquote><p><img src="https://file.buildworld.cn/img/20200703152929.png"></p><h3 id="7、kafka事务"><a href="#7、kafka事务" class="headerlink" title="7、kafka事务"></a>7、kafka事务</h3><h4 id="1）Producer-事务"><a href="#1）Producer-事务" class="headerlink" title="1）Producer  事务"></a>1）Producer  事务</h4><blockquote><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 <strong>Transaction ID（客户端给予的）</strong>，并将 <code>Producer</code>获得的<code>PID</code>和<code>Transaction ID</code>绑定。这样当Producer重启后就可以通过正在进行的TransactionID 获得原来的 PID。</p><p>为了管理 Transaction，Kafka 引入了一个新的组件 <code>Transaction Coordinator</code>。Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。TransactionCoordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p></blockquote><h4 id="2）Consumer"><a href="#2）Consumer" class="headerlink" title="2）Consumer"></a>2）Consumer</h4><blockquote><p>由于 <code>Consumer</code> 可以通过 <code>offset</code> 访问任意信息，而且不同的 <code>Segment File</code> 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p></blockquote>]]></content>
    
    
    <summary type="html">Kafka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域。</summary>
    
    
    
    <category term="BigData" scheme="https://www.buildworld.cn/categories/BigData/"/>
    
    
    <category term="Hadoop" scheme="https://www.buildworld.cn/tags/Hadoop/"/>
    
    <category term="Apache" scheme="https://www.buildworld.cn/tags/Apache/"/>
    
    <category term="Kafka" scheme="https://www.buildworld.cn/tags/Kafka/"/>
    
  </entry>
  
</feed>
